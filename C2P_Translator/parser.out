Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT_MULTI
    COMMENT_SINGLE

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration_list
Rule 2     declaration_list -> declaration_list declaration
Rule 3     declaration_list -> declaration
Rule 4     declaration -> var_declaration
Rule 5     declaration -> function_declaration
Rule 6     declaration -> function_definition
Rule 7     declaration -> array_declaration
Rule 8     var_declaration -> type_specifier IDENTIFIER SEMICOLON
Rule 9     var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON
Rule 10    var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON
Rule 11    array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
Rule 12    array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
Rule 13    array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
Rule 14    array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
Rule 15    array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
Rule 16    type_specifier -> INT
Rule 17    type_specifier -> FLOAT
Rule 18    type_specifier -> CHAR
Rule 19    type_specifier -> VOID
Rule 20    array_list -> array_list COMMA expression
Rule 21    array_list -> expression
Rule 22    function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN SEMICOLON
Rule 23    function_definition -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement
Rule 24    param_list -> param_list COMMA param
Rule 25    param_list -> param
Rule 26    param_list -> empty
Rule 27    param -> type_specifier IDENTIFIER
Rule 28    param -> type_specifier IDENTIFIER LBRACKET RBRACKET
Rule 29    param -> type_specifier TIMES IDENTIFIER
Rule 30    empty -> <empty>
Rule 31    compound_statement -> LBRACE statement_list RBRACE
Rule 32    statement_list -> statement_list statement
Rule 33    statement_list -> statement
Rule 34    statement -> expression_statement
Rule 35    statement -> compound_statement
Rule 36    statement -> selection_statement
Rule 37    statement -> iteration_statement
Rule 38    statement -> return_statement
Rule 39    statement -> continue_statement
Rule 40    statement -> break_statement
Rule 41    statement -> var_declaration
Rule 42    statement -> array_declaration
Rule 43    statement -> empty
Rule 44    expression_statement -> expression SEMICOLON
Rule 45    expression -> assignment_expression
Rule 46    expression -> binary_expression
Rule 47    expression -> unary_expression
Rule 48    expression -> term
Rule 49    assignment_expression -> IDENTIFIER ASSIGN expression
Rule 50    assignment_expression -> array_access ASSIGN expression
Rule 51    binary_expression -> expression PLUS expression
Rule 52    binary_expression -> expression MINUS expression
Rule 53    binary_expression -> expression TIMES expression
Rule 54    binary_expression -> expression DIVIDE expression
Rule 55    binary_expression -> expression MOD expression
Rule 56    binary_expression -> expression EQ expression
Rule 57    binary_expression -> expression NEQ expression
Rule 58    binary_expression -> expression LT expression
Rule 59    binary_expression -> expression GT expression
Rule 60    binary_expression -> expression LTE expression
Rule 61    binary_expression -> expression GTE expression
Rule 62    binary_expression -> expression AND expression
Rule 63    binary_expression -> expression OR expression
Rule 64    unary_expression -> MINUS expression
Rule 65    unary_expression -> NOT expression
Rule 66    unary_expression -> INC IDENTIFIER
Rule 67    unary_expression -> DEC IDENTIFIER
Rule 68    unary_expression -> IDENTIFIER INC
Rule 69    unary_expression -> IDENTIFIER DEC
Rule 70    term -> IDENTIFIER
Rule 71    term -> INT_LITERAL
Rule 72    term -> FLOAT_LITERAL
Rule 73    term -> CHAR_LITERAL
Rule 74    term -> STRING_LITERAL
Rule 75    term -> LPAREN expression RPAREN
Rule 76    term -> function_call
Rule 77    term -> array_access
Rule 78    function_call -> IDENTIFIER LPAREN argument_list RPAREN
Rule 79    array_access -> IDENTIFIER LBRACKET expression RBRACKET
Rule 80    argument_list -> argument_list COMMA expression
Rule 81    argument_list -> expression
Rule 82    argument_list -> empty
Rule 83    selection_statement -> IF LPAREN expression RPAREN statement
Rule 84    selection_statement -> IF LPAREN expression RPAREN statement ELSE statement
Rule 85    iteration_statement -> WHILE LPAREN expression RPAREN statement
Rule 86    iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement
Rule 87    iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement
Rule 88    return_statement -> RETURN expression SEMICOLON
Rule 89    continue_statement -> CONTINUE SEMICOLON
Rule 90    break_statement -> BREAK SEMICOLON

Terminals, with rules where they appear

AND                  : 62
ASSIGN               : 10 12 13 14 15 49 50
BREAK                : 90
CHAR                 : 18
CHAR_LITERAL         : 73
COMMA                : 20 24 80
COMMENT_MULTI        : 
COMMENT_SINGLE       : 
CONTINUE             : 89
DEC                  : 67 69
DIVIDE               : 54
ELSE                 : 84
EQ                   : 56
FLOAT                : 17
FLOAT_LITERAL        : 72
FOR                  : 86 87
GT                   : 59
GTE                  : 61
IDENTIFIER           : 8 9 10 11 12 13 14 15 22 23 27 28 29 49 66 67 68 69 70 78 79
IF                   : 83 84
INC                  : 66 68
INT                  : 16
INT_LITERAL          : 71
LBRACE               : 12 13 31
LBRACKET             : 11 12 13 14 15 28 79
LPAREN               : 22 23 75 78 83 84 85 86 87
LT                   : 58
LTE                  : 60
MINUS                : 52 64
MOD                  : 55
NEQ                  : 57
NOT                  : 65
OR                   : 63
PLUS                 : 51
RBRACE               : 12 13 31
RBRACKET             : 11 12 13 14 15 28 79
RETURN               : 88
RPAREN               : 22 23 75 78 83 84 85 86 87
SEMICOLON            : 8 9 10 11 12 13 14 15 22 44 88 89 90
STRING_LITERAL       : 14 15 74
TIMES                : 9 29 53
VOID                 : 19
WHILE                : 85
error                : 

Nonterminals, with rules where they appear

argument_list        : 78 80
array_access         : 50 77
array_declaration    : 7 42
array_list           : 12 13 20
assignment_expression : 45
binary_expression    : 46
break_statement      : 40
compound_statement   : 23 35
continue_statement   : 39
declaration          : 2 3
declaration_list     : 1 2
empty                : 26 43 82
expression           : 10 11 12 14 20 21 44 49 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 65 75 79 80 81 83 84 85 86 87 88
expression_statement : 34 86 86 87
function_call        : 76
function_declaration : 5
function_definition  : 6
iteration_statement  : 37
param                : 24 25
param_list           : 22 23 24
program              : 0
return_statement     : 38
selection_statement  : 36
statement            : 32 33 83 84 84 85 86 87
statement_list       : 31 32
term                 : 48
type_specifier       : 8 9 10 11 12 13 14 15 22 23 27 28 29
unary_expression     : 47
var_declaration      : 4 41 87

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration_list
    (2) declaration_list -> . declaration_list declaration
    (3) declaration_list -> . declaration
    (4) declaration -> . var_declaration
    (5) declaration -> . function_declaration
    (6) declaration -> . function_definition
    (7) declaration -> . array_declaration
    (8) var_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (9) var_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (10) var_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (22) function_declaration -> . type_specifier IDENTIFIER LPAREN param_list RPAREN SEMICOLON
    (23) function_definition -> . type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement
    (11) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (12) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (13) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (14) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (15) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (16) type_specifier -> . INT
    (17) type_specifier -> . FLOAT
    (18) type_specifier -> . CHAR
    (19) type_specifier -> . VOID

    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    VOID            shift and go to state 12

    program                        shift and go to state 1
    declaration_list               shift and go to state 2
    declaration                    shift and go to state 3
    var_declaration                shift and go to state 4
    function_declaration           shift and go to state 5
    function_definition            shift and go to state 6
    array_declaration              shift and go to state 7
    type_specifier                 shift and go to state 8

state 1

    (0) S' -> program .



state 2

    (1) program -> declaration_list .
    (2) declaration_list -> declaration_list . declaration
    (4) declaration -> . var_declaration
    (5) declaration -> . function_declaration
    (6) declaration -> . function_definition
    (7) declaration -> . array_declaration
    (8) var_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (9) var_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (10) var_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (22) function_declaration -> . type_specifier IDENTIFIER LPAREN param_list RPAREN SEMICOLON
    (23) function_definition -> . type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement
    (11) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (12) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (13) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (14) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (15) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (16) type_specifier -> . INT
    (17) type_specifier -> . FLOAT
    (18) type_specifier -> . CHAR
    (19) type_specifier -> . VOID

    $end            reduce using rule 1 (program -> declaration_list .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    VOID            shift and go to state 12

    declaration                    shift and go to state 13
    var_declaration                shift and go to state 4
    function_declaration           shift and go to state 5
    function_definition            shift and go to state 6
    array_declaration              shift and go to state 7
    type_specifier                 shift and go to state 8

state 3

    (3) declaration_list -> declaration .

    INT             reduce using rule 3 (declaration_list -> declaration .)
    FLOAT           reduce using rule 3 (declaration_list -> declaration .)
    CHAR            reduce using rule 3 (declaration_list -> declaration .)
    VOID            reduce using rule 3 (declaration_list -> declaration .)
    $end            reduce using rule 3 (declaration_list -> declaration .)


state 4

    (4) declaration -> var_declaration .

    INT             reduce using rule 4 (declaration -> var_declaration .)
    FLOAT           reduce using rule 4 (declaration -> var_declaration .)
    CHAR            reduce using rule 4 (declaration -> var_declaration .)
    VOID            reduce using rule 4 (declaration -> var_declaration .)
    $end            reduce using rule 4 (declaration -> var_declaration .)


state 5

    (5) declaration -> function_declaration .

    INT             reduce using rule 5 (declaration -> function_declaration .)
    FLOAT           reduce using rule 5 (declaration -> function_declaration .)
    CHAR            reduce using rule 5 (declaration -> function_declaration .)
    VOID            reduce using rule 5 (declaration -> function_declaration .)
    $end            reduce using rule 5 (declaration -> function_declaration .)


state 6

    (6) declaration -> function_definition .

    INT             reduce using rule 6 (declaration -> function_definition .)
    FLOAT           reduce using rule 6 (declaration -> function_definition .)
    CHAR            reduce using rule 6 (declaration -> function_definition .)
    VOID            reduce using rule 6 (declaration -> function_definition .)
    $end            reduce using rule 6 (declaration -> function_definition .)


state 7

    (7) declaration -> array_declaration .

    INT             reduce using rule 7 (declaration -> array_declaration .)
    FLOAT           reduce using rule 7 (declaration -> array_declaration .)
    CHAR            reduce using rule 7 (declaration -> array_declaration .)
    VOID            reduce using rule 7 (declaration -> array_declaration .)
    $end            reduce using rule 7 (declaration -> array_declaration .)


state 8

    (8) var_declaration -> type_specifier . IDENTIFIER SEMICOLON
    (9) var_declaration -> type_specifier . TIMES IDENTIFIER SEMICOLON
    (10) var_declaration -> type_specifier . IDENTIFIER ASSIGN expression SEMICOLON
    (22) function_declaration -> type_specifier . IDENTIFIER LPAREN param_list RPAREN SEMICOLON
    (23) function_definition -> type_specifier . IDENTIFIER LPAREN param_list RPAREN compound_statement
    (11) array_declaration -> type_specifier . IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (12) array_declaration -> type_specifier . IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (13) array_declaration -> type_specifier . IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (14) array_declaration -> type_specifier . IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (15) array_declaration -> type_specifier . IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON

    IDENTIFIER      shift and go to state 14
    TIMES           shift and go to state 15


state 9

    (16) type_specifier -> INT .

    IDENTIFIER      reduce using rule 16 (type_specifier -> INT .)
    TIMES           reduce using rule 16 (type_specifier -> INT .)


state 10

    (17) type_specifier -> FLOAT .

    IDENTIFIER      reduce using rule 17 (type_specifier -> FLOAT .)
    TIMES           reduce using rule 17 (type_specifier -> FLOAT .)


state 11

    (18) type_specifier -> CHAR .

    IDENTIFIER      reduce using rule 18 (type_specifier -> CHAR .)
    TIMES           reduce using rule 18 (type_specifier -> CHAR .)


state 12

    (19) type_specifier -> VOID .

    IDENTIFIER      reduce using rule 19 (type_specifier -> VOID .)
    TIMES           reduce using rule 19 (type_specifier -> VOID .)


state 13

    (2) declaration_list -> declaration_list declaration .

    INT             reduce using rule 2 (declaration_list -> declaration_list declaration .)
    FLOAT           reduce using rule 2 (declaration_list -> declaration_list declaration .)
    CHAR            reduce using rule 2 (declaration_list -> declaration_list declaration .)
    VOID            reduce using rule 2 (declaration_list -> declaration_list declaration .)
    $end            reduce using rule 2 (declaration_list -> declaration_list declaration .)


state 14

    (8) var_declaration -> type_specifier IDENTIFIER . SEMICOLON
    (10) var_declaration -> type_specifier IDENTIFIER . ASSIGN expression SEMICOLON
    (22) function_declaration -> type_specifier IDENTIFIER . LPAREN param_list RPAREN SEMICOLON
    (23) function_definition -> type_specifier IDENTIFIER . LPAREN param_list RPAREN compound_statement
    (11) array_declaration -> type_specifier IDENTIFIER . LBRACKET expression RBRACKET SEMICOLON
    (12) array_declaration -> type_specifier IDENTIFIER . LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (13) array_declaration -> type_specifier IDENTIFIER . LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (14) array_declaration -> type_specifier IDENTIFIER . LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (15) array_declaration -> type_specifier IDENTIFIER . LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON

    SEMICOLON       shift and go to state 16
    ASSIGN          shift and go to state 17
    LPAREN          shift and go to state 18
    LBRACKET        shift and go to state 19


state 15

    (9) var_declaration -> type_specifier TIMES . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 20


state 16

    (8) var_declaration -> type_specifier IDENTIFIER SEMICOLON .

    INT             reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    CHAR            reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    $end            reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    RBRACE          reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    LBRACE          reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    IF              reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    RETURN          reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    CONTINUE        reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    BREAK           reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    INC             reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    DEC             reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    INT_LITERAL     reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    CHAR_LITERAL    reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    STRING_LITERAL  reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    LPAREN          reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    ELSE            reduce using rule 8 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)


state 17

    (10) var_declaration -> type_specifier IDENTIFIER ASSIGN . expression SEMICOLON
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 22
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 18

    (22) function_declaration -> type_specifier IDENTIFIER LPAREN . param_list RPAREN SEMICOLON
    (23) function_definition -> type_specifier IDENTIFIER LPAREN . param_list RPAREN compound_statement
    (24) param_list -> . param_list COMMA param
    (25) param_list -> . param
    (26) param_list -> . empty
    (27) param -> . type_specifier IDENTIFIER
    (28) param -> . type_specifier IDENTIFIER LBRACKET RBRACKET
    (29) param -> . type_specifier TIMES IDENTIFIER
    (30) empty -> .
    (16) type_specifier -> . INT
    (17) type_specifier -> . FLOAT
    (18) type_specifier -> . CHAR
    (19) type_specifier -> . VOID

    RPAREN          reduce using rule 30 (empty -> .)
    COMMA           reduce using rule 30 (empty -> .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    VOID            shift and go to state 12

    type_specifier                 shift and go to state 38
    param_list                     shift and go to state 39
    param                          shift and go to state 40
    empty                          shift and go to state 41

state 19

    (11) array_declaration -> type_specifier IDENTIFIER LBRACKET . expression RBRACKET SEMICOLON
    (12) array_declaration -> type_specifier IDENTIFIER LBRACKET . expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (13) array_declaration -> type_specifier IDENTIFIER LBRACKET . RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (14) array_declaration -> type_specifier IDENTIFIER LBRACKET . expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (15) array_declaration -> type_specifier IDENTIFIER LBRACKET . RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    RBRACKET        shift and go to state 43
    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 42
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 20

    (9) var_declaration -> type_specifier TIMES IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 44


state 21

    (49) assignment_expression -> IDENTIFIER . ASSIGN expression
    (68) unary_expression -> IDENTIFIER . INC
    (69) unary_expression -> IDENTIFIER . DEC
    (70) term -> IDENTIFIER .
    (79) array_access -> IDENTIFIER . LBRACKET expression RBRACKET
    (78) function_call -> IDENTIFIER . LPAREN argument_list RPAREN

    ASSIGN          shift and go to state 45
    INC             shift and go to state 46
    DEC             shift and go to state 47
    SEMICOLON       reduce using rule 70 (term -> IDENTIFIER .)
    PLUS            reduce using rule 70 (term -> IDENTIFIER .)
    MINUS           reduce using rule 70 (term -> IDENTIFIER .)
    TIMES           reduce using rule 70 (term -> IDENTIFIER .)
    DIVIDE          reduce using rule 70 (term -> IDENTIFIER .)
    MOD             reduce using rule 70 (term -> IDENTIFIER .)
    EQ              reduce using rule 70 (term -> IDENTIFIER .)
    NEQ             reduce using rule 70 (term -> IDENTIFIER .)
    LT              reduce using rule 70 (term -> IDENTIFIER .)
    GT              reduce using rule 70 (term -> IDENTIFIER .)
    LTE             reduce using rule 70 (term -> IDENTIFIER .)
    GTE             reduce using rule 70 (term -> IDENTIFIER .)
    AND             reduce using rule 70 (term -> IDENTIFIER .)
    OR              reduce using rule 70 (term -> IDENTIFIER .)
    RBRACKET        reduce using rule 70 (term -> IDENTIFIER .)
    RPAREN          reduce using rule 70 (term -> IDENTIFIER .)
    COMMA           reduce using rule 70 (term -> IDENTIFIER .)
    RBRACE          reduce using rule 70 (term -> IDENTIFIER .)
    LBRACKET        shift and go to state 48
    LPAREN          shift and go to state 49


state 22

    (10) var_declaration -> type_specifier IDENTIFIER ASSIGN expression . SEMICOLON
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    SEMICOLON       shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63


state 23

    (45) expression -> assignment_expression .

    SEMICOLON       reduce using rule 45 (expression -> assignment_expression .)
    PLUS            reduce using rule 45 (expression -> assignment_expression .)
    MINUS           reduce using rule 45 (expression -> assignment_expression .)
    TIMES           reduce using rule 45 (expression -> assignment_expression .)
    DIVIDE          reduce using rule 45 (expression -> assignment_expression .)
    MOD             reduce using rule 45 (expression -> assignment_expression .)
    EQ              reduce using rule 45 (expression -> assignment_expression .)
    NEQ             reduce using rule 45 (expression -> assignment_expression .)
    LT              reduce using rule 45 (expression -> assignment_expression .)
    GT              reduce using rule 45 (expression -> assignment_expression .)
    LTE             reduce using rule 45 (expression -> assignment_expression .)
    GTE             reduce using rule 45 (expression -> assignment_expression .)
    AND             reduce using rule 45 (expression -> assignment_expression .)
    OR              reduce using rule 45 (expression -> assignment_expression .)
    RBRACKET        reduce using rule 45 (expression -> assignment_expression .)
    RPAREN          reduce using rule 45 (expression -> assignment_expression .)
    COMMA           reduce using rule 45 (expression -> assignment_expression .)
    RBRACE          reduce using rule 45 (expression -> assignment_expression .)


state 24

    (46) expression -> binary_expression .

    SEMICOLON       reduce using rule 46 (expression -> binary_expression .)
    PLUS            reduce using rule 46 (expression -> binary_expression .)
    MINUS           reduce using rule 46 (expression -> binary_expression .)
    TIMES           reduce using rule 46 (expression -> binary_expression .)
    DIVIDE          reduce using rule 46 (expression -> binary_expression .)
    MOD             reduce using rule 46 (expression -> binary_expression .)
    EQ              reduce using rule 46 (expression -> binary_expression .)
    NEQ             reduce using rule 46 (expression -> binary_expression .)
    LT              reduce using rule 46 (expression -> binary_expression .)
    GT              reduce using rule 46 (expression -> binary_expression .)
    LTE             reduce using rule 46 (expression -> binary_expression .)
    GTE             reduce using rule 46 (expression -> binary_expression .)
    AND             reduce using rule 46 (expression -> binary_expression .)
    OR              reduce using rule 46 (expression -> binary_expression .)
    RBRACKET        reduce using rule 46 (expression -> binary_expression .)
    RPAREN          reduce using rule 46 (expression -> binary_expression .)
    COMMA           reduce using rule 46 (expression -> binary_expression .)
    RBRACE          reduce using rule 46 (expression -> binary_expression .)


state 25

    (47) expression -> unary_expression .

    SEMICOLON       reduce using rule 47 (expression -> unary_expression .)
    PLUS            reduce using rule 47 (expression -> unary_expression .)
    MINUS           reduce using rule 47 (expression -> unary_expression .)
    TIMES           reduce using rule 47 (expression -> unary_expression .)
    DIVIDE          reduce using rule 47 (expression -> unary_expression .)
    MOD             reduce using rule 47 (expression -> unary_expression .)
    EQ              reduce using rule 47 (expression -> unary_expression .)
    NEQ             reduce using rule 47 (expression -> unary_expression .)
    LT              reduce using rule 47 (expression -> unary_expression .)
    GT              reduce using rule 47 (expression -> unary_expression .)
    LTE             reduce using rule 47 (expression -> unary_expression .)
    GTE             reduce using rule 47 (expression -> unary_expression .)
    AND             reduce using rule 47 (expression -> unary_expression .)
    OR              reduce using rule 47 (expression -> unary_expression .)
    RBRACKET        reduce using rule 47 (expression -> unary_expression .)
    RPAREN          reduce using rule 47 (expression -> unary_expression .)
    COMMA           reduce using rule 47 (expression -> unary_expression .)
    RBRACE          reduce using rule 47 (expression -> unary_expression .)


state 26

    (48) expression -> term .

    SEMICOLON       reduce using rule 48 (expression -> term .)
    PLUS            reduce using rule 48 (expression -> term .)
    MINUS           reduce using rule 48 (expression -> term .)
    TIMES           reduce using rule 48 (expression -> term .)
    DIVIDE          reduce using rule 48 (expression -> term .)
    MOD             reduce using rule 48 (expression -> term .)
    EQ              reduce using rule 48 (expression -> term .)
    NEQ             reduce using rule 48 (expression -> term .)
    LT              reduce using rule 48 (expression -> term .)
    GT              reduce using rule 48 (expression -> term .)
    LTE             reduce using rule 48 (expression -> term .)
    GTE             reduce using rule 48 (expression -> term .)
    AND             reduce using rule 48 (expression -> term .)
    OR              reduce using rule 48 (expression -> term .)
    RBRACKET        reduce using rule 48 (expression -> term .)
    RPAREN          reduce using rule 48 (expression -> term .)
    COMMA           reduce using rule 48 (expression -> term .)
    RBRACE          reduce using rule 48 (expression -> term .)


state 27

    (50) assignment_expression -> array_access . ASSIGN expression
    (77) term -> array_access .

    ASSIGN          shift and go to state 64
    SEMICOLON       reduce using rule 77 (term -> array_access .)
    PLUS            reduce using rule 77 (term -> array_access .)
    MINUS           reduce using rule 77 (term -> array_access .)
    TIMES           reduce using rule 77 (term -> array_access .)
    DIVIDE          reduce using rule 77 (term -> array_access .)
    MOD             reduce using rule 77 (term -> array_access .)
    EQ              reduce using rule 77 (term -> array_access .)
    NEQ             reduce using rule 77 (term -> array_access .)
    LT              reduce using rule 77 (term -> array_access .)
    GT              reduce using rule 77 (term -> array_access .)
    LTE             reduce using rule 77 (term -> array_access .)
    GTE             reduce using rule 77 (term -> array_access .)
    AND             reduce using rule 77 (term -> array_access .)
    OR              reduce using rule 77 (term -> array_access .)
    RBRACKET        reduce using rule 77 (term -> array_access .)
    RPAREN          reduce using rule 77 (term -> array_access .)
    COMMA           reduce using rule 77 (term -> array_access .)
    RBRACE          reduce using rule 77 (term -> array_access .)


state 28

    (64) unary_expression -> MINUS . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 65
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 29

    (65) unary_expression -> NOT . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 66
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 30

    (66) unary_expression -> INC . IDENTIFIER

    IDENTIFIER      shift and go to state 67


state 31

    (67) unary_expression -> DEC . IDENTIFIER

    IDENTIFIER      shift and go to state 68


state 32

    (71) term -> INT_LITERAL .

    SEMICOLON       reduce using rule 71 (term -> INT_LITERAL .)
    PLUS            reduce using rule 71 (term -> INT_LITERAL .)
    MINUS           reduce using rule 71 (term -> INT_LITERAL .)
    TIMES           reduce using rule 71 (term -> INT_LITERAL .)
    DIVIDE          reduce using rule 71 (term -> INT_LITERAL .)
    MOD             reduce using rule 71 (term -> INT_LITERAL .)
    EQ              reduce using rule 71 (term -> INT_LITERAL .)
    NEQ             reduce using rule 71 (term -> INT_LITERAL .)
    LT              reduce using rule 71 (term -> INT_LITERAL .)
    GT              reduce using rule 71 (term -> INT_LITERAL .)
    LTE             reduce using rule 71 (term -> INT_LITERAL .)
    GTE             reduce using rule 71 (term -> INT_LITERAL .)
    AND             reduce using rule 71 (term -> INT_LITERAL .)
    OR              reduce using rule 71 (term -> INT_LITERAL .)
    RBRACKET        reduce using rule 71 (term -> INT_LITERAL .)
    RPAREN          reduce using rule 71 (term -> INT_LITERAL .)
    COMMA           reduce using rule 71 (term -> INT_LITERAL .)
    RBRACE          reduce using rule 71 (term -> INT_LITERAL .)


state 33

    (72) term -> FLOAT_LITERAL .

    SEMICOLON       reduce using rule 72 (term -> FLOAT_LITERAL .)
    PLUS            reduce using rule 72 (term -> FLOAT_LITERAL .)
    MINUS           reduce using rule 72 (term -> FLOAT_LITERAL .)
    TIMES           reduce using rule 72 (term -> FLOAT_LITERAL .)
    DIVIDE          reduce using rule 72 (term -> FLOAT_LITERAL .)
    MOD             reduce using rule 72 (term -> FLOAT_LITERAL .)
    EQ              reduce using rule 72 (term -> FLOAT_LITERAL .)
    NEQ             reduce using rule 72 (term -> FLOAT_LITERAL .)
    LT              reduce using rule 72 (term -> FLOAT_LITERAL .)
    GT              reduce using rule 72 (term -> FLOAT_LITERAL .)
    LTE             reduce using rule 72 (term -> FLOAT_LITERAL .)
    GTE             reduce using rule 72 (term -> FLOAT_LITERAL .)
    AND             reduce using rule 72 (term -> FLOAT_LITERAL .)
    OR              reduce using rule 72 (term -> FLOAT_LITERAL .)
    RBRACKET        reduce using rule 72 (term -> FLOAT_LITERAL .)
    RPAREN          reduce using rule 72 (term -> FLOAT_LITERAL .)
    COMMA           reduce using rule 72 (term -> FLOAT_LITERAL .)
    RBRACE          reduce using rule 72 (term -> FLOAT_LITERAL .)


state 34

    (73) term -> CHAR_LITERAL .

    SEMICOLON       reduce using rule 73 (term -> CHAR_LITERAL .)
    PLUS            reduce using rule 73 (term -> CHAR_LITERAL .)
    MINUS           reduce using rule 73 (term -> CHAR_LITERAL .)
    TIMES           reduce using rule 73 (term -> CHAR_LITERAL .)
    DIVIDE          reduce using rule 73 (term -> CHAR_LITERAL .)
    MOD             reduce using rule 73 (term -> CHAR_LITERAL .)
    EQ              reduce using rule 73 (term -> CHAR_LITERAL .)
    NEQ             reduce using rule 73 (term -> CHAR_LITERAL .)
    LT              reduce using rule 73 (term -> CHAR_LITERAL .)
    GT              reduce using rule 73 (term -> CHAR_LITERAL .)
    LTE             reduce using rule 73 (term -> CHAR_LITERAL .)
    GTE             reduce using rule 73 (term -> CHAR_LITERAL .)
    AND             reduce using rule 73 (term -> CHAR_LITERAL .)
    OR              reduce using rule 73 (term -> CHAR_LITERAL .)
    RBRACKET        reduce using rule 73 (term -> CHAR_LITERAL .)
    RPAREN          reduce using rule 73 (term -> CHAR_LITERAL .)
    COMMA           reduce using rule 73 (term -> CHAR_LITERAL .)
    RBRACE          reduce using rule 73 (term -> CHAR_LITERAL .)


state 35

    (74) term -> STRING_LITERAL .

    SEMICOLON       reduce using rule 74 (term -> STRING_LITERAL .)
    PLUS            reduce using rule 74 (term -> STRING_LITERAL .)
    MINUS           reduce using rule 74 (term -> STRING_LITERAL .)
    TIMES           reduce using rule 74 (term -> STRING_LITERAL .)
    DIVIDE          reduce using rule 74 (term -> STRING_LITERAL .)
    MOD             reduce using rule 74 (term -> STRING_LITERAL .)
    EQ              reduce using rule 74 (term -> STRING_LITERAL .)
    NEQ             reduce using rule 74 (term -> STRING_LITERAL .)
    LT              reduce using rule 74 (term -> STRING_LITERAL .)
    GT              reduce using rule 74 (term -> STRING_LITERAL .)
    LTE             reduce using rule 74 (term -> STRING_LITERAL .)
    GTE             reduce using rule 74 (term -> STRING_LITERAL .)
    AND             reduce using rule 74 (term -> STRING_LITERAL .)
    OR              reduce using rule 74 (term -> STRING_LITERAL .)
    RBRACKET        reduce using rule 74 (term -> STRING_LITERAL .)
    RPAREN          reduce using rule 74 (term -> STRING_LITERAL .)
    COMMA           reduce using rule 74 (term -> STRING_LITERAL .)
    RBRACE          reduce using rule 74 (term -> STRING_LITERAL .)


state 36

    (75) term -> LPAREN . expression RPAREN
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 69
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 37

    (76) term -> function_call .

    SEMICOLON       reduce using rule 76 (term -> function_call .)
    PLUS            reduce using rule 76 (term -> function_call .)
    MINUS           reduce using rule 76 (term -> function_call .)
    TIMES           reduce using rule 76 (term -> function_call .)
    DIVIDE          reduce using rule 76 (term -> function_call .)
    MOD             reduce using rule 76 (term -> function_call .)
    EQ              reduce using rule 76 (term -> function_call .)
    NEQ             reduce using rule 76 (term -> function_call .)
    LT              reduce using rule 76 (term -> function_call .)
    GT              reduce using rule 76 (term -> function_call .)
    LTE             reduce using rule 76 (term -> function_call .)
    GTE             reduce using rule 76 (term -> function_call .)
    AND             reduce using rule 76 (term -> function_call .)
    OR              reduce using rule 76 (term -> function_call .)
    RBRACKET        reduce using rule 76 (term -> function_call .)
    RPAREN          reduce using rule 76 (term -> function_call .)
    COMMA           reduce using rule 76 (term -> function_call .)
    RBRACE          reduce using rule 76 (term -> function_call .)


state 38

    (27) param -> type_specifier . IDENTIFIER
    (28) param -> type_specifier . IDENTIFIER LBRACKET RBRACKET
    (29) param -> type_specifier . TIMES IDENTIFIER

    IDENTIFIER      shift and go to state 70
    TIMES           shift and go to state 71


state 39

    (22) function_declaration -> type_specifier IDENTIFIER LPAREN param_list . RPAREN SEMICOLON
    (23) function_definition -> type_specifier IDENTIFIER LPAREN param_list . RPAREN compound_statement
    (24) param_list -> param_list . COMMA param

    RPAREN          shift and go to state 72
    COMMA           shift and go to state 73


state 40

    (25) param_list -> param .

    RPAREN          reduce using rule 25 (param_list -> param .)
    COMMA           reduce using rule 25 (param_list -> param .)


state 41

    (26) param_list -> empty .

    RPAREN          reduce using rule 26 (param_list -> empty .)
    COMMA           reduce using rule 26 (param_list -> empty .)


state 42

    (11) array_declaration -> type_specifier IDENTIFIER LBRACKET expression . RBRACKET SEMICOLON
    (12) array_declaration -> type_specifier IDENTIFIER LBRACKET expression . RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (14) array_declaration -> type_specifier IDENTIFIER LBRACKET expression . RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    RBRACKET        shift and go to state 74
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63


state 43

    (13) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET . ASSIGN LBRACE array_list RBRACE SEMICOLON
    (15) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET . ASSIGN STRING_LITERAL SEMICOLON

    ASSIGN          shift and go to state 75


state 44

    (9) var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .

    INT             reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    CHAR            reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    $end            reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    RBRACE          reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    LBRACE          reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    IF              reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    RETURN          reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    CONTINUE        reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    BREAK           reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    INC             reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    DEC             reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    INT_LITERAL     reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    CHAR_LITERAL    reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    STRING_LITERAL  reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    LPAREN          reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    ELSE            reduce using rule 9 (var_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)


state 45

    (49) assignment_expression -> IDENTIFIER ASSIGN . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 76
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 46

    (68) unary_expression -> IDENTIFIER INC .

    SEMICOLON       reduce using rule 68 (unary_expression -> IDENTIFIER INC .)
    PLUS            reduce using rule 68 (unary_expression -> IDENTIFIER INC .)
    MINUS           reduce using rule 68 (unary_expression -> IDENTIFIER INC .)
    TIMES           reduce using rule 68 (unary_expression -> IDENTIFIER INC .)
    DIVIDE          reduce using rule 68 (unary_expression -> IDENTIFIER INC .)
    MOD             reduce using rule 68 (unary_expression -> IDENTIFIER INC .)
    EQ              reduce using rule 68 (unary_expression -> IDENTIFIER INC .)
    NEQ             reduce using rule 68 (unary_expression -> IDENTIFIER INC .)
    LT              reduce using rule 68 (unary_expression -> IDENTIFIER INC .)
    GT              reduce using rule 68 (unary_expression -> IDENTIFIER INC .)
    LTE             reduce using rule 68 (unary_expression -> IDENTIFIER INC .)
    GTE             reduce using rule 68 (unary_expression -> IDENTIFIER INC .)
    AND             reduce using rule 68 (unary_expression -> IDENTIFIER INC .)
    OR              reduce using rule 68 (unary_expression -> IDENTIFIER INC .)
    RBRACKET        reduce using rule 68 (unary_expression -> IDENTIFIER INC .)
    RPAREN          reduce using rule 68 (unary_expression -> IDENTIFIER INC .)
    COMMA           reduce using rule 68 (unary_expression -> IDENTIFIER INC .)
    RBRACE          reduce using rule 68 (unary_expression -> IDENTIFIER INC .)


state 47

    (69) unary_expression -> IDENTIFIER DEC .

    SEMICOLON       reduce using rule 69 (unary_expression -> IDENTIFIER DEC .)
    PLUS            reduce using rule 69 (unary_expression -> IDENTIFIER DEC .)
    MINUS           reduce using rule 69 (unary_expression -> IDENTIFIER DEC .)
    TIMES           reduce using rule 69 (unary_expression -> IDENTIFIER DEC .)
    DIVIDE          reduce using rule 69 (unary_expression -> IDENTIFIER DEC .)
    MOD             reduce using rule 69 (unary_expression -> IDENTIFIER DEC .)
    EQ              reduce using rule 69 (unary_expression -> IDENTIFIER DEC .)
    NEQ             reduce using rule 69 (unary_expression -> IDENTIFIER DEC .)
    LT              reduce using rule 69 (unary_expression -> IDENTIFIER DEC .)
    GT              reduce using rule 69 (unary_expression -> IDENTIFIER DEC .)
    LTE             reduce using rule 69 (unary_expression -> IDENTIFIER DEC .)
    GTE             reduce using rule 69 (unary_expression -> IDENTIFIER DEC .)
    AND             reduce using rule 69 (unary_expression -> IDENTIFIER DEC .)
    OR              reduce using rule 69 (unary_expression -> IDENTIFIER DEC .)
    RBRACKET        reduce using rule 69 (unary_expression -> IDENTIFIER DEC .)
    RPAREN          reduce using rule 69 (unary_expression -> IDENTIFIER DEC .)
    COMMA           reduce using rule 69 (unary_expression -> IDENTIFIER DEC .)
    RBRACE          reduce using rule 69 (unary_expression -> IDENTIFIER DEC .)


state 48

    (79) array_access -> IDENTIFIER LBRACKET . expression RBRACKET
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 77
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 49

    (78) function_call -> IDENTIFIER LPAREN . argument_list RPAREN
    (80) argument_list -> . argument_list COMMA expression
    (81) argument_list -> . expression
    (82) argument_list -> . empty
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (30) empty -> .
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    RPAREN          reduce using rule 30 (empty -> .)
    COMMA           reduce using rule 30 (empty -> .)
    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    argument_list                  shift and go to state 78
    expression                     shift and go to state 79
    empty                          shift and go to state 80
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 50

    (10) var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .

    INT             reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    FLOAT           reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    CHAR            reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    CONTINUE        reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    BREAK           reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    INC             reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    DEC             reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    INT_LITERAL     reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    CHAR_LITERAL    reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_LITERAL  reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    ELSE            reduce using rule 10 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)


state 51

    (51) binary_expression -> expression PLUS . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 81
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 52

    (52) binary_expression -> expression MINUS . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 82
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 53

    (53) binary_expression -> expression TIMES . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 83
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 54

    (54) binary_expression -> expression DIVIDE . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 84
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 55

    (55) binary_expression -> expression MOD . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 85
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 56

    (56) binary_expression -> expression EQ . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 86
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 57

    (57) binary_expression -> expression NEQ . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 87
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 58

    (58) binary_expression -> expression LT . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 88
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 59

    (59) binary_expression -> expression GT . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 89
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 60

    (60) binary_expression -> expression LTE . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 90
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 61

    (61) binary_expression -> expression GTE . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 91
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 62

    (62) binary_expression -> expression AND . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 92
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 63

    (63) binary_expression -> expression OR . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 93
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 64

    (50) assignment_expression -> array_access ASSIGN . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    array_access                   shift and go to state 27
    expression                     shift and go to state 94
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    function_call                  shift and go to state 37

state 65

    (64) unary_expression -> MINUS expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 64 (unary_expression -> MINUS expression .)
    PLUS            reduce using rule 64 (unary_expression -> MINUS expression .)
    MINUS           reduce using rule 64 (unary_expression -> MINUS expression .)
    TIMES           reduce using rule 64 (unary_expression -> MINUS expression .)
    DIVIDE          reduce using rule 64 (unary_expression -> MINUS expression .)
    MOD             reduce using rule 64 (unary_expression -> MINUS expression .)
    EQ              reduce using rule 64 (unary_expression -> MINUS expression .)
    NEQ             reduce using rule 64 (unary_expression -> MINUS expression .)
    LT              reduce using rule 64 (unary_expression -> MINUS expression .)
    GT              reduce using rule 64 (unary_expression -> MINUS expression .)
    LTE             reduce using rule 64 (unary_expression -> MINUS expression .)
    GTE             reduce using rule 64 (unary_expression -> MINUS expression .)
    AND             reduce using rule 64 (unary_expression -> MINUS expression .)
    OR              reduce using rule 64 (unary_expression -> MINUS expression .)
    RBRACKET        reduce using rule 64 (unary_expression -> MINUS expression .)
    RPAREN          reduce using rule 64 (unary_expression -> MINUS expression .)
    COMMA           reduce using rule 64 (unary_expression -> MINUS expression .)
    RBRACE          reduce using rule 64 (unary_expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 51 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 53 ]
  ! DIVIDE          [ shift and go to state 54 ]
  ! MOD             [ shift and go to state 55 ]
  ! EQ              [ shift and go to state 56 ]
  ! NEQ             [ shift and go to state 57 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]


state 66

    (65) unary_expression -> NOT expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 65 (unary_expression -> NOT expression .)
    PLUS            reduce using rule 65 (unary_expression -> NOT expression .)
    MINUS           reduce using rule 65 (unary_expression -> NOT expression .)
    TIMES           reduce using rule 65 (unary_expression -> NOT expression .)
    DIVIDE          reduce using rule 65 (unary_expression -> NOT expression .)
    MOD             reduce using rule 65 (unary_expression -> NOT expression .)
    EQ              reduce using rule 65 (unary_expression -> NOT expression .)
    NEQ             reduce using rule 65 (unary_expression -> NOT expression .)
    LT              reduce using rule 65 (unary_expression -> NOT expression .)
    GT              reduce using rule 65 (unary_expression -> NOT expression .)
    LTE             reduce using rule 65 (unary_expression -> NOT expression .)
    GTE             reduce using rule 65 (unary_expression -> NOT expression .)
    AND             reduce using rule 65 (unary_expression -> NOT expression .)
    OR              reduce using rule 65 (unary_expression -> NOT expression .)
    RBRACKET        reduce using rule 65 (unary_expression -> NOT expression .)
    RPAREN          reduce using rule 65 (unary_expression -> NOT expression .)
    COMMA           reduce using rule 65 (unary_expression -> NOT expression .)
    RBRACE          reduce using rule 65 (unary_expression -> NOT expression .)

  ! PLUS            [ shift and go to state 51 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 53 ]
  ! DIVIDE          [ shift and go to state 54 ]
  ! MOD             [ shift and go to state 55 ]
  ! EQ              [ shift and go to state 56 ]
  ! NEQ             [ shift and go to state 57 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]


state 67

    (66) unary_expression -> INC IDENTIFIER .

    SEMICOLON       reduce using rule 66 (unary_expression -> INC IDENTIFIER .)
    PLUS            reduce using rule 66 (unary_expression -> INC IDENTIFIER .)
    MINUS           reduce using rule 66 (unary_expression -> INC IDENTIFIER .)
    TIMES           reduce using rule 66 (unary_expression -> INC IDENTIFIER .)
    DIVIDE          reduce using rule 66 (unary_expression -> INC IDENTIFIER .)
    MOD             reduce using rule 66 (unary_expression -> INC IDENTIFIER .)
    EQ              reduce using rule 66 (unary_expression -> INC IDENTIFIER .)
    NEQ             reduce using rule 66 (unary_expression -> INC IDENTIFIER .)
    LT              reduce using rule 66 (unary_expression -> INC IDENTIFIER .)
    GT              reduce using rule 66 (unary_expression -> INC IDENTIFIER .)
    LTE             reduce using rule 66 (unary_expression -> INC IDENTIFIER .)
    GTE             reduce using rule 66 (unary_expression -> INC IDENTIFIER .)
    AND             reduce using rule 66 (unary_expression -> INC IDENTIFIER .)
    OR              reduce using rule 66 (unary_expression -> INC IDENTIFIER .)
    RBRACKET        reduce using rule 66 (unary_expression -> INC IDENTIFIER .)
    RPAREN          reduce using rule 66 (unary_expression -> INC IDENTIFIER .)
    COMMA           reduce using rule 66 (unary_expression -> INC IDENTIFIER .)
    RBRACE          reduce using rule 66 (unary_expression -> INC IDENTIFIER .)


state 68

    (67) unary_expression -> DEC IDENTIFIER .

    SEMICOLON       reduce using rule 67 (unary_expression -> DEC IDENTIFIER .)
    PLUS            reduce using rule 67 (unary_expression -> DEC IDENTIFIER .)
    MINUS           reduce using rule 67 (unary_expression -> DEC IDENTIFIER .)
    TIMES           reduce using rule 67 (unary_expression -> DEC IDENTIFIER .)
    DIVIDE          reduce using rule 67 (unary_expression -> DEC IDENTIFIER .)
    MOD             reduce using rule 67 (unary_expression -> DEC IDENTIFIER .)
    EQ              reduce using rule 67 (unary_expression -> DEC IDENTIFIER .)
    NEQ             reduce using rule 67 (unary_expression -> DEC IDENTIFIER .)
    LT              reduce using rule 67 (unary_expression -> DEC IDENTIFIER .)
    GT              reduce using rule 67 (unary_expression -> DEC IDENTIFIER .)
    LTE             reduce using rule 67 (unary_expression -> DEC IDENTIFIER .)
    GTE             reduce using rule 67 (unary_expression -> DEC IDENTIFIER .)
    AND             reduce using rule 67 (unary_expression -> DEC IDENTIFIER .)
    OR              reduce using rule 67 (unary_expression -> DEC IDENTIFIER .)
    RBRACKET        reduce using rule 67 (unary_expression -> DEC IDENTIFIER .)
    RPAREN          reduce using rule 67 (unary_expression -> DEC IDENTIFIER .)
    COMMA           reduce using rule 67 (unary_expression -> DEC IDENTIFIER .)
    RBRACE          reduce using rule 67 (unary_expression -> DEC IDENTIFIER .)


state 69

    (75) term -> LPAREN expression . RPAREN
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    RPAREN          shift and go to state 95
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63


state 70

    (27) param -> type_specifier IDENTIFIER .
    (28) param -> type_specifier IDENTIFIER . LBRACKET RBRACKET

    RPAREN          reduce using rule 27 (param -> type_specifier IDENTIFIER .)
    COMMA           reduce using rule 27 (param -> type_specifier IDENTIFIER .)
    LBRACKET        shift and go to state 96


state 71

    (29) param -> type_specifier TIMES . IDENTIFIER

    IDENTIFIER      shift and go to state 97


state 72

    (22) function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN . SEMICOLON
    (23) function_definition -> type_specifier IDENTIFIER LPAREN param_list RPAREN . compound_statement
    (31) compound_statement -> . LBRACE statement_list RBRACE

    SEMICOLON       shift and go to state 98
    LBRACE          shift and go to state 100

    compound_statement             shift and go to state 99

state 73

    (24) param_list -> param_list COMMA . param
    (27) param -> . type_specifier IDENTIFIER
    (28) param -> . type_specifier IDENTIFIER LBRACKET RBRACKET
    (29) param -> . type_specifier TIMES IDENTIFIER
    (16) type_specifier -> . INT
    (17) type_specifier -> . FLOAT
    (18) type_specifier -> . CHAR
    (19) type_specifier -> . VOID

    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    VOID            shift and go to state 12

    param                          shift and go to state 101
    type_specifier                 shift and go to state 38

state 74

    (11) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET . SEMICOLON
    (12) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET . ASSIGN LBRACE array_list RBRACE SEMICOLON
    (14) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET . ASSIGN STRING_LITERAL SEMICOLON

    SEMICOLON       shift and go to state 102
    ASSIGN          shift and go to state 103


state 75

    (13) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN . LBRACE array_list RBRACE SEMICOLON
    (15) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN . STRING_LITERAL SEMICOLON

    LBRACE          shift and go to state 104
    STRING_LITERAL  shift and go to state 105


state 76

    (49) assignment_expression -> IDENTIFIER ASSIGN expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 49 (assignment_expression -> IDENTIFIER ASSIGN expression .)
    RBRACKET        reduce using rule 49 (assignment_expression -> IDENTIFIER ASSIGN expression .)
    RPAREN          reduce using rule 49 (assignment_expression -> IDENTIFIER ASSIGN expression .)
    COMMA           reduce using rule 49 (assignment_expression -> IDENTIFIER ASSIGN expression .)
    RBRACE          reduce using rule 49 (assignment_expression -> IDENTIFIER ASSIGN expression .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63

  ! PLUS            [ reduce using rule 49 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 49 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! TIMES           [ reduce using rule 49 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! DIVIDE          [ reduce using rule 49 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! MOD             [ reduce using rule 49 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! EQ              [ reduce using rule 49 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! NEQ             [ reduce using rule 49 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! LT              [ reduce using rule 49 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! GT              [ reduce using rule 49 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! LTE             [ reduce using rule 49 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! GTE             [ reduce using rule 49 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! AND             [ reduce using rule 49 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! OR              [ reduce using rule 49 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]


state 77

    (79) array_access -> IDENTIFIER LBRACKET expression . RBRACKET
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    RBRACKET        shift and go to state 106
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63


state 78

    (78) function_call -> IDENTIFIER LPAREN argument_list . RPAREN
    (80) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 107
    COMMA           shift and go to state 108


state 79

    (81) argument_list -> expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    RPAREN          reduce using rule 81 (argument_list -> expression .)
    COMMA           reduce using rule 81 (argument_list -> expression .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63


state 80

    (82) argument_list -> empty .

    RPAREN          reduce using rule 82 (argument_list -> empty .)
    COMMA           reduce using rule 82 (argument_list -> empty .)


state 81

    (51) binary_expression -> expression PLUS expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 51 (binary_expression -> expression PLUS expression .)
    PLUS            reduce using rule 51 (binary_expression -> expression PLUS expression .)
    MINUS           reduce using rule 51 (binary_expression -> expression PLUS expression .)
    EQ              reduce using rule 51 (binary_expression -> expression PLUS expression .)
    NEQ             reduce using rule 51 (binary_expression -> expression PLUS expression .)
    LT              reduce using rule 51 (binary_expression -> expression PLUS expression .)
    GT              reduce using rule 51 (binary_expression -> expression PLUS expression .)
    LTE             reduce using rule 51 (binary_expression -> expression PLUS expression .)
    GTE             reduce using rule 51 (binary_expression -> expression PLUS expression .)
    AND             reduce using rule 51 (binary_expression -> expression PLUS expression .)
    OR              reduce using rule 51 (binary_expression -> expression PLUS expression .)
    RBRACKET        reduce using rule 51 (binary_expression -> expression PLUS expression .)
    RPAREN          reduce using rule 51 (binary_expression -> expression PLUS expression .)
    COMMA           reduce using rule 51 (binary_expression -> expression PLUS expression .)
    RBRACE          reduce using rule 51 (binary_expression -> expression PLUS expression .)
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55

  ! TIMES           [ reduce using rule 51 (binary_expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 51 (binary_expression -> expression PLUS expression .) ]
  ! MOD             [ reduce using rule 51 (binary_expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 51 ]
  ! MINUS           [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 56 ]
  ! NEQ             [ shift and go to state 57 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]


state 82

    (52) binary_expression -> expression MINUS expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 52 (binary_expression -> expression MINUS expression .)
    PLUS            reduce using rule 52 (binary_expression -> expression MINUS expression .)
    MINUS           reduce using rule 52 (binary_expression -> expression MINUS expression .)
    EQ              reduce using rule 52 (binary_expression -> expression MINUS expression .)
    NEQ             reduce using rule 52 (binary_expression -> expression MINUS expression .)
    LT              reduce using rule 52 (binary_expression -> expression MINUS expression .)
    GT              reduce using rule 52 (binary_expression -> expression MINUS expression .)
    LTE             reduce using rule 52 (binary_expression -> expression MINUS expression .)
    GTE             reduce using rule 52 (binary_expression -> expression MINUS expression .)
    AND             reduce using rule 52 (binary_expression -> expression MINUS expression .)
    OR              reduce using rule 52 (binary_expression -> expression MINUS expression .)
    RBRACKET        reduce using rule 52 (binary_expression -> expression MINUS expression .)
    RPAREN          reduce using rule 52 (binary_expression -> expression MINUS expression .)
    COMMA           reduce using rule 52 (binary_expression -> expression MINUS expression .)
    RBRACE          reduce using rule 52 (binary_expression -> expression MINUS expression .)
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55

  ! TIMES           [ reduce using rule 52 (binary_expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 52 (binary_expression -> expression MINUS expression .) ]
  ! MOD             [ reduce using rule 52 (binary_expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 51 ]
  ! MINUS           [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 56 ]
  ! NEQ             [ shift and go to state 57 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]


state 83

    (53) binary_expression -> expression TIMES expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 53 (binary_expression -> expression TIMES expression .)
    PLUS            reduce using rule 53 (binary_expression -> expression TIMES expression .)
    MINUS           reduce using rule 53 (binary_expression -> expression TIMES expression .)
    TIMES           reduce using rule 53 (binary_expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 53 (binary_expression -> expression TIMES expression .)
    MOD             reduce using rule 53 (binary_expression -> expression TIMES expression .)
    EQ              reduce using rule 53 (binary_expression -> expression TIMES expression .)
    NEQ             reduce using rule 53 (binary_expression -> expression TIMES expression .)
    LT              reduce using rule 53 (binary_expression -> expression TIMES expression .)
    GT              reduce using rule 53 (binary_expression -> expression TIMES expression .)
    LTE             reduce using rule 53 (binary_expression -> expression TIMES expression .)
    GTE             reduce using rule 53 (binary_expression -> expression TIMES expression .)
    AND             reduce using rule 53 (binary_expression -> expression TIMES expression .)
    OR              reduce using rule 53 (binary_expression -> expression TIMES expression .)
    RBRACKET        reduce using rule 53 (binary_expression -> expression TIMES expression .)
    RPAREN          reduce using rule 53 (binary_expression -> expression TIMES expression .)
    COMMA           reduce using rule 53 (binary_expression -> expression TIMES expression .)
    RBRACE          reduce using rule 53 (binary_expression -> expression TIMES expression .)

  ! PLUS            [ shift and go to state 51 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 53 ]
  ! DIVIDE          [ shift and go to state 54 ]
  ! MOD             [ shift and go to state 55 ]
  ! EQ              [ shift and go to state 56 ]
  ! NEQ             [ shift and go to state 57 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]


state 84

    (54) binary_expression -> expression DIVIDE expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 54 (binary_expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 54 (binary_expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 54 (binary_expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 54 (binary_expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 54 (binary_expression -> expression DIVIDE expression .)
    MOD             reduce using rule 54 (binary_expression -> expression DIVIDE expression .)
    EQ              reduce using rule 54 (binary_expression -> expression DIVIDE expression .)
    NEQ             reduce using rule 54 (binary_expression -> expression DIVIDE expression .)
    LT              reduce using rule 54 (binary_expression -> expression DIVIDE expression .)
    GT              reduce using rule 54 (binary_expression -> expression DIVIDE expression .)
    LTE             reduce using rule 54 (binary_expression -> expression DIVIDE expression .)
    GTE             reduce using rule 54 (binary_expression -> expression DIVIDE expression .)
    AND             reduce using rule 54 (binary_expression -> expression DIVIDE expression .)
    OR              reduce using rule 54 (binary_expression -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 54 (binary_expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 54 (binary_expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 54 (binary_expression -> expression DIVIDE expression .)
    RBRACE          reduce using rule 54 (binary_expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 51 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 53 ]
  ! DIVIDE          [ shift and go to state 54 ]
  ! MOD             [ shift and go to state 55 ]
  ! EQ              [ shift and go to state 56 ]
  ! NEQ             [ shift and go to state 57 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]


state 85

    (55) binary_expression -> expression MOD expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 55 (binary_expression -> expression MOD expression .)
    PLUS            reduce using rule 55 (binary_expression -> expression MOD expression .)
    MINUS           reduce using rule 55 (binary_expression -> expression MOD expression .)
    TIMES           reduce using rule 55 (binary_expression -> expression MOD expression .)
    DIVIDE          reduce using rule 55 (binary_expression -> expression MOD expression .)
    MOD             reduce using rule 55 (binary_expression -> expression MOD expression .)
    EQ              reduce using rule 55 (binary_expression -> expression MOD expression .)
    NEQ             reduce using rule 55 (binary_expression -> expression MOD expression .)
    LT              reduce using rule 55 (binary_expression -> expression MOD expression .)
    GT              reduce using rule 55 (binary_expression -> expression MOD expression .)
    LTE             reduce using rule 55 (binary_expression -> expression MOD expression .)
    GTE             reduce using rule 55 (binary_expression -> expression MOD expression .)
    AND             reduce using rule 55 (binary_expression -> expression MOD expression .)
    OR              reduce using rule 55 (binary_expression -> expression MOD expression .)
    RBRACKET        reduce using rule 55 (binary_expression -> expression MOD expression .)
    RPAREN          reduce using rule 55 (binary_expression -> expression MOD expression .)
    COMMA           reduce using rule 55 (binary_expression -> expression MOD expression .)
    RBRACE          reduce using rule 55 (binary_expression -> expression MOD expression .)

  ! PLUS            [ shift and go to state 51 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 53 ]
  ! DIVIDE          [ shift and go to state 54 ]
  ! MOD             [ shift and go to state 55 ]
  ! EQ              [ shift and go to state 56 ]
  ! NEQ             [ shift and go to state 57 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]


state 86

    (56) binary_expression -> expression EQ expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 56 (binary_expression -> expression EQ expression .)
    EQ              reduce using rule 56 (binary_expression -> expression EQ expression .)
    NEQ             reduce using rule 56 (binary_expression -> expression EQ expression .)
    AND             reduce using rule 56 (binary_expression -> expression EQ expression .)
    OR              reduce using rule 56 (binary_expression -> expression EQ expression .)
    RBRACKET        reduce using rule 56 (binary_expression -> expression EQ expression .)
    RPAREN          reduce using rule 56 (binary_expression -> expression EQ expression .)
    COMMA           reduce using rule 56 (binary_expression -> expression EQ expression .)
    RBRACE          reduce using rule 56 (binary_expression -> expression EQ expression .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61

  ! PLUS            [ reduce using rule 56 (binary_expression -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 56 (binary_expression -> expression EQ expression .) ]
  ! TIMES           [ reduce using rule 56 (binary_expression -> expression EQ expression .) ]
  ! DIVIDE          [ reduce using rule 56 (binary_expression -> expression EQ expression .) ]
  ! MOD             [ reduce using rule 56 (binary_expression -> expression EQ expression .) ]
  ! LT              [ reduce using rule 56 (binary_expression -> expression EQ expression .) ]
  ! GT              [ reduce using rule 56 (binary_expression -> expression EQ expression .) ]
  ! LTE             [ reduce using rule 56 (binary_expression -> expression EQ expression .) ]
  ! GTE             [ reduce using rule 56 (binary_expression -> expression EQ expression .) ]
  ! EQ              [ shift and go to state 56 ]
  ! NEQ             [ shift and go to state 57 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]


state 87

    (57) binary_expression -> expression NEQ expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 57 (binary_expression -> expression NEQ expression .)
    EQ              reduce using rule 57 (binary_expression -> expression NEQ expression .)
    NEQ             reduce using rule 57 (binary_expression -> expression NEQ expression .)
    AND             reduce using rule 57 (binary_expression -> expression NEQ expression .)
    OR              reduce using rule 57 (binary_expression -> expression NEQ expression .)
    RBRACKET        reduce using rule 57 (binary_expression -> expression NEQ expression .)
    RPAREN          reduce using rule 57 (binary_expression -> expression NEQ expression .)
    COMMA           reduce using rule 57 (binary_expression -> expression NEQ expression .)
    RBRACE          reduce using rule 57 (binary_expression -> expression NEQ expression .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61

  ! PLUS            [ reduce using rule 57 (binary_expression -> expression NEQ expression .) ]
  ! MINUS           [ reduce using rule 57 (binary_expression -> expression NEQ expression .) ]
  ! TIMES           [ reduce using rule 57 (binary_expression -> expression NEQ expression .) ]
  ! DIVIDE          [ reduce using rule 57 (binary_expression -> expression NEQ expression .) ]
  ! MOD             [ reduce using rule 57 (binary_expression -> expression NEQ expression .) ]
  ! LT              [ reduce using rule 57 (binary_expression -> expression NEQ expression .) ]
  ! GT              [ reduce using rule 57 (binary_expression -> expression NEQ expression .) ]
  ! LTE             [ reduce using rule 57 (binary_expression -> expression NEQ expression .) ]
  ! GTE             [ reduce using rule 57 (binary_expression -> expression NEQ expression .) ]
  ! EQ              [ shift and go to state 56 ]
  ! NEQ             [ shift and go to state 57 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]


state 88

    (58) binary_expression -> expression LT expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 58 (binary_expression -> expression LT expression .)
    EQ              reduce using rule 58 (binary_expression -> expression LT expression .)
    NEQ             reduce using rule 58 (binary_expression -> expression LT expression .)
    LT              reduce using rule 58 (binary_expression -> expression LT expression .)
    GT              reduce using rule 58 (binary_expression -> expression LT expression .)
    LTE             reduce using rule 58 (binary_expression -> expression LT expression .)
    GTE             reduce using rule 58 (binary_expression -> expression LT expression .)
    AND             reduce using rule 58 (binary_expression -> expression LT expression .)
    OR              reduce using rule 58 (binary_expression -> expression LT expression .)
    RBRACKET        reduce using rule 58 (binary_expression -> expression LT expression .)
    RPAREN          reduce using rule 58 (binary_expression -> expression LT expression .)
    COMMA           reduce using rule 58 (binary_expression -> expression LT expression .)
    RBRACE          reduce using rule 58 (binary_expression -> expression LT expression .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55

  ! PLUS            [ reduce using rule 58 (binary_expression -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 58 (binary_expression -> expression LT expression .) ]
  ! TIMES           [ reduce using rule 58 (binary_expression -> expression LT expression .) ]
  ! DIVIDE          [ reduce using rule 58 (binary_expression -> expression LT expression .) ]
  ! MOD             [ reduce using rule 58 (binary_expression -> expression LT expression .) ]
  ! EQ              [ shift and go to state 56 ]
  ! NEQ             [ shift and go to state 57 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]


state 89

    (59) binary_expression -> expression GT expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 59 (binary_expression -> expression GT expression .)
    EQ              reduce using rule 59 (binary_expression -> expression GT expression .)
    NEQ             reduce using rule 59 (binary_expression -> expression GT expression .)
    LT              reduce using rule 59 (binary_expression -> expression GT expression .)
    GT              reduce using rule 59 (binary_expression -> expression GT expression .)
    LTE             reduce using rule 59 (binary_expression -> expression GT expression .)
    GTE             reduce using rule 59 (binary_expression -> expression GT expression .)
    AND             reduce using rule 59 (binary_expression -> expression GT expression .)
    OR              reduce using rule 59 (binary_expression -> expression GT expression .)
    RBRACKET        reduce using rule 59 (binary_expression -> expression GT expression .)
    RPAREN          reduce using rule 59 (binary_expression -> expression GT expression .)
    COMMA           reduce using rule 59 (binary_expression -> expression GT expression .)
    RBRACE          reduce using rule 59 (binary_expression -> expression GT expression .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55

  ! PLUS            [ reduce using rule 59 (binary_expression -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 59 (binary_expression -> expression GT expression .) ]
  ! TIMES           [ reduce using rule 59 (binary_expression -> expression GT expression .) ]
  ! DIVIDE          [ reduce using rule 59 (binary_expression -> expression GT expression .) ]
  ! MOD             [ reduce using rule 59 (binary_expression -> expression GT expression .) ]
  ! EQ              [ shift and go to state 56 ]
  ! NEQ             [ shift and go to state 57 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]


state 90

    (60) binary_expression -> expression LTE expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 60 (binary_expression -> expression LTE expression .)
    EQ              reduce using rule 60 (binary_expression -> expression LTE expression .)
    NEQ             reduce using rule 60 (binary_expression -> expression LTE expression .)
    LT              reduce using rule 60 (binary_expression -> expression LTE expression .)
    GT              reduce using rule 60 (binary_expression -> expression LTE expression .)
    LTE             reduce using rule 60 (binary_expression -> expression LTE expression .)
    GTE             reduce using rule 60 (binary_expression -> expression LTE expression .)
    AND             reduce using rule 60 (binary_expression -> expression LTE expression .)
    OR              reduce using rule 60 (binary_expression -> expression LTE expression .)
    RBRACKET        reduce using rule 60 (binary_expression -> expression LTE expression .)
    RPAREN          reduce using rule 60 (binary_expression -> expression LTE expression .)
    COMMA           reduce using rule 60 (binary_expression -> expression LTE expression .)
    RBRACE          reduce using rule 60 (binary_expression -> expression LTE expression .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55

  ! PLUS            [ reduce using rule 60 (binary_expression -> expression LTE expression .) ]
  ! MINUS           [ reduce using rule 60 (binary_expression -> expression LTE expression .) ]
  ! TIMES           [ reduce using rule 60 (binary_expression -> expression LTE expression .) ]
  ! DIVIDE          [ reduce using rule 60 (binary_expression -> expression LTE expression .) ]
  ! MOD             [ reduce using rule 60 (binary_expression -> expression LTE expression .) ]
  ! EQ              [ shift and go to state 56 ]
  ! NEQ             [ shift and go to state 57 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]


state 91

    (61) binary_expression -> expression GTE expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 61 (binary_expression -> expression GTE expression .)
    EQ              reduce using rule 61 (binary_expression -> expression GTE expression .)
    NEQ             reduce using rule 61 (binary_expression -> expression GTE expression .)
    LT              reduce using rule 61 (binary_expression -> expression GTE expression .)
    GT              reduce using rule 61 (binary_expression -> expression GTE expression .)
    LTE             reduce using rule 61 (binary_expression -> expression GTE expression .)
    GTE             reduce using rule 61 (binary_expression -> expression GTE expression .)
    AND             reduce using rule 61 (binary_expression -> expression GTE expression .)
    OR              reduce using rule 61 (binary_expression -> expression GTE expression .)
    RBRACKET        reduce using rule 61 (binary_expression -> expression GTE expression .)
    RPAREN          reduce using rule 61 (binary_expression -> expression GTE expression .)
    COMMA           reduce using rule 61 (binary_expression -> expression GTE expression .)
    RBRACE          reduce using rule 61 (binary_expression -> expression GTE expression .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55

  ! PLUS            [ reduce using rule 61 (binary_expression -> expression GTE expression .) ]
  ! MINUS           [ reduce using rule 61 (binary_expression -> expression GTE expression .) ]
  ! TIMES           [ reduce using rule 61 (binary_expression -> expression GTE expression .) ]
  ! DIVIDE          [ reduce using rule 61 (binary_expression -> expression GTE expression .) ]
  ! MOD             [ reduce using rule 61 (binary_expression -> expression GTE expression .) ]
  ! EQ              [ shift and go to state 56 ]
  ! NEQ             [ shift and go to state 57 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]


state 92

    (62) binary_expression -> expression AND expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 62 (binary_expression -> expression AND expression .)
    AND             reduce using rule 62 (binary_expression -> expression AND expression .)
    OR              reduce using rule 62 (binary_expression -> expression AND expression .)
    RBRACKET        reduce using rule 62 (binary_expression -> expression AND expression .)
    RPAREN          reduce using rule 62 (binary_expression -> expression AND expression .)
    COMMA           reduce using rule 62 (binary_expression -> expression AND expression .)
    RBRACE          reduce using rule 62 (binary_expression -> expression AND expression .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61

  ! PLUS            [ reduce using rule 62 (binary_expression -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 62 (binary_expression -> expression AND expression .) ]
  ! TIMES           [ reduce using rule 62 (binary_expression -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 62 (binary_expression -> expression AND expression .) ]
  ! MOD             [ reduce using rule 62 (binary_expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 62 (binary_expression -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 62 (binary_expression -> expression AND expression .) ]
  ! LT              [ reduce using rule 62 (binary_expression -> expression AND expression .) ]
  ! GT              [ reduce using rule 62 (binary_expression -> expression AND expression .) ]
  ! LTE             [ reduce using rule 62 (binary_expression -> expression AND expression .) ]
  ! GTE             [ reduce using rule 62 (binary_expression -> expression AND expression .) ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]


state 93

    (63) binary_expression -> expression OR expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 63 (binary_expression -> expression OR expression .)
    OR              reduce using rule 63 (binary_expression -> expression OR expression .)
    RBRACKET        reduce using rule 63 (binary_expression -> expression OR expression .)
    RPAREN          reduce using rule 63 (binary_expression -> expression OR expression .)
    COMMA           reduce using rule 63 (binary_expression -> expression OR expression .)
    RBRACE          reduce using rule 63 (binary_expression -> expression OR expression .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    AND             shift and go to state 62

  ! PLUS            [ reduce using rule 63 (binary_expression -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 63 (binary_expression -> expression OR expression .) ]
  ! TIMES           [ reduce using rule 63 (binary_expression -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 63 (binary_expression -> expression OR expression .) ]
  ! MOD             [ reduce using rule 63 (binary_expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 63 (binary_expression -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 63 (binary_expression -> expression OR expression .) ]
  ! LT              [ reduce using rule 63 (binary_expression -> expression OR expression .) ]
  ! GT              [ reduce using rule 63 (binary_expression -> expression OR expression .) ]
  ! LTE             [ reduce using rule 63 (binary_expression -> expression OR expression .) ]
  ! GTE             [ reduce using rule 63 (binary_expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 63 (binary_expression -> expression OR expression .) ]
  ! OR              [ shift and go to state 63 ]


state 94

    (50) assignment_expression -> array_access ASSIGN expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 50 (assignment_expression -> array_access ASSIGN expression .)
    RBRACKET        reduce using rule 50 (assignment_expression -> array_access ASSIGN expression .)
    RPAREN          reduce using rule 50 (assignment_expression -> array_access ASSIGN expression .)
    COMMA           reduce using rule 50 (assignment_expression -> array_access ASSIGN expression .)
    RBRACE          reduce using rule 50 (assignment_expression -> array_access ASSIGN expression .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63

  ! PLUS            [ reduce using rule 50 (assignment_expression -> array_access ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 50 (assignment_expression -> array_access ASSIGN expression .) ]
  ! TIMES           [ reduce using rule 50 (assignment_expression -> array_access ASSIGN expression .) ]
  ! DIVIDE          [ reduce using rule 50 (assignment_expression -> array_access ASSIGN expression .) ]
  ! MOD             [ reduce using rule 50 (assignment_expression -> array_access ASSIGN expression .) ]
  ! EQ              [ reduce using rule 50 (assignment_expression -> array_access ASSIGN expression .) ]
  ! NEQ             [ reduce using rule 50 (assignment_expression -> array_access ASSIGN expression .) ]
  ! LT              [ reduce using rule 50 (assignment_expression -> array_access ASSIGN expression .) ]
  ! GT              [ reduce using rule 50 (assignment_expression -> array_access ASSIGN expression .) ]
  ! LTE             [ reduce using rule 50 (assignment_expression -> array_access ASSIGN expression .) ]
  ! GTE             [ reduce using rule 50 (assignment_expression -> array_access ASSIGN expression .) ]
  ! AND             [ reduce using rule 50 (assignment_expression -> array_access ASSIGN expression .) ]
  ! OR              [ reduce using rule 50 (assignment_expression -> array_access ASSIGN expression .) ]


state 95

    (75) term -> LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 75 (term -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 75 (term -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 75 (term -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 75 (term -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 75 (term -> LPAREN expression RPAREN .)
    MOD             reduce using rule 75 (term -> LPAREN expression RPAREN .)
    EQ              reduce using rule 75 (term -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 75 (term -> LPAREN expression RPAREN .)
    LT              reduce using rule 75 (term -> LPAREN expression RPAREN .)
    GT              reduce using rule 75 (term -> LPAREN expression RPAREN .)
    LTE             reduce using rule 75 (term -> LPAREN expression RPAREN .)
    GTE             reduce using rule 75 (term -> LPAREN expression RPAREN .)
    AND             reduce using rule 75 (term -> LPAREN expression RPAREN .)
    OR              reduce using rule 75 (term -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 75 (term -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 75 (term -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 75 (term -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 75 (term -> LPAREN expression RPAREN .)


state 96

    (28) param -> type_specifier IDENTIFIER LBRACKET . RBRACKET

    RBRACKET        shift and go to state 109


state 97

    (29) param -> type_specifier TIMES IDENTIFIER .

    RPAREN          reduce using rule 29 (param -> type_specifier TIMES IDENTIFIER .)
    COMMA           reduce using rule 29 (param -> type_specifier TIMES IDENTIFIER .)


state 98

    (22) function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN SEMICOLON .

    INT             reduce using rule 22 (function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN SEMICOLON .)
    FLOAT           reduce using rule 22 (function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN SEMICOLON .)
    CHAR            reduce using rule 22 (function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN SEMICOLON .)
    VOID            reduce using rule 22 (function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN SEMICOLON .)
    $end            reduce using rule 22 (function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN SEMICOLON .)


state 99

    (23) function_definition -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement .

    INT             reduce using rule 23 (function_definition -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement .)
    FLOAT           reduce using rule 23 (function_definition -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement .)
    CHAR            reduce using rule 23 (function_definition -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement .)
    VOID            reduce using rule 23 (function_definition -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement .)
    $end            reduce using rule 23 (function_definition -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement .)


state 100

    (31) compound_statement -> LBRACE . statement_list RBRACE
    (32) statement_list -> . statement_list statement
    (33) statement_list -> . statement
    (34) statement -> . expression_statement
    (35) statement -> . compound_statement
    (36) statement -> . selection_statement
    (37) statement -> . iteration_statement
    (38) statement -> . return_statement
    (39) statement -> . continue_statement
    (40) statement -> . break_statement
    (41) statement -> . var_declaration
    (42) statement -> . array_declaration
    (43) statement -> . empty
    (44) expression_statement -> . expression SEMICOLON
    (31) compound_statement -> . LBRACE statement_list RBRACE
    (83) selection_statement -> . IF LPAREN expression RPAREN statement
    (84) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (85) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (86) iteration_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
    (87) iteration_statement -> . FOR LPAREN var_declaration expression_statement expression RPAREN statement
    (88) return_statement -> . RETURN expression SEMICOLON
    (89) continue_statement -> . CONTINUE SEMICOLON
    (90) break_statement -> . BREAK SEMICOLON
    (8) var_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (9) var_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (10) var_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (11) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (12) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (13) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (14) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (15) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (30) empty -> .
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (16) type_specifier -> . INT
    (17) type_specifier -> . FLOAT
    (18) type_specifier -> . CHAR
    (19) type_specifier -> . VOID
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for FLOAT_LITERAL resolved as shift
  ! shift/reduce conflict for CHAR_LITERAL resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 100
    IF              shift and go to state 123
    WHILE           shift and go to state 124
    FOR             shift and go to state 125
    RETURN          shift and go to state 126
    CONTINUE        shift and go to state 127
    BREAK           shift and go to state 128
    RBRACE          reduce using rule 30 (empty -> .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    VOID            shift and go to state 12
    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

  ! LBRACE          [ reduce using rule 30 (empty -> .) ]
  ! IF              [ reduce using rule 30 (empty -> .) ]
  ! WHILE           [ reduce using rule 30 (empty -> .) ]
  ! FOR             [ reduce using rule 30 (empty -> .) ]
  ! RETURN          [ reduce using rule 30 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 30 (empty -> .) ]
  ! BREAK           [ reduce using rule 30 (empty -> .) ]
  ! INT             [ reduce using rule 30 (empty -> .) ]
  ! FLOAT           [ reduce using rule 30 (empty -> .) ]
  ! CHAR            [ reduce using rule 30 (empty -> .) ]
  ! VOID            [ reduce using rule 30 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 30 (empty -> .) ]
  ! MINUS           [ reduce using rule 30 (empty -> .) ]
  ! NOT             [ reduce using rule 30 (empty -> .) ]
  ! INC             [ reduce using rule 30 (empty -> .) ]
  ! DEC             [ reduce using rule 30 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 30 (empty -> .) ]
  ! FLOAT_LITERAL   [ reduce using rule 30 (empty -> .) ]
  ! CHAR_LITERAL    [ reduce using rule 30 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 30 (empty -> .) ]
  ! LPAREN          [ reduce using rule 30 (empty -> .) ]

    statement_list                 shift and go to state 110
    statement                      shift and go to state 111
    expression_statement           shift and go to state 112
    compound_statement             shift and go to state 113
    selection_statement            shift and go to state 114
    iteration_statement            shift and go to state 115
    return_statement               shift and go to state 116
    continue_statement             shift and go to state 117
    break_statement                shift and go to state 118
    var_declaration                shift and go to state 119
    array_declaration              shift and go to state 120
    empty                          shift and go to state 121
    expression                     shift and go to state 122
    type_specifier                 shift and go to state 129
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 101

    (24) param_list -> param_list COMMA param .

    RPAREN          reduce using rule 24 (param_list -> param_list COMMA param .)
    COMMA           reduce using rule 24 (param_list -> param_list COMMA param .)


state 102

    (11) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .

    INT             reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    FLOAT           reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    CHAR            reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    VOID            reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    $end            reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    LBRACE          reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    IF              reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    WHILE           reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    FOR             reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    RETURN          reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    CONTINUE        reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    BREAK           reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    MINUS           reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    NOT             reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    INC             reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    DEC             reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    INT_LITERAL     reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    CHAR_LITERAL    reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    STRING_LITERAL  reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    LPAREN          reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    ELSE            reduce using rule 11 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)


state 103

    (12) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN . LBRACE array_list RBRACE SEMICOLON
    (14) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN . STRING_LITERAL SEMICOLON

    LBRACE          shift and go to state 130
    STRING_LITERAL  shift and go to state 131


state 104

    (13) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE . array_list RBRACE SEMICOLON
    (20) array_list -> . array_list COMMA expression
    (21) array_list -> . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    array_list                     shift and go to state 132
    expression                     shift and go to state 133
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 105

    (15) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL . SEMICOLON

    SEMICOLON       shift and go to state 134


state 106

    (79) array_access -> IDENTIFIER LBRACKET expression RBRACKET .

    ASSIGN          reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    MOD             reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    EQ              reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    NEQ             reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    LT              reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    GT              reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    LTE             reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    GTE             reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    AND             reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    OR              reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    RBRACE          reduce using rule 79 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)


state 107

    (78) function_call -> IDENTIFIER LPAREN argument_list RPAREN .

    SEMICOLON       reduce using rule 78 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    PLUS            reduce using rule 78 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 78 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 78 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    DIVIDE          reduce using rule 78 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    MOD             reduce using rule 78 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    EQ              reduce using rule 78 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    NEQ             reduce using rule 78 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    LT              reduce using rule 78 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    GT              reduce using rule 78 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    LTE             reduce using rule 78 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    GTE             reduce using rule 78 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    AND             reduce using rule 78 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    OR              reduce using rule 78 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 78 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 78 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 78 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACE          reduce using rule 78 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)


state 108

    (80) argument_list -> argument_list COMMA . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 135
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 109

    (28) param -> type_specifier IDENTIFIER LBRACKET RBRACKET .

    RPAREN          reduce using rule 28 (param -> type_specifier IDENTIFIER LBRACKET RBRACKET .)
    COMMA           reduce using rule 28 (param -> type_specifier IDENTIFIER LBRACKET RBRACKET .)


state 110

    (31) compound_statement -> LBRACE statement_list . RBRACE
    (32) statement_list -> statement_list . statement
    (34) statement -> . expression_statement
    (35) statement -> . compound_statement
    (36) statement -> . selection_statement
    (37) statement -> . iteration_statement
    (38) statement -> . return_statement
    (39) statement -> . continue_statement
    (40) statement -> . break_statement
    (41) statement -> . var_declaration
    (42) statement -> . array_declaration
    (43) statement -> . empty
    (44) expression_statement -> . expression SEMICOLON
    (31) compound_statement -> . LBRACE statement_list RBRACE
    (83) selection_statement -> . IF LPAREN expression RPAREN statement
    (84) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (85) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (86) iteration_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
    (87) iteration_statement -> . FOR LPAREN var_declaration expression_statement expression RPAREN statement
    (88) return_statement -> . RETURN expression SEMICOLON
    (89) continue_statement -> . CONTINUE SEMICOLON
    (90) break_statement -> . BREAK SEMICOLON
    (8) var_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (9) var_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (10) var_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (11) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (12) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (13) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (14) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (15) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (30) empty -> .
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (16) type_specifier -> . INT
    (17) type_specifier -> . FLOAT
    (18) type_specifier -> . CHAR
    (19) type_specifier -> . VOID
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for FLOAT_LITERAL resolved as shift
  ! shift/reduce conflict for CHAR_LITERAL resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    RBRACE          shift and go to state 136
    LBRACE          shift and go to state 100
    IF              shift and go to state 123
    WHILE           shift and go to state 124
    FOR             shift and go to state 125
    RETURN          shift and go to state 126
    CONTINUE        shift and go to state 127
    BREAK           shift and go to state 128
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    VOID            shift and go to state 12
    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

  ! RBRACE          [ reduce using rule 30 (empty -> .) ]
  ! LBRACE          [ reduce using rule 30 (empty -> .) ]
  ! IF              [ reduce using rule 30 (empty -> .) ]
  ! WHILE           [ reduce using rule 30 (empty -> .) ]
  ! FOR             [ reduce using rule 30 (empty -> .) ]
  ! RETURN          [ reduce using rule 30 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 30 (empty -> .) ]
  ! BREAK           [ reduce using rule 30 (empty -> .) ]
  ! INT             [ reduce using rule 30 (empty -> .) ]
  ! FLOAT           [ reduce using rule 30 (empty -> .) ]
  ! CHAR            [ reduce using rule 30 (empty -> .) ]
  ! VOID            [ reduce using rule 30 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 30 (empty -> .) ]
  ! MINUS           [ reduce using rule 30 (empty -> .) ]
  ! NOT             [ reduce using rule 30 (empty -> .) ]
  ! INC             [ reduce using rule 30 (empty -> .) ]
  ! DEC             [ reduce using rule 30 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 30 (empty -> .) ]
  ! FLOAT_LITERAL   [ reduce using rule 30 (empty -> .) ]
  ! CHAR_LITERAL    [ reduce using rule 30 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 30 (empty -> .) ]
  ! LPAREN          [ reduce using rule 30 (empty -> .) ]

    statement                      shift and go to state 137
    expression_statement           shift and go to state 112
    compound_statement             shift and go to state 113
    selection_statement            shift and go to state 114
    iteration_statement            shift and go to state 115
    return_statement               shift and go to state 116
    continue_statement             shift and go to state 117
    break_statement                shift and go to state 118
    var_declaration                shift and go to state 119
    array_declaration              shift and go to state 120
    empty                          shift and go to state 121
    expression                     shift and go to state 122
    type_specifier                 shift and go to state 129
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 111

    (33) statement_list -> statement .

    RBRACE          reduce using rule 33 (statement_list -> statement .)
    LBRACE          reduce using rule 33 (statement_list -> statement .)
    IF              reduce using rule 33 (statement_list -> statement .)
    WHILE           reduce using rule 33 (statement_list -> statement .)
    FOR             reduce using rule 33 (statement_list -> statement .)
    RETURN          reduce using rule 33 (statement_list -> statement .)
    CONTINUE        reduce using rule 33 (statement_list -> statement .)
    BREAK           reduce using rule 33 (statement_list -> statement .)
    INT             reduce using rule 33 (statement_list -> statement .)
    FLOAT           reduce using rule 33 (statement_list -> statement .)
    CHAR            reduce using rule 33 (statement_list -> statement .)
    VOID            reduce using rule 33 (statement_list -> statement .)
    IDENTIFIER      reduce using rule 33 (statement_list -> statement .)
    MINUS           reduce using rule 33 (statement_list -> statement .)
    NOT             reduce using rule 33 (statement_list -> statement .)
    INC             reduce using rule 33 (statement_list -> statement .)
    DEC             reduce using rule 33 (statement_list -> statement .)
    INT_LITERAL     reduce using rule 33 (statement_list -> statement .)
    FLOAT_LITERAL   reduce using rule 33 (statement_list -> statement .)
    CHAR_LITERAL    reduce using rule 33 (statement_list -> statement .)
    STRING_LITERAL  reduce using rule 33 (statement_list -> statement .)
    LPAREN          reduce using rule 33 (statement_list -> statement .)


state 112

    (34) statement -> expression_statement .

    RBRACE          reduce using rule 34 (statement -> expression_statement .)
    LBRACE          reduce using rule 34 (statement -> expression_statement .)
    IF              reduce using rule 34 (statement -> expression_statement .)
    WHILE           reduce using rule 34 (statement -> expression_statement .)
    FOR             reduce using rule 34 (statement -> expression_statement .)
    RETURN          reduce using rule 34 (statement -> expression_statement .)
    CONTINUE        reduce using rule 34 (statement -> expression_statement .)
    BREAK           reduce using rule 34 (statement -> expression_statement .)
    INT             reduce using rule 34 (statement -> expression_statement .)
    FLOAT           reduce using rule 34 (statement -> expression_statement .)
    CHAR            reduce using rule 34 (statement -> expression_statement .)
    VOID            reduce using rule 34 (statement -> expression_statement .)
    IDENTIFIER      reduce using rule 34 (statement -> expression_statement .)
    MINUS           reduce using rule 34 (statement -> expression_statement .)
    NOT             reduce using rule 34 (statement -> expression_statement .)
    INC             reduce using rule 34 (statement -> expression_statement .)
    DEC             reduce using rule 34 (statement -> expression_statement .)
    INT_LITERAL     reduce using rule 34 (statement -> expression_statement .)
    FLOAT_LITERAL   reduce using rule 34 (statement -> expression_statement .)
    CHAR_LITERAL    reduce using rule 34 (statement -> expression_statement .)
    STRING_LITERAL  reduce using rule 34 (statement -> expression_statement .)
    LPAREN          reduce using rule 34 (statement -> expression_statement .)
    ELSE            reduce using rule 34 (statement -> expression_statement .)


state 113

    (35) statement -> compound_statement .

    RBRACE          reduce using rule 35 (statement -> compound_statement .)
    LBRACE          reduce using rule 35 (statement -> compound_statement .)
    IF              reduce using rule 35 (statement -> compound_statement .)
    WHILE           reduce using rule 35 (statement -> compound_statement .)
    FOR             reduce using rule 35 (statement -> compound_statement .)
    RETURN          reduce using rule 35 (statement -> compound_statement .)
    CONTINUE        reduce using rule 35 (statement -> compound_statement .)
    BREAK           reduce using rule 35 (statement -> compound_statement .)
    INT             reduce using rule 35 (statement -> compound_statement .)
    FLOAT           reduce using rule 35 (statement -> compound_statement .)
    CHAR            reduce using rule 35 (statement -> compound_statement .)
    VOID            reduce using rule 35 (statement -> compound_statement .)
    IDENTIFIER      reduce using rule 35 (statement -> compound_statement .)
    MINUS           reduce using rule 35 (statement -> compound_statement .)
    NOT             reduce using rule 35 (statement -> compound_statement .)
    INC             reduce using rule 35 (statement -> compound_statement .)
    DEC             reduce using rule 35 (statement -> compound_statement .)
    INT_LITERAL     reduce using rule 35 (statement -> compound_statement .)
    FLOAT_LITERAL   reduce using rule 35 (statement -> compound_statement .)
    CHAR_LITERAL    reduce using rule 35 (statement -> compound_statement .)
    STRING_LITERAL  reduce using rule 35 (statement -> compound_statement .)
    LPAREN          reduce using rule 35 (statement -> compound_statement .)
    ELSE            reduce using rule 35 (statement -> compound_statement .)


state 114

    (36) statement -> selection_statement .

    RBRACE          reduce using rule 36 (statement -> selection_statement .)
    LBRACE          reduce using rule 36 (statement -> selection_statement .)
    IF              reduce using rule 36 (statement -> selection_statement .)
    WHILE           reduce using rule 36 (statement -> selection_statement .)
    FOR             reduce using rule 36 (statement -> selection_statement .)
    RETURN          reduce using rule 36 (statement -> selection_statement .)
    CONTINUE        reduce using rule 36 (statement -> selection_statement .)
    BREAK           reduce using rule 36 (statement -> selection_statement .)
    INT             reduce using rule 36 (statement -> selection_statement .)
    FLOAT           reduce using rule 36 (statement -> selection_statement .)
    CHAR            reduce using rule 36 (statement -> selection_statement .)
    VOID            reduce using rule 36 (statement -> selection_statement .)
    IDENTIFIER      reduce using rule 36 (statement -> selection_statement .)
    MINUS           reduce using rule 36 (statement -> selection_statement .)
    NOT             reduce using rule 36 (statement -> selection_statement .)
    INC             reduce using rule 36 (statement -> selection_statement .)
    DEC             reduce using rule 36 (statement -> selection_statement .)
    INT_LITERAL     reduce using rule 36 (statement -> selection_statement .)
    FLOAT_LITERAL   reduce using rule 36 (statement -> selection_statement .)
    CHAR_LITERAL    reduce using rule 36 (statement -> selection_statement .)
    STRING_LITERAL  reduce using rule 36 (statement -> selection_statement .)
    LPAREN          reduce using rule 36 (statement -> selection_statement .)
    ELSE            reduce using rule 36 (statement -> selection_statement .)


state 115

    (37) statement -> iteration_statement .

    RBRACE          reduce using rule 37 (statement -> iteration_statement .)
    LBRACE          reduce using rule 37 (statement -> iteration_statement .)
    IF              reduce using rule 37 (statement -> iteration_statement .)
    WHILE           reduce using rule 37 (statement -> iteration_statement .)
    FOR             reduce using rule 37 (statement -> iteration_statement .)
    RETURN          reduce using rule 37 (statement -> iteration_statement .)
    CONTINUE        reduce using rule 37 (statement -> iteration_statement .)
    BREAK           reduce using rule 37 (statement -> iteration_statement .)
    INT             reduce using rule 37 (statement -> iteration_statement .)
    FLOAT           reduce using rule 37 (statement -> iteration_statement .)
    CHAR            reduce using rule 37 (statement -> iteration_statement .)
    VOID            reduce using rule 37 (statement -> iteration_statement .)
    IDENTIFIER      reduce using rule 37 (statement -> iteration_statement .)
    MINUS           reduce using rule 37 (statement -> iteration_statement .)
    NOT             reduce using rule 37 (statement -> iteration_statement .)
    INC             reduce using rule 37 (statement -> iteration_statement .)
    DEC             reduce using rule 37 (statement -> iteration_statement .)
    INT_LITERAL     reduce using rule 37 (statement -> iteration_statement .)
    FLOAT_LITERAL   reduce using rule 37 (statement -> iteration_statement .)
    CHAR_LITERAL    reduce using rule 37 (statement -> iteration_statement .)
    STRING_LITERAL  reduce using rule 37 (statement -> iteration_statement .)
    LPAREN          reduce using rule 37 (statement -> iteration_statement .)
    ELSE            reduce using rule 37 (statement -> iteration_statement .)


state 116

    (38) statement -> return_statement .

    RBRACE          reduce using rule 38 (statement -> return_statement .)
    LBRACE          reduce using rule 38 (statement -> return_statement .)
    IF              reduce using rule 38 (statement -> return_statement .)
    WHILE           reduce using rule 38 (statement -> return_statement .)
    FOR             reduce using rule 38 (statement -> return_statement .)
    RETURN          reduce using rule 38 (statement -> return_statement .)
    CONTINUE        reduce using rule 38 (statement -> return_statement .)
    BREAK           reduce using rule 38 (statement -> return_statement .)
    INT             reduce using rule 38 (statement -> return_statement .)
    FLOAT           reduce using rule 38 (statement -> return_statement .)
    CHAR            reduce using rule 38 (statement -> return_statement .)
    VOID            reduce using rule 38 (statement -> return_statement .)
    IDENTIFIER      reduce using rule 38 (statement -> return_statement .)
    MINUS           reduce using rule 38 (statement -> return_statement .)
    NOT             reduce using rule 38 (statement -> return_statement .)
    INC             reduce using rule 38 (statement -> return_statement .)
    DEC             reduce using rule 38 (statement -> return_statement .)
    INT_LITERAL     reduce using rule 38 (statement -> return_statement .)
    FLOAT_LITERAL   reduce using rule 38 (statement -> return_statement .)
    CHAR_LITERAL    reduce using rule 38 (statement -> return_statement .)
    STRING_LITERAL  reduce using rule 38 (statement -> return_statement .)
    LPAREN          reduce using rule 38 (statement -> return_statement .)
    ELSE            reduce using rule 38 (statement -> return_statement .)


state 117

    (39) statement -> continue_statement .

    RBRACE          reduce using rule 39 (statement -> continue_statement .)
    LBRACE          reduce using rule 39 (statement -> continue_statement .)
    IF              reduce using rule 39 (statement -> continue_statement .)
    WHILE           reduce using rule 39 (statement -> continue_statement .)
    FOR             reduce using rule 39 (statement -> continue_statement .)
    RETURN          reduce using rule 39 (statement -> continue_statement .)
    CONTINUE        reduce using rule 39 (statement -> continue_statement .)
    BREAK           reduce using rule 39 (statement -> continue_statement .)
    INT             reduce using rule 39 (statement -> continue_statement .)
    FLOAT           reduce using rule 39 (statement -> continue_statement .)
    CHAR            reduce using rule 39 (statement -> continue_statement .)
    VOID            reduce using rule 39 (statement -> continue_statement .)
    IDENTIFIER      reduce using rule 39 (statement -> continue_statement .)
    MINUS           reduce using rule 39 (statement -> continue_statement .)
    NOT             reduce using rule 39 (statement -> continue_statement .)
    INC             reduce using rule 39 (statement -> continue_statement .)
    DEC             reduce using rule 39 (statement -> continue_statement .)
    INT_LITERAL     reduce using rule 39 (statement -> continue_statement .)
    FLOAT_LITERAL   reduce using rule 39 (statement -> continue_statement .)
    CHAR_LITERAL    reduce using rule 39 (statement -> continue_statement .)
    STRING_LITERAL  reduce using rule 39 (statement -> continue_statement .)
    LPAREN          reduce using rule 39 (statement -> continue_statement .)
    ELSE            reduce using rule 39 (statement -> continue_statement .)


state 118

    (40) statement -> break_statement .

    RBRACE          reduce using rule 40 (statement -> break_statement .)
    LBRACE          reduce using rule 40 (statement -> break_statement .)
    IF              reduce using rule 40 (statement -> break_statement .)
    WHILE           reduce using rule 40 (statement -> break_statement .)
    FOR             reduce using rule 40 (statement -> break_statement .)
    RETURN          reduce using rule 40 (statement -> break_statement .)
    CONTINUE        reduce using rule 40 (statement -> break_statement .)
    BREAK           reduce using rule 40 (statement -> break_statement .)
    INT             reduce using rule 40 (statement -> break_statement .)
    FLOAT           reduce using rule 40 (statement -> break_statement .)
    CHAR            reduce using rule 40 (statement -> break_statement .)
    VOID            reduce using rule 40 (statement -> break_statement .)
    IDENTIFIER      reduce using rule 40 (statement -> break_statement .)
    MINUS           reduce using rule 40 (statement -> break_statement .)
    NOT             reduce using rule 40 (statement -> break_statement .)
    INC             reduce using rule 40 (statement -> break_statement .)
    DEC             reduce using rule 40 (statement -> break_statement .)
    INT_LITERAL     reduce using rule 40 (statement -> break_statement .)
    FLOAT_LITERAL   reduce using rule 40 (statement -> break_statement .)
    CHAR_LITERAL    reduce using rule 40 (statement -> break_statement .)
    STRING_LITERAL  reduce using rule 40 (statement -> break_statement .)
    LPAREN          reduce using rule 40 (statement -> break_statement .)
    ELSE            reduce using rule 40 (statement -> break_statement .)


state 119

    (41) statement -> var_declaration .

    RBRACE          reduce using rule 41 (statement -> var_declaration .)
    LBRACE          reduce using rule 41 (statement -> var_declaration .)
    IF              reduce using rule 41 (statement -> var_declaration .)
    WHILE           reduce using rule 41 (statement -> var_declaration .)
    FOR             reduce using rule 41 (statement -> var_declaration .)
    RETURN          reduce using rule 41 (statement -> var_declaration .)
    CONTINUE        reduce using rule 41 (statement -> var_declaration .)
    BREAK           reduce using rule 41 (statement -> var_declaration .)
    INT             reduce using rule 41 (statement -> var_declaration .)
    FLOAT           reduce using rule 41 (statement -> var_declaration .)
    CHAR            reduce using rule 41 (statement -> var_declaration .)
    VOID            reduce using rule 41 (statement -> var_declaration .)
    IDENTIFIER      reduce using rule 41 (statement -> var_declaration .)
    MINUS           reduce using rule 41 (statement -> var_declaration .)
    NOT             reduce using rule 41 (statement -> var_declaration .)
    INC             reduce using rule 41 (statement -> var_declaration .)
    DEC             reduce using rule 41 (statement -> var_declaration .)
    INT_LITERAL     reduce using rule 41 (statement -> var_declaration .)
    FLOAT_LITERAL   reduce using rule 41 (statement -> var_declaration .)
    CHAR_LITERAL    reduce using rule 41 (statement -> var_declaration .)
    STRING_LITERAL  reduce using rule 41 (statement -> var_declaration .)
    LPAREN          reduce using rule 41 (statement -> var_declaration .)
    ELSE            reduce using rule 41 (statement -> var_declaration .)


state 120

    (42) statement -> array_declaration .

    RBRACE          reduce using rule 42 (statement -> array_declaration .)
    LBRACE          reduce using rule 42 (statement -> array_declaration .)
    IF              reduce using rule 42 (statement -> array_declaration .)
    WHILE           reduce using rule 42 (statement -> array_declaration .)
    FOR             reduce using rule 42 (statement -> array_declaration .)
    RETURN          reduce using rule 42 (statement -> array_declaration .)
    CONTINUE        reduce using rule 42 (statement -> array_declaration .)
    BREAK           reduce using rule 42 (statement -> array_declaration .)
    INT             reduce using rule 42 (statement -> array_declaration .)
    FLOAT           reduce using rule 42 (statement -> array_declaration .)
    CHAR            reduce using rule 42 (statement -> array_declaration .)
    VOID            reduce using rule 42 (statement -> array_declaration .)
    IDENTIFIER      reduce using rule 42 (statement -> array_declaration .)
    MINUS           reduce using rule 42 (statement -> array_declaration .)
    NOT             reduce using rule 42 (statement -> array_declaration .)
    INC             reduce using rule 42 (statement -> array_declaration .)
    DEC             reduce using rule 42 (statement -> array_declaration .)
    INT_LITERAL     reduce using rule 42 (statement -> array_declaration .)
    FLOAT_LITERAL   reduce using rule 42 (statement -> array_declaration .)
    CHAR_LITERAL    reduce using rule 42 (statement -> array_declaration .)
    STRING_LITERAL  reduce using rule 42 (statement -> array_declaration .)
    LPAREN          reduce using rule 42 (statement -> array_declaration .)
    ELSE            reduce using rule 42 (statement -> array_declaration .)


state 121

    (43) statement -> empty .

    RBRACE          reduce using rule 43 (statement -> empty .)
    LBRACE          reduce using rule 43 (statement -> empty .)
    IF              reduce using rule 43 (statement -> empty .)
    WHILE           reduce using rule 43 (statement -> empty .)
    FOR             reduce using rule 43 (statement -> empty .)
    RETURN          reduce using rule 43 (statement -> empty .)
    CONTINUE        reduce using rule 43 (statement -> empty .)
    BREAK           reduce using rule 43 (statement -> empty .)
    INT             reduce using rule 43 (statement -> empty .)
    FLOAT           reduce using rule 43 (statement -> empty .)
    CHAR            reduce using rule 43 (statement -> empty .)
    VOID            reduce using rule 43 (statement -> empty .)
    IDENTIFIER      reduce using rule 43 (statement -> empty .)
    MINUS           reduce using rule 43 (statement -> empty .)
    NOT             reduce using rule 43 (statement -> empty .)
    INC             reduce using rule 43 (statement -> empty .)
    DEC             reduce using rule 43 (statement -> empty .)
    INT_LITERAL     reduce using rule 43 (statement -> empty .)
    FLOAT_LITERAL   reduce using rule 43 (statement -> empty .)
    CHAR_LITERAL    reduce using rule 43 (statement -> empty .)
    STRING_LITERAL  reduce using rule 43 (statement -> empty .)
    LPAREN          reduce using rule 43 (statement -> empty .)
    ELSE            reduce using rule 43 (statement -> empty .)


state 122

    (44) expression_statement -> expression . SEMICOLON
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    SEMICOLON       shift and go to state 138
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63


state 123

    (83) selection_statement -> IF . LPAREN expression RPAREN statement
    (84) selection_statement -> IF . LPAREN expression RPAREN statement ELSE statement

    LPAREN          shift and go to state 139


state 124

    (85) iteration_statement -> WHILE . LPAREN expression RPAREN statement

    LPAREN          shift and go to state 140


state 125

    (86) iteration_statement -> FOR . LPAREN expression_statement expression_statement expression RPAREN statement
    (87) iteration_statement -> FOR . LPAREN var_declaration expression_statement expression RPAREN statement

    LPAREN          shift and go to state 141


state 126

    (88) return_statement -> RETURN . expression SEMICOLON
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 142
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 127

    (89) continue_statement -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 143


state 128

    (90) break_statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 144


state 129

    (8) var_declaration -> type_specifier . IDENTIFIER SEMICOLON
    (9) var_declaration -> type_specifier . TIMES IDENTIFIER SEMICOLON
    (10) var_declaration -> type_specifier . IDENTIFIER ASSIGN expression SEMICOLON
    (11) array_declaration -> type_specifier . IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (12) array_declaration -> type_specifier . IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (13) array_declaration -> type_specifier . IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (14) array_declaration -> type_specifier . IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (15) array_declaration -> type_specifier . IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON

    IDENTIFIER      shift and go to state 145
    TIMES           shift and go to state 15


state 130

    (12) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE . array_list RBRACE SEMICOLON
    (20) array_list -> . array_list COMMA expression
    (21) array_list -> . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 133
    array_list                     shift and go to state 146
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 131

    (14) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL . SEMICOLON

    SEMICOLON       shift and go to state 147


state 132

    (13) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list . RBRACE SEMICOLON
    (20) array_list -> array_list . COMMA expression

    RBRACE          shift and go to state 148
    COMMA           shift and go to state 149


state 133

    (21) array_list -> expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    RBRACE          reduce using rule 21 (array_list -> expression .)
    COMMA           reduce using rule 21 (array_list -> expression .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63


state 134

    (15) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .

    INT             reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    FLOAT           reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    CHAR            reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    VOID            reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    $end            reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    RBRACE          reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    LBRACE          reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    IF              reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    WHILE           reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    FOR             reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    RETURN          reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    CONTINUE        reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    BREAK           reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    IDENTIFIER      reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    MINUS           reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    NOT             reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    INC             reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    DEC             reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    INT_LITERAL     reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    CHAR_LITERAL    reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    STRING_LITERAL  reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    LPAREN          reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    ELSE            reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)


state 135

    (80) argument_list -> argument_list COMMA expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    RPAREN          reduce using rule 80 (argument_list -> argument_list COMMA expression .)
    COMMA           reduce using rule 80 (argument_list -> argument_list COMMA expression .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63


state 136

    (31) compound_statement -> LBRACE statement_list RBRACE .

    INT             reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    FLOAT           reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    CHAR            reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    VOID            reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    $end            reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    IF              reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    FOR             reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    CONTINUE        reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    BREAK           reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    IDENTIFIER      reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    MINUS           reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    NOT             reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    INC             reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    DEC             reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    INT_LITERAL     reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    FLOAT_LITERAL   reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    CHAR_LITERAL    reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    STRING_LITERAL  reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)
    ELSE            reduce using rule 31 (compound_statement -> LBRACE statement_list RBRACE .)


state 137

    (32) statement_list -> statement_list statement .

    RBRACE          reduce using rule 32 (statement_list -> statement_list statement .)
    LBRACE          reduce using rule 32 (statement_list -> statement_list statement .)
    IF              reduce using rule 32 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 32 (statement_list -> statement_list statement .)
    FOR             reduce using rule 32 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 32 (statement_list -> statement_list statement .)
    CONTINUE        reduce using rule 32 (statement_list -> statement_list statement .)
    BREAK           reduce using rule 32 (statement_list -> statement_list statement .)
    INT             reduce using rule 32 (statement_list -> statement_list statement .)
    FLOAT           reduce using rule 32 (statement_list -> statement_list statement .)
    CHAR            reduce using rule 32 (statement_list -> statement_list statement .)
    VOID            reduce using rule 32 (statement_list -> statement_list statement .)
    IDENTIFIER      reduce using rule 32 (statement_list -> statement_list statement .)
    MINUS           reduce using rule 32 (statement_list -> statement_list statement .)
    NOT             reduce using rule 32 (statement_list -> statement_list statement .)
    INC             reduce using rule 32 (statement_list -> statement_list statement .)
    DEC             reduce using rule 32 (statement_list -> statement_list statement .)
    INT_LITERAL     reduce using rule 32 (statement_list -> statement_list statement .)
    FLOAT_LITERAL   reduce using rule 32 (statement_list -> statement_list statement .)
    CHAR_LITERAL    reduce using rule 32 (statement_list -> statement_list statement .)
    STRING_LITERAL  reduce using rule 32 (statement_list -> statement_list statement .)
    LPAREN          reduce using rule 32 (statement_list -> statement_list statement .)


state 138

    (44) expression_statement -> expression SEMICOLON .

    RBRACE          reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    LBRACE          reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    IF              reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    WHILE           reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    FOR             reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    RETURN          reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    CONTINUE        reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    BREAK           reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    INT             reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    FLOAT           reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    CHAR            reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    VOID            reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    MINUS           reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    NOT             reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    INC             reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    DEC             reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    INT_LITERAL     reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    CHAR_LITERAL    reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    STRING_LITERAL  reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    LPAREN          reduce using rule 44 (expression_statement -> expression SEMICOLON .)
    ELSE            reduce using rule 44 (expression_statement -> expression SEMICOLON .)


state 139

    (83) selection_statement -> IF LPAREN . expression RPAREN statement
    (84) selection_statement -> IF LPAREN . expression RPAREN statement ELSE statement
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 150
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 140

    (85) iteration_statement -> WHILE LPAREN . expression RPAREN statement
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 151
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 141

    (86) iteration_statement -> FOR LPAREN . expression_statement expression_statement expression RPAREN statement
    (87) iteration_statement -> FOR LPAREN . var_declaration expression_statement expression RPAREN statement
    (44) expression_statement -> . expression SEMICOLON
    (8) var_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (9) var_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (10) var_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (16) type_specifier -> . INT
    (17) type_specifier -> . FLOAT
    (18) type_specifier -> . CHAR
    (19) type_specifier -> . VOID
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    VOID            shift and go to state 12
    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression_statement           shift and go to state 152
    expression                     shift and go to state 122
    var_declaration                shift and go to state 153
    type_specifier                 shift and go to state 154
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 142

    (88) return_statement -> RETURN expression . SEMICOLON
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    SEMICOLON       shift and go to state 155
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63


state 143

    (89) continue_statement -> CONTINUE SEMICOLON .

    RBRACE          reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    LBRACE          reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    IF              reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    INT             reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    CHAR            reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    VOID            reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    IDENTIFIER      reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    MINUS           reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    NOT             reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    INC             reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    DEC             reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    INT_LITERAL     reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    CHAR_LITERAL    reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    STRING_LITERAL  reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 89 (continue_statement -> CONTINUE SEMICOLON .)


state 144

    (90) break_statement -> BREAK SEMICOLON .

    RBRACE          reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    IF              reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    FOR             reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    RETURN          reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    INT             reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    CHAR            reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    VOID            reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    IDENTIFIER      reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    MINUS           reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    NOT             reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    INC             reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    DEC             reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    INT_LITERAL     reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    CHAR_LITERAL    reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    STRING_LITERAL  reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 90 (break_statement -> BREAK SEMICOLON .)
    ELSE            reduce using rule 90 (break_statement -> BREAK SEMICOLON .)


state 145

    (8) var_declaration -> type_specifier IDENTIFIER . SEMICOLON
    (10) var_declaration -> type_specifier IDENTIFIER . ASSIGN expression SEMICOLON
    (11) array_declaration -> type_specifier IDENTIFIER . LBRACKET expression RBRACKET SEMICOLON
    (12) array_declaration -> type_specifier IDENTIFIER . LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (13) array_declaration -> type_specifier IDENTIFIER . LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (14) array_declaration -> type_specifier IDENTIFIER . LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (15) array_declaration -> type_specifier IDENTIFIER . LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON

    SEMICOLON       shift and go to state 16
    ASSIGN          shift and go to state 17
    LBRACKET        shift and go to state 19


state 146

    (12) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list . RBRACE SEMICOLON
    (20) array_list -> array_list . COMMA expression

    RBRACE          shift and go to state 156
    COMMA           shift and go to state 149


state 147

    (14) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .

    INT             reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    FLOAT           reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    CHAR            reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    VOID            reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    $end            reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    RBRACE          reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    LBRACE          reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    IF              reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    WHILE           reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    FOR             reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    RETURN          reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    CONTINUE        reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    BREAK           reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    IDENTIFIER      reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    MINUS           reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    NOT             reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    INC             reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    DEC             reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    INT_LITERAL     reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    CHAR_LITERAL    reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    STRING_LITERAL  reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    LPAREN          reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    ELSE            reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)


state 148

    (13) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 157


state 149

    (20) array_list -> array_list COMMA . expression
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 158
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 150

    (83) selection_statement -> IF LPAREN expression . RPAREN statement
    (84) selection_statement -> IF LPAREN expression . RPAREN statement ELSE statement
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    RPAREN          shift and go to state 159
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63


state 151

    (85) iteration_statement -> WHILE LPAREN expression . RPAREN statement
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    RPAREN          shift and go to state 160
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63


state 152

    (86) iteration_statement -> FOR LPAREN expression_statement . expression_statement expression RPAREN statement
    (44) expression_statement -> . expression SEMICOLON
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression_statement           shift and go to state 161
    expression                     shift and go to state 122
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 153

    (87) iteration_statement -> FOR LPAREN var_declaration . expression_statement expression RPAREN statement
    (44) expression_statement -> . expression SEMICOLON
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression_statement           shift and go to state 162
    expression                     shift and go to state 122
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 154

    (8) var_declaration -> type_specifier . IDENTIFIER SEMICOLON
    (9) var_declaration -> type_specifier . TIMES IDENTIFIER SEMICOLON
    (10) var_declaration -> type_specifier . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 163
    TIMES           shift and go to state 15


state 155

    (88) return_statement -> RETURN expression SEMICOLON .

    RBRACE          reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    LBRACE          reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    CONTINUE        reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    BREAK           reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    INT             reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    FLOAT           reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    CHAR            reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    VOID            reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    MINUS           reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    NOT             reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    INC             reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    DEC             reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    INT_LITERAL     reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    CHAR_LITERAL    reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    STRING_LITERAL  reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    LPAREN          reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 88 (return_statement -> RETURN expression SEMICOLON .)


state 156

    (12) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 164


state 157

    (13) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .

    INT             reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    FLOAT           reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    CHAR            reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    VOID            reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    $end            reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    RBRACE          reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    LBRACE          reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    IF              reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    WHILE           reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    FOR             reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    RETURN          reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    CONTINUE        reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    BREAK           reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    IDENTIFIER      reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    MINUS           reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    NOT             reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    INC             reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    DEC             reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    INT_LITERAL     reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    CHAR_LITERAL    reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    STRING_LITERAL  reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    LPAREN          reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    ELSE            reduce using rule 13 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)


state 158

    (20) array_list -> array_list COMMA expression .
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    RBRACE          reduce using rule 20 (array_list -> array_list COMMA expression .)
    COMMA           reduce using rule 20 (array_list -> array_list COMMA expression .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63


state 159

    (83) selection_statement -> IF LPAREN expression RPAREN . statement
    (84) selection_statement -> IF LPAREN expression RPAREN . statement ELSE statement
    (34) statement -> . expression_statement
    (35) statement -> . compound_statement
    (36) statement -> . selection_statement
    (37) statement -> . iteration_statement
    (38) statement -> . return_statement
    (39) statement -> . continue_statement
    (40) statement -> . break_statement
    (41) statement -> . var_declaration
    (42) statement -> . array_declaration
    (43) statement -> . empty
    (44) expression_statement -> . expression SEMICOLON
    (31) compound_statement -> . LBRACE statement_list RBRACE
    (83) selection_statement -> . IF LPAREN expression RPAREN statement
    (84) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (85) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (86) iteration_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
    (87) iteration_statement -> . FOR LPAREN var_declaration expression_statement expression RPAREN statement
    (88) return_statement -> . RETURN expression SEMICOLON
    (89) continue_statement -> . CONTINUE SEMICOLON
    (90) break_statement -> . BREAK SEMICOLON
    (8) var_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (9) var_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (10) var_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (11) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (12) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (13) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (14) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (15) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (30) empty -> .
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (16) type_specifier -> . INT
    (17) type_specifier -> . FLOAT
    (18) type_specifier -> . CHAR
    (19) type_specifier -> . VOID
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for FLOAT_LITERAL resolved as shift
  ! shift/reduce conflict for CHAR_LITERAL resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 100
    IF              shift and go to state 123
    WHILE           shift and go to state 124
    FOR             shift and go to state 125
    RETURN          shift and go to state 126
    CONTINUE        shift and go to state 127
    BREAK           shift and go to state 128
    ELSE            reduce using rule 30 (empty -> .)
    RBRACE          reduce using rule 30 (empty -> .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    VOID            shift and go to state 12
    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

  ! LBRACE          [ reduce using rule 30 (empty -> .) ]
  ! IF              [ reduce using rule 30 (empty -> .) ]
  ! WHILE           [ reduce using rule 30 (empty -> .) ]
  ! FOR             [ reduce using rule 30 (empty -> .) ]
  ! RETURN          [ reduce using rule 30 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 30 (empty -> .) ]
  ! BREAK           [ reduce using rule 30 (empty -> .) ]
  ! INT             [ reduce using rule 30 (empty -> .) ]
  ! FLOAT           [ reduce using rule 30 (empty -> .) ]
  ! CHAR            [ reduce using rule 30 (empty -> .) ]
  ! VOID            [ reduce using rule 30 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 30 (empty -> .) ]
  ! MINUS           [ reduce using rule 30 (empty -> .) ]
  ! NOT             [ reduce using rule 30 (empty -> .) ]
  ! INC             [ reduce using rule 30 (empty -> .) ]
  ! DEC             [ reduce using rule 30 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 30 (empty -> .) ]
  ! FLOAT_LITERAL   [ reduce using rule 30 (empty -> .) ]
  ! CHAR_LITERAL    [ reduce using rule 30 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 30 (empty -> .) ]
  ! LPAREN          [ reduce using rule 30 (empty -> .) ]

    expression                     shift and go to state 122
    statement                      shift and go to state 165
    expression_statement           shift and go to state 112
    compound_statement             shift and go to state 113
    selection_statement            shift and go to state 114
    iteration_statement            shift and go to state 115
    return_statement               shift and go to state 116
    continue_statement             shift and go to state 117
    break_statement                shift and go to state 118
    var_declaration                shift and go to state 119
    array_declaration              shift and go to state 120
    empty                          shift and go to state 121
    type_specifier                 shift and go to state 129
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 160

    (85) iteration_statement -> WHILE LPAREN expression RPAREN . statement
    (34) statement -> . expression_statement
    (35) statement -> . compound_statement
    (36) statement -> . selection_statement
    (37) statement -> . iteration_statement
    (38) statement -> . return_statement
    (39) statement -> . continue_statement
    (40) statement -> . break_statement
    (41) statement -> . var_declaration
    (42) statement -> . array_declaration
    (43) statement -> . empty
    (44) expression_statement -> . expression SEMICOLON
    (31) compound_statement -> . LBRACE statement_list RBRACE
    (83) selection_statement -> . IF LPAREN expression RPAREN statement
    (84) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (85) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (86) iteration_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
    (87) iteration_statement -> . FOR LPAREN var_declaration expression_statement expression RPAREN statement
    (88) return_statement -> . RETURN expression SEMICOLON
    (89) continue_statement -> . CONTINUE SEMICOLON
    (90) break_statement -> . BREAK SEMICOLON
    (8) var_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (9) var_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (10) var_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (11) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (12) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (13) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (14) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (15) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (30) empty -> .
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (16) type_specifier -> . INT
    (17) type_specifier -> . FLOAT
    (18) type_specifier -> . CHAR
    (19) type_specifier -> . VOID
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for FLOAT_LITERAL resolved as shift
  ! shift/reduce conflict for CHAR_LITERAL resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 100
    IF              shift and go to state 123
    WHILE           shift and go to state 124
    FOR             shift and go to state 125
    RETURN          shift and go to state 126
    CONTINUE        shift and go to state 127
    BREAK           shift and go to state 128
    ELSE            reduce using rule 30 (empty -> .)
    RBRACE          reduce using rule 30 (empty -> .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    VOID            shift and go to state 12
    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

  ! LBRACE          [ reduce using rule 30 (empty -> .) ]
  ! IF              [ reduce using rule 30 (empty -> .) ]
  ! WHILE           [ reduce using rule 30 (empty -> .) ]
  ! FOR             [ reduce using rule 30 (empty -> .) ]
  ! RETURN          [ reduce using rule 30 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 30 (empty -> .) ]
  ! BREAK           [ reduce using rule 30 (empty -> .) ]
  ! INT             [ reduce using rule 30 (empty -> .) ]
  ! FLOAT           [ reduce using rule 30 (empty -> .) ]
  ! CHAR            [ reduce using rule 30 (empty -> .) ]
  ! VOID            [ reduce using rule 30 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 30 (empty -> .) ]
  ! MINUS           [ reduce using rule 30 (empty -> .) ]
  ! NOT             [ reduce using rule 30 (empty -> .) ]
  ! INC             [ reduce using rule 30 (empty -> .) ]
  ! DEC             [ reduce using rule 30 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 30 (empty -> .) ]
  ! FLOAT_LITERAL   [ reduce using rule 30 (empty -> .) ]
  ! CHAR_LITERAL    [ reduce using rule 30 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 30 (empty -> .) ]
  ! LPAREN          [ reduce using rule 30 (empty -> .) ]

    expression                     shift and go to state 122
    statement                      shift and go to state 166
    expression_statement           shift and go to state 112
    compound_statement             shift and go to state 113
    selection_statement            shift and go to state 114
    iteration_statement            shift and go to state 115
    return_statement               shift and go to state 116
    continue_statement             shift and go to state 117
    break_statement                shift and go to state 118
    var_declaration                shift and go to state 119
    array_declaration              shift and go to state 120
    empty                          shift and go to state 121
    type_specifier                 shift and go to state 129
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 161

    (86) iteration_statement -> FOR LPAREN expression_statement expression_statement . expression RPAREN statement
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 167
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 162

    (87) iteration_statement -> FOR LPAREN var_declaration expression_statement . expression RPAREN statement
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

    expression                     shift and go to state 168
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 163

    (8) var_declaration -> type_specifier IDENTIFIER . SEMICOLON
    (10) var_declaration -> type_specifier IDENTIFIER . ASSIGN expression SEMICOLON

    SEMICOLON       shift and go to state 16
    ASSIGN          shift and go to state 17


state 164

    (12) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .

    INT             reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    FLOAT           reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    CHAR            reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    VOID            reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    $end            reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    RBRACE          reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    LBRACE          reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    IF              reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    WHILE           reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    FOR             reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    RETURN          reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    CONTINUE        reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    BREAK           reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    IDENTIFIER      reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    MINUS           reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    NOT             reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    INC             reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    DEC             reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    INT_LITERAL     reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    CHAR_LITERAL    reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    STRING_LITERAL  reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    LPAREN          reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    ELSE            reduce using rule 12 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)


state 165

    (83) selection_statement -> IF LPAREN expression RPAREN statement .
    (84) selection_statement -> IF LPAREN expression RPAREN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    RBRACE          reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    LBRACE          reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    IF              reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    WHILE           reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    FOR             reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    RETURN          reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    CONTINUE        reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    BREAK           reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    INT             reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    FLOAT           reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    CHAR            reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    VOID            reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    IDENTIFIER      reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    MINUS           reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    NOT             reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    INC             reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    DEC             reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    INT_LITERAL     reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    FLOAT_LITERAL   reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    CHAR_LITERAL    reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    STRING_LITERAL  reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    LPAREN          reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .)
    ELSE            shift and go to state 169

  ! ELSE            [ reduce using rule 83 (selection_statement -> IF LPAREN expression RPAREN statement .) ]


state 166

    (85) iteration_statement -> WHILE LPAREN expression RPAREN statement .

    RBRACE          reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    LBRACE          reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    IF              reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    WHILE           reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    FOR             reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    RETURN          reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    CONTINUE        reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    BREAK           reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    INT             reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    FLOAT           reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    CHAR            reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    VOID            reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    IDENTIFIER      reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    MINUS           reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    NOT             reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    INC             reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    DEC             reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    INT_LITERAL     reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    FLOAT_LITERAL   reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    CHAR_LITERAL    reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    STRING_LITERAL  reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    LPAREN          reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    ELSE            reduce using rule 85 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)


state 167

    (86) iteration_statement -> FOR LPAREN expression_statement expression_statement expression . RPAREN statement
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    RPAREN          shift and go to state 170
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63


state 168

    (87) iteration_statement -> FOR LPAREN var_declaration expression_statement expression . RPAREN statement
    (51) binary_expression -> expression . PLUS expression
    (52) binary_expression -> expression . MINUS expression
    (53) binary_expression -> expression . TIMES expression
    (54) binary_expression -> expression . DIVIDE expression
    (55) binary_expression -> expression . MOD expression
    (56) binary_expression -> expression . EQ expression
    (57) binary_expression -> expression . NEQ expression
    (58) binary_expression -> expression . LT expression
    (59) binary_expression -> expression . GT expression
    (60) binary_expression -> expression . LTE expression
    (61) binary_expression -> expression . GTE expression
    (62) binary_expression -> expression . AND expression
    (63) binary_expression -> expression . OR expression

    RPAREN          shift and go to state 171
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63


state 169

    (84) selection_statement -> IF LPAREN expression RPAREN statement ELSE . statement
    (34) statement -> . expression_statement
    (35) statement -> . compound_statement
    (36) statement -> . selection_statement
    (37) statement -> . iteration_statement
    (38) statement -> . return_statement
    (39) statement -> . continue_statement
    (40) statement -> . break_statement
    (41) statement -> . var_declaration
    (42) statement -> . array_declaration
    (43) statement -> . empty
    (44) expression_statement -> . expression SEMICOLON
    (31) compound_statement -> . LBRACE statement_list RBRACE
    (83) selection_statement -> . IF LPAREN expression RPAREN statement
    (84) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (85) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (86) iteration_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
    (87) iteration_statement -> . FOR LPAREN var_declaration expression_statement expression RPAREN statement
    (88) return_statement -> . RETURN expression SEMICOLON
    (89) continue_statement -> . CONTINUE SEMICOLON
    (90) break_statement -> . BREAK SEMICOLON
    (8) var_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (9) var_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (10) var_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (11) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (12) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (13) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (14) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (15) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (30) empty -> .
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (16) type_specifier -> . INT
    (17) type_specifier -> . FLOAT
    (18) type_specifier -> . CHAR
    (19) type_specifier -> . VOID
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for FLOAT_LITERAL resolved as shift
  ! shift/reduce conflict for CHAR_LITERAL resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 100
    IF              shift and go to state 123
    WHILE           shift and go to state 124
    FOR             shift and go to state 125
    RETURN          shift and go to state 126
    CONTINUE        shift and go to state 127
    BREAK           shift and go to state 128
    ELSE            reduce using rule 30 (empty -> .)
    RBRACE          reduce using rule 30 (empty -> .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    VOID            shift and go to state 12
    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

  ! LBRACE          [ reduce using rule 30 (empty -> .) ]
  ! IF              [ reduce using rule 30 (empty -> .) ]
  ! WHILE           [ reduce using rule 30 (empty -> .) ]
  ! FOR             [ reduce using rule 30 (empty -> .) ]
  ! RETURN          [ reduce using rule 30 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 30 (empty -> .) ]
  ! BREAK           [ reduce using rule 30 (empty -> .) ]
  ! INT             [ reduce using rule 30 (empty -> .) ]
  ! FLOAT           [ reduce using rule 30 (empty -> .) ]
  ! CHAR            [ reduce using rule 30 (empty -> .) ]
  ! VOID            [ reduce using rule 30 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 30 (empty -> .) ]
  ! MINUS           [ reduce using rule 30 (empty -> .) ]
  ! NOT             [ reduce using rule 30 (empty -> .) ]
  ! INC             [ reduce using rule 30 (empty -> .) ]
  ! DEC             [ reduce using rule 30 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 30 (empty -> .) ]
  ! FLOAT_LITERAL   [ reduce using rule 30 (empty -> .) ]
  ! CHAR_LITERAL    [ reduce using rule 30 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 30 (empty -> .) ]
  ! LPAREN          [ reduce using rule 30 (empty -> .) ]

    expression                     shift and go to state 122
    statement                      shift and go to state 172
    expression_statement           shift and go to state 112
    compound_statement             shift and go to state 113
    selection_statement            shift and go to state 114
    iteration_statement            shift and go to state 115
    return_statement               shift and go to state 116
    continue_statement             shift and go to state 117
    break_statement                shift and go to state 118
    var_declaration                shift and go to state 119
    array_declaration              shift and go to state 120
    empty                          shift and go to state 121
    type_specifier                 shift and go to state 129
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 170

    (86) iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN . statement
    (34) statement -> . expression_statement
    (35) statement -> . compound_statement
    (36) statement -> . selection_statement
    (37) statement -> . iteration_statement
    (38) statement -> . return_statement
    (39) statement -> . continue_statement
    (40) statement -> . break_statement
    (41) statement -> . var_declaration
    (42) statement -> . array_declaration
    (43) statement -> . empty
    (44) expression_statement -> . expression SEMICOLON
    (31) compound_statement -> . LBRACE statement_list RBRACE
    (83) selection_statement -> . IF LPAREN expression RPAREN statement
    (84) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (85) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (86) iteration_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
    (87) iteration_statement -> . FOR LPAREN var_declaration expression_statement expression RPAREN statement
    (88) return_statement -> . RETURN expression SEMICOLON
    (89) continue_statement -> . CONTINUE SEMICOLON
    (90) break_statement -> . BREAK SEMICOLON
    (8) var_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (9) var_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (10) var_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (11) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (12) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (13) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (14) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (15) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (30) empty -> .
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (16) type_specifier -> . INT
    (17) type_specifier -> . FLOAT
    (18) type_specifier -> . CHAR
    (19) type_specifier -> . VOID
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for FLOAT_LITERAL resolved as shift
  ! shift/reduce conflict for CHAR_LITERAL resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 100
    IF              shift and go to state 123
    WHILE           shift and go to state 124
    FOR             shift and go to state 125
    RETURN          shift and go to state 126
    CONTINUE        shift and go to state 127
    BREAK           shift and go to state 128
    ELSE            reduce using rule 30 (empty -> .)
    RBRACE          reduce using rule 30 (empty -> .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    VOID            shift and go to state 12
    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

  ! LBRACE          [ reduce using rule 30 (empty -> .) ]
  ! IF              [ reduce using rule 30 (empty -> .) ]
  ! WHILE           [ reduce using rule 30 (empty -> .) ]
  ! FOR             [ reduce using rule 30 (empty -> .) ]
  ! RETURN          [ reduce using rule 30 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 30 (empty -> .) ]
  ! BREAK           [ reduce using rule 30 (empty -> .) ]
  ! INT             [ reduce using rule 30 (empty -> .) ]
  ! FLOAT           [ reduce using rule 30 (empty -> .) ]
  ! CHAR            [ reduce using rule 30 (empty -> .) ]
  ! VOID            [ reduce using rule 30 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 30 (empty -> .) ]
  ! MINUS           [ reduce using rule 30 (empty -> .) ]
  ! NOT             [ reduce using rule 30 (empty -> .) ]
  ! INC             [ reduce using rule 30 (empty -> .) ]
  ! DEC             [ reduce using rule 30 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 30 (empty -> .) ]
  ! FLOAT_LITERAL   [ reduce using rule 30 (empty -> .) ]
  ! CHAR_LITERAL    [ reduce using rule 30 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 30 (empty -> .) ]
  ! LPAREN          [ reduce using rule 30 (empty -> .) ]

    expression_statement           shift and go to state 112
    expression                     shift and go to state 122
    statement                      shift and go to state 173
    compound_statement             shift and go to state 113
    selection_statement            shift and go to state 114
    iteration_statement            shift and go to state 115
    return_statement               shift and go to state 116
    continue_statement             shift and go to state 117
    break_statement                shift and go to state 118
    var_declaration                shift and go to state 119
    array_declaration              shift and go to state 120
    empty                          shift and go to state 121
    type_specifier                 shift and go to state 129
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 171

    (87) iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN . statement
    (34) statement -> . expression_statement
    (35) statement -> . compound_statement
    (36) statement -> . selection_statement
    (37) statement -> . iteration_statement
    (38) statement -> . return_statement
    (39) statement -> . continue_statement
    (40) statement -> . break_statement
    (41) statement -> . var_declaration
    (42) statement -> . array_declaration
    (43) statement -> . empty
    (44) expression_statement -> . expression SEMICOLON
    (31) compound_statement -> . LBRACE statement_list RBRACE
    (83) selection_statement -> . IF LPAREN expression RPAREN statement
    (84) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (85) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (86) iteration_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
    (87) iteration_statement -> . FOR LPAREN var_declaration expression_statement expression RPAREN statement
    (88) return_statement -> . RETURN expression SEMICOLON
    (89) continue_statement -> . CONTINUE SEMICOLON
    (90) break_statement -> . BREAK SEMICOLON
    (8) var_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (9) var_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (10) var_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (11) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (12) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (13) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (14) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (15) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (30) empty -> .
    (45) expression -> . assignment_expression
    (46) expression -> . binary_expression
    (47) expression -> . unary_expression
    (48) expression -> . term
    (16) type_specifier -> . INT
    (17) type_specifier -> . FLOAT
    (18) type_specifier -> . CHAR
    (19) type_specifier -> . VOID
    (49) assignment_expression -> . IDENTIFIER ASSIGN expression
    (50) assignment_expression -> . array_access ASSIGN expression
    (51) binary_expression -> . expression PLUS expression
    (52) binary_expression -> . expression MINUS expression
    (53) binary_expression -> . expression TIMES expression
    (54) binary_expression -> . expression DIVIDE expression
    (55) binary_expression -> . expression MOD expression
    (56) binary_expression -> . expression EQ expression
    (57) binary_expression -> . expression NEQ expression
    (58) binary_expression -> . expression LT expression
    (59) binary_expression -> . expression GT expression
    (60) binary_expression -> . expression LTE expression
    (61) binary_expression -> . expression GTE expression
    (62) binary_expression -> . expression AND expression
    (63) binary_expression -> . expression OR expression
    (64) unary_expression -> . MINUS expression
    (65) unary_expression -> . NOT expression
    (66) unary_expression -> . INC IDENTIFIER
    (67) unary_expression -> . DEC IDENTIFIER
    (68) unary_expression -> . IDENTIFIER INC
    (69) unary_expression -> . IDENTIFIER DEC
    (70) term -> . IDENTIFIER
    (71) term -> . INT_LITERAL
    (72) term -> . FLOAT_LITERAL
    (73) term -> . CHAR_LITERAL
    (74) term -> . STRING_LITERAL
    (75) term -> . LPAREN expression RPAREN
    (76) term -> . function_call
    (77) term -> . array_access
    (79) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (78) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for FLOAT_LITERAL resolved as shift
  ! shift/reduce conflict for CHAR_LITERAL resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 100
    IF              shift and go to state 123
    WHILE           shift and go to state 124
    FOR             shift and go to state 125
    RETURN          shift and go to state 126
    CONTINUE        shift and go to state 127
    BREAK           shift and go to state 128
    ELSE            reduce using rule 30 (empty -> .)
    RBRACE          reduce using rule 30 (empty -> .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    VOID            shift and go to state 12
    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 31
    INT_LITERAL     shift and go to state 32
    FLOAT_LITERAL   shift and go to state 33
    CHAR_LITERAL    shift and go to state 34
    STRING_LITERAL  shift and go to state 35
    LPAREN          shift and go to state 36

  ! LBRACE          [ reduce using rule 30 (empty -> .) ]
  ! IF              [ reduce using rule 30 (empty -> .) ]
  ! WHILE           [ reduce using rule 30 (empty -> .) ]
  ! FOR             [ reduce using rule 30 (empty -> .) ]
  ! RETURN          [ reduce using rule 30 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 30 (empty -> .) ]
  ! BREAK           [ reduce using rule 30 (empty -> .) ]
  ! INT             [ reduce using rule 30 (empty -> .) ]
  ! FLOAT           [ reduce using rule 30 (empty -> .) ]
  ! CHAR            [ reduce using rule 30 (empty -> .) ]
  ! VOID            [ reduce using rule 30 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 30 (empty -> .) ]
  ! MINUS           [ reduce using rule 30 (empty -> .) ]
  ! NOT             [ reduce using rule 30 (empty -> .) ]
  ! INC             [ reduce using rule 30 (empty -> .) ]
  ! DEC             [ reduce using rule 30 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 30 (empty -> .) ]
  ! FLOAT_LITERAL   [ reduce using rule 30 (empty -> .) ]
  ! CHAR_LITERAL    [ reduce using rule 30 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 30 (empty -> .) ]
  ! LPAREN          [ reduce using rule 30 (empty -> .) ]

    var_declaration                shift and go to state 119
    expression_statement           shift and go to state 112
    expression                     shift and go to state 122
    statement                      shift and go to state 174
    compound_statement             shift and go to state 113
    selection_statement            shift and go to state 114
    iteration_statement            shift and go to state 115
    return_statement               shift and go to state 116
    continue_statement             shift and go to state 117
    break_statement                shift and go to state 118
    array_declaration              shift and go to state 120
    empty                          shift and go to state 121
    type_specifier                 shift and go to state 129
    assignment_expression          shift and go to state 23
    binary_expression              shift and go to state 24
    unary_expression               shift and go to state 25
    term                           shift and go to state 26
    array_access                   shift and go to state 27
    function_call                  shift and go to state 37

state 172

    (84) selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .

    RBRACE          reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    LBRACE          reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    IF              reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    WHILE           reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    FOR             reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    RETURN          reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    CONTINUE        reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    BREAK           reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    INT             reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    FLOAT           reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    CHAR            reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    VOID            reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    IDENTIFIER      reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    MINUS           reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    NOT             reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    INC             reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    DEC             reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    INT_LITERAL     reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    FLOAT_LITERAL   reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    CHAR_LITERAL    reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    STRING_LITERAL  reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    LPAREN          reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    ELSE            reduce using rule 84 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)


state 173

    (86) iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .

    RBRACE          reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    LBRACE          reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    IF              reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    WHILE           reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    FOR             reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    RETURN          reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    CONTINUE        reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    BREAK           reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    INT             reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    FLOAT           reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    CHAR            reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    VOID            reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    IDENTIFIER      reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    MINUS           reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    NOT             reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    INC             reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    DEC             reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    INT_LITERAL     reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    FLOAT_LITERAL   reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    CHAR_LITERAL    reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    STRING_LITERAL  reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    LPAREN          reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    ELSE            reduce using rule 86 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)


state 174

    (87) iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .

    RBRACE          reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    LBRACE          reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    IF              reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    WHILE           reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    FOR             reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    RETURN          reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    CONTINUE        reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    BREAK           reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    INT             reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    FLOAT           reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    CHAR            reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    VOID            reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    IDENTIFIER      reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    MINUS           reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    NOT             reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    INC             reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    DEC             reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    INT_LITERAL     reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    FLOAT_LITERAL   reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    CHAR_LITERAL    reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    STRING_LITERAL  reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    LPAREN          reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    ELSE            reduce using rule 87 (iteration_statement -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 76 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 76 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 76 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 76 resolved as shift
WARNING: shift/reduce conflict for MOD in state 76 resolved as shift
WARNING: shift/reduce conflict for EQ in state 76 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 76 resolved as shift
WARNING: shift/reduce conflict for LT in state 76 resolved as shift
WARNING: shift/reduce conflict for GT in state 76 resolved as shift
WARNING: shift/reduce conflict for LTE in state 76 resolved as shift
WARNING: shift/reduce conflict for GTE in state 76 resolved as shift
WARNING: shift/reduce conflict for AND in state 76 resolved as shift
WARNING: shift/reduce conflict for OR in state 76 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 94 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 94 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 94 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 94 resolved as shift
WARNING: shift/reduce conflict for MOD in state 94 resolved as shift
WARNING: shift/reduce conflict for EQ in state 94 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 94 resolved as shift
WARNING: shift/reduce conflict for LT in state 94 resolved as shift
WARNING: shift/reduce conflict for GT in state 94 resolved as shift
WARNING: shift/reduce conflict for LTE in state 94 resolved as shift
WARNING: shift/reduce conflict for GTE in state 94 resolved as shift
WARNING: shift/reduce conflict for AND in state 94 resolved as shift
WARNING: shift/reduce conflict for OR in state 94 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 100 resolved as shift
WARNING: shift/reduce conflict for IF in state 100 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 100 resolved as shift
WARNING: shift/reduce conflict for FOR in state 100 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 100 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 100 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 100 resolved as shift
WARNING: shift/reduce conflict for INT in state 100 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 100 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 100 resolved as shift
WARNING: shift/reduce conflict for VOID in state 100 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 100 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 100 resolved as shift
WARNING: shift/reduce conflict for NOT in state 100 resolved as shift
WARNING: shift/reduce conflict for INC in state 100 resolved as shift
WARNING: shift/reduce conflict for DEC in state 100 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 100 resolved as shift
WARNING: shift/reduce conflict for FLOAT_LITERAL in state 100 resolved as shift
WARNING: shift/reduce conflict for CHAR_LITERAL in state 100 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 100 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 100 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 110 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 110 resolved as shift
WARNING: shift/reduce conflict for IF in state 110 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 110 resolved as shift
WARNING: shift/reduce conflict for FOR in state 110 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 110 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 110 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 110 resolved as shift
WARNING: shift/reduce conflict for INT in state 110 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 110 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 110 resolved as shift
WARNING: shift/reduce conflict for VOID in state 110 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 110 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 110 resolved as shift
WARNING: shift/reduce conflict for NOT in state 110 resolved as shift
WARNING: shift/reduce conflict for INC in state 110 resolved as shift
WARNING: shift/reduce conflict for DEC in state 110 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 110 resolved as shift
WARNING: shift/reduce conflict for FLOAT_LITERAL in state 110 resolved as shift
WARNING: shift/reduce conflict for CHAR_LITERAL in state 110 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 110 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 110 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 159 resolved as shift
WARNING: shift/reduce conflict for IF in state 159 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 159 resolved as shift
WARNING: shift/reduce conflict for FOR in state 159 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 159 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 159 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 159 resolved as shift
WARNING: shift/reduce conflict for INT in state 159 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 159 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 159 resolved as shift
WARNING: shift/reduce conflict for VOID in state 159 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 159 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 159 resolved as shift
WARNING: shift/reduce conflict for NOT in state 159 resolved as shift
WARNING: shift/reduce conflict for INC in state 159 resolved as shift
WARNING: shift/reduce conflict for DEC in state 159 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 159 resolved as shift
WARNING: shift/reduce conflict for FLOAT_LITERAL in state 159 resolved as shift
WARNING: shift/reduce conflict for CHAR_LITERAL in state 159 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 159 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 159 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 160 resolved as shift
WARNING: shift/reduce conflict for IF in state 160 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 160 resolved as shift
WARNING: shift/reduce conflict for FOR in state 160 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 160 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 160 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 160 resolved as shift
WARNING: shift/reduce conflict for INT in state 160 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 160 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 160 resolved as shift
WARNING: shift/reduce conflict for VOID in state 160 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 160 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 160 resolved as shift
WARNING: shift/reduce conflict for NOT in state 160 resolved as shift
WARNING: shift/reduce conflict for INC in state 160 resolved as shift
WARNING: shift/reduce conflict for DEC in state 160 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 160 resolved as shift
WARNING: shift/reduce conflict for FLOAT_LITERAL in state 160 resolved as shift
WARNING: shift/reduce conflict for CHAR_LITERAL in state 160 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 160 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 160 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 165 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 169 resolved as shift
WARNING: shift/reduce conflict for IF in state 169 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 169 resolved as shift
WARNING: shift/reduce conflict for FOR in state 169 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 169 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 169 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 169 resolved as shift
WARNING: shift/reduce conflict for INT in state 169 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 169 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 169 resolved as shift
WARNING: shift/reduce conflict for VOID in state 169 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 169 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 169 resolved as shift
WARNING: shift/reduce conflict for NOT in state 169 resolved as shift
WARNING: shift/reduce conflict for INC in state 169 resolved as shift
WARNING: shift/reduce conflict for DEC in state 169 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 169 resolved as shift
WARNING: shift/reduce conflict for FLOAT_LITERAL in state 169 resolved as shift
WARNING: shift/reduce conflict for CHAR_LITERAL in state 169 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 169 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 169 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 170 resolved as shift
WARNING: shift/reduce conflict for IF in state 170 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 170 resolved as shift
WARNING: shift/reduce conflict for FOR in state 170 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 170 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 170 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 170 resolved as shift
WARNING: shift/reduce conflict for INT in state 170 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 170 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 170 resolved as shift
WARNING: shift/reduce conflict for VOID in state 170 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 170 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 170 resolved as shift
WARNING: shift/reduce conflict for NOT in state 170 resolved as shift
WARNING: shift/reduce conflict for INC in state 170 resolved as shift
WARNING: shift/reduce conflict for DEC in state 170 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 170 resolved as shift
WARNING: shift/reduce conflict for FLOAT_LITERAL in state 170 resolved as shift
WARNING: shift/reduce conflict for CHAR_LITERAL in state 170 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 170 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 170 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 171 resolved as shift
WARNING: shift/reduce conflict for IF in state 171 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 171 resolved as shift
WARNING: shift/reduce conflict for FOR in state 171 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 171 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 171 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 171 resolved as shift
WARNING: shift/reduce conflict for INT in state 171 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 171 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 171 resolved as shift
WARNING: shift/reduce conflict for VOID in state 171 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 171 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 171 resolved as shift
WARNING: shift/reduce conflict for NOT in state 171 resolved as shift
WARNING: shift/reduce conflict for INC in state 171 resolved as shift
WARNING: shift/reduce conflict for DEC in state 171 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 171 resolved as shift
WARNING: shift/reduce conflict for FLOAT_LITERAL in state 171 resolved as shift
WARNING: shift/reduce conflict for CHAR_LITERAL in state 171 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 171 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 171 resolved as shift
