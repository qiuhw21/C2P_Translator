Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT_MULTI
    COMMENT_SINGLE

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration_list
Rule 2     declaration_list -> declaration_list declaration
Rule 3     declaration_list -> declaration
Rule 4     declaration -> var_declaration
Rule 5     declaration -> function_declaration
Rule 6     declaration -> function_definition
Rule 7     declaration -> array_declaration
Rule 8     var_declaration -> var_direct_declaration
Rule 9     var_declaration -> var_pointer_declaration
Rule 10    var_declaration -> var_declaration_init
Rule 11    var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON
Rule 12    var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON
Rule 13    var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON
Rule 14    array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
Rule 15    array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
Rule 16    array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
Rule 17    array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
Rule 18    array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
Rule 19    type_specifier -> INT
Rule 20    type_specifier -> FLOAT
Rule 21    type_specifier -> CHAR
Rule 22    type_specifier -> VOID
Rule 23    array_list -> array_list COMMA expression
Rule 24    array_list -> expression
Rule 25    function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN SEMICOLON
Rule 26    function_definition -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement
Rule 27    param_list -> param_list COMMA param
Rule 28    param_list -> param
Rule 29    param_list -> empty
Rule 30    param -> type_specifier IDENTIFIER
Rule 31    param -> type_specifier IDENTIFIER LBRACKET RBRACKET
Rule 32    param -> type_specifier TIMES IDENTIFIER
Rule 33    empty -> <empty>
Rule 34    compound_statement -> LBRACE statement_list RBRACE
Rule 35    statement_list -> statement_list statement
Rule 36    statement_list -> statement
Rule 37    statement -> expression_statement
Rule 38    statement -> compound_statement
Rule 39    statement -> selection_statement
Rule 40    statement -> iteration_statement
Rule 41    statement -> return_statement
Rule 42    statement -> continue_statement
Rule 43    statement -> break_statement
Rule 44    statement -> var_declaration
Rule 45    statement -> array_declaration
Rule 46    statement -> empty
Rule 47    expression_statement -> expression SEMICOLON
Rule 48    expression -> assignment_expression
Rule 49    expression -> binary_expression
Rule 50    expression -> unary_expression
Rule 51    expression -> function_call
Rule 52    expression -> array_access
Rule 53    expression -> term
Rule 54    assignment_expression -> IDENTIFIER ASSIGN expression
Rule 55    assignment_expression -> array_access ASSIGN expression
Rule 56    binary_expression -> expression PLUS expression
Rule 57    binary_expression -> expression MINUS expression
Rule 58    binary_expression -> expression TIMES expression
Rule 59    binary_expression -> expression DIVIDE expression
Rule 60    binary_expression -> expression MOD expression
Rule 61    binary_expression -> expression EQ expression
Rule 62    binary_expression -> expression NEQ expression
Rule 63    binary_expression -> expression LT expression
Rule 64    binary_expression -> expression GT expression
Rule 65    binary_expression -> expression LTE expression
Rule 66    binary_expression -> expression GTE expression
Rule 67    binary_expression -> expression AND expression
Rule 68    binary_expression -> expression OR expression
Rule 69    unary_expression -> MINUS expression
Rule 70    unary_expression -> NOT expression
Rule 71    unary_expression -> INC IDENTIFIER
Rule 72    unary_expression -> DEC IDENTIFIER
Rule 73    unary_expression -> IDENTIFIER INC
Rule 74    unary_expression -> IDENTIFIER DEC
Rule 75    term -> IDENTIFIER
Rule 76    term -> INT_LITERAL
Rule 77    term -> FLOAT_LITERAL
Rule 78    term -> CHAR_LITERAL
Rule 79    term -> STRING_LITERAL
Rule 80    term -> LPAREN expression RPAREN
Rule 81    function_call -> IDENTIFIER LPAREN argument_list RPAREN
Rule 82    array_access -> IDENTIFIER LBRACKET expression RBRACKET
Rule 83    argument_list -> argument_list COMMA expression
Rule 84    argument_list -> expression
Rule 85    argument_list -> empty
Rule 86    selection_statement -> IF LPAREN expression RPAREN statement
Rule 87    selection_statement -> IF LPAREN expression RPAREN statement ELSE statement
Rule 88    iteration_statement -> WHILE LPAREN expression RPAREN statement
Rule 89    iteration_statement -> for_expression_statement
Rule 90    iteration_statement -> for_var_declaration
Rule 91    for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement
Rule 92    for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement
Rule 93    return_statement -> RETURN expression SEMICOLON
Rule 94    continue_statement -> CONTINUE SEMICOLON
Rule 95    break_statement -> BREAK SEMICOLON

Terminals, with rules where they appear

AND                  : 67
ASSIGN               : 13 15 16 17 18 54 55
BREAK                : 95
CHAR                 : 21
CHAR_LITERAL         : 78
COMMA                : 23 27 83
COMMENT_MULTI        : 
COMMENT_SINGLE       : 
CONTINUE             : 94
DEC                  : 72 74
DIVIDE               : 59
ELSE                 : 87
EQ                   : 61
FLOAT                : 20
FLOAT_LITERAL        : 77
FOR                  : 91 92
GT                   : 64
GTE                  : 66
IDENTIFIER           : 11 12 13 14 15 16 17 18 25 26 30 31 32 54 71 72 73 74 75 81 82
IF                   : 86 87
INC                  : 71 73
INT                  : 19
INT_LITERAL          : 76
LBRACE               : 15 16 34
LBRACKET             : 14 15 16 17 18 31 82
LPAREN               : 25 26 80 81 86 87 88 91 92
LT                   : 63
LTE                  : 65
MINUS                : 57 69
MOD                  : 60
NEQ                  : 62
NOT                  : 70
OR                   : 68
PLUS                 : 56
RBRACE               : 15 16 34
RBRACKET             : 14 15 16 17 18 31 82
RETURN               : 93
RPAREN               : 25 26 80 81 86 87 88 91 92
SEMICOLON            : 11 12 13 14 15 16 17 18 25 47 93 94 95
STRING_LITERAL       : 17 18 79
TIMES                : 12 32 58
VOID                 : 22
WHILE                : 88
error                : 

Nonterminals, with rules where they appear

argument_list        : 81 83
array_access         : 52 55
array_declaration    : 7 45
array_list           : 15 16 23
assignment_expression : 48
binary_expression    : 49
break_statement      : 43
compound_statement   : 26 38
continue_statement   : 42
declaration          : 2 3
declaration_list     : 1 2
empty                : 29 46 85
expression           : 13 14 15 17 23 24 47 54 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 70 80 82 83 84 86 87 88 91 92 93
expression_statement : 37 91 91 92
for_expression_statement : 89
for_var_declaration  : 90
function_call        : 51
function_declaration : 5
function_definition  : 6
iteration_statement  : 40
param                : 27 28
param_list           : 25 26 27
program              : 0
return_statement     : 41
selection_statement  : 39
statement            : 35 36 86 87 87 88 91 92
statement_list       : 34 35
term                 : 53
type_specifier       : 11 12 13 14 15 16 17 18 25 26 30 31 32
unary_expression     : 50
var_declaration      : 4 44 92
var_declaration_init : 10
var_direct_declaration : 8
var_pointer_declaration : 9

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration_list
    (2) declaration_list -> . declaration_list declaration
    (3) declaration_list -> . declaration
    (4) declaration -> . var_declaration
    (5) declaration -> . function_declaration
    (6) declaration -> . function_definition
    (7) declaration -> . array_declaration
    (8) var_declaration -> . var_direct_declaration
    (9) var_declaration -> . var_pointer_declaration
    (10) var_declaration -> . var_declaration_init
    (25) function_declaration -> . type_specifier IDENTIFIER LPAREN param_list RPAREN SEMICOLON
    (26) function_definition -> . type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement
    (14) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (15) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (16) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (17) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (18) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (11) var_direct_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (12) var_pointer_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (13) var_declaration_init -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (19) type_specifier -> . INT
    (20) type_specifier -> . FLOAT
    (21) type_specifier -> . CHAR
    (22) type_specifier -> . VOID

    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    CHAR            shift and go to state 14
    VOID            shift and go to state 15

    program                        shift and go to state 1
    declaration_list               shift and go to state 2
    declaration                    shift and go to state 3
    var_declaration                shift and go to state 4
    function_declaration           shift and go to state 5
    function_definition            shift and go to state 6
    array_declaration              shift and go to state 7
    var_direct_declaration         shift and go to state 8
    var_pointer_declaration        shift and go to state 9
    var_declaration_init           shift and go to state 10
    type_specifier                 shift and go to state 11

state 1

    (0) S' -> program .



state 2

    (1) program -> declaration_list .
    (2) declaration_list -> declaration_list . declaration
    (4) declaration -> . var_declaration
    (5) declaration -> . function_declaration
    (6) declaration -> . function_definition
    (7) declaration -> . array_declaration
    (8) var_declaration -> . var_direct_declaration
    (9) var_declaration -> . var_pointer_declaration
    (10) var_declaration -> . var_declaration_init
    (25) function_declaration -> . type_specifier IDENTIFIER LPAREN param_list RPAREN SEMICOLON
    (26) function_definition -> . type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement
    (14) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (15) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (16) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (17) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (18) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (11) var_direct_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (12) var_pointer_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (13) var_declaration_init -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (19) type_specifier -> . INT
    (20) type_specifier -> . FLOAT
    (21) type_specifier -> . CHAR
    (22) type_specifier -> . VOID

    $end            reduce using rule 1 (program -> declaration_list .)
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    CHAR            shift and go to state 14
    VOID            shift and go to state 15

    declaration                    shift and go to state 16
    var_declaration                shift and go to state 4
    function_declaration           shift and go to state 5
    function_definition            shift and go to state 6
    array_declaration              shift and go to state 7
    var_direct_declaration         shift and go to state 8
    var_pointer_declaration        shift and go to state 9
    var_declaration_init           shift and go to state 10
    type_specifier                 shift and go to state 11

state 3

    (3) declaration_list -> declaration .

    INT             reduce using rule 3 (declaration_list -> declaration .)
    FLOAT           reduce using rule 3 (declaration_list -> declaration .)
    CHAR            reduce using rule 3 (declaration_list -> declaration .)
    VOID            reduce using rule 3 (declaration_list -> declaration .)
    $end            reduce using rule 3 (declaration_list -> declaration .)


state 4

    (4) declaration -> var_declaration .

    INT             reduce using rule 4 (declaration -> var_declaration .)
    FLOAT           reduce using rule 4 (declaration -> var_declaration .)
    CHAR            reduce using rule 4 (declaration -> var_declaration .)
    VOID            reduce using rule 4 (declaration -> var_declaration .)
    $end            reduce using rule 4 (declaration -> var_declaration .)


state 5

    (5) declaration -> function_declaration .

    INT             reduce using rule 5 (declaration -> function_declaration .)
    FLOAT           reduce using rule 5 (declaration -> function_declaration .)
    CHAR            reduce using rule 5 (declaration -> function_declaration .)
    VOID            reduce using rule 5 (declaration -> function_declaration .)
    $end            reduce using rule 5 (declaration -> function_declaration .)


state 6

    (6) declaration -> function_definition .

    INT             reduce using rule 6 (declaration -> function_definition .)
    FLOAT           reduce using rule 6 (declaration -> function_definition .)
    CHAR            reduce using rule 6 (declaration -> function_definition .)
    VOID            reduce using rule 6 (declaration -> function_definition .)
    $end            reduce using rule 6 (declaration -> function_definition .)


state 7

    (7) declaration -> array_declaration .

    INT             reduce using rule 7 (declaration -> array_declaration .)
    FLOAT           reduce using rule 7 (declaration -> array_declaration .)
    CHAR            reduce using rule 7 (declaration -> array_declaration .)
    VOID            reduce using rule 7 (declaration -> array_declaration .)
    $end            reduce using rule 7 (declaration -> array_declaration .)


state 8

    (8) var_declaration -> var_direct_declaration .

    INT             reduce using rule 8 (var_declaration -> var_direct_declaration .)
    FLOAT           reduce using rule 8 (var_declaration -> var_direct_declaration .)
    CHAR            reduce using rule 8 (var_declaration -> var_direct_declaration .)
    VOID            reduce using rule 8 (var_declaration -> var_direct_declaration .)
    $end            reduce using rule 8 (var_declaration -> var_direct_declaration .)
    RBRACE          reduce using rule 8 (var_declaration -> var_direct_declaration .)
    LBRACE          reduce using rule 8 (var_declaration -> var_direct_declaration .)
    IF              reduce using rule 8 (var_declaration -> var_direct_declaration .)
    WHILE           reduce using rule 8 (var_declaration -> var_direct_declaration .)
    RETURN          reduce using rule 8 (var_declaration -> var_direct_declaration .)
    CONTINUE        reduce using rule 8 (var_declaration -> var_direct_declaration .)
    BREAK           reduce using rule 8 (var_declaration -> var_direct_declaration .)
    FOR             reduce using rule 8 (var_declaration -> var_direct_declaration .)
    IDENTIFIER      reduce using rule 8 (var_declaration -> var_direct_declaration .)
    MINUS           reduce using rule 8 (var_declaration -> var_direct_declaration .)
    NOT             reduce using rule 8 (var_declaration -> var_direct_declaration .)
    INC             reduce using rule 8 (var_declaration -> var_direct_declaration .)
    DEC             reduce using rule 8 (var_declaration -> var_direct_declaration .)
    INT_LITERAL     reduce using rule 8 (var_declaration -> var_direct_declaration .)
    FLOAT_LITERAL   reduce using rule 8 (var_declaration -> var_direct_declaration .)
    CHAR_LITERAL    reduce using rule 8 (var_declaration -> var_direct_declaration .)
    STRING_LITERAL  reduce using rule 8 (var_declaration -> var_direct_declaration .)
    LPAREN          reduce using rule 8 (var_declaration -> var_direct_declaration .)
    ELSE            reduce using rule 8 (var_declaration -> var_direct_declaration .)


state 9

    (9) var_declaration -> var_pointer_declaration .

    INT             reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    FLOAT           reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    CHAR            reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    VOID            reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    $end            reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    RBRACE          reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    LBRACE          reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    IF              reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    WHILE           reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    RETURN          reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    CONTINUE        reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    BREAK           reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    FOR             reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    IDENTIFIER      reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    MINUS           reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    NOT             reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    INC             reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    DEC             reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    INT_LITERAL     reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    FLOAT_LITERAL   reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    CHAR_LITERAL    reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    STRING_LITERAL  reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    LPAREN          reduce using rule 9 (var_declaration -> var_pointer_declaration .)
    ELSE            reduce using rule 9 (var_declaration -> var_pointer_declaration .)


state 10

    (10) var_declaration -> var_declaration_init .

    INT             reduce using rule 10 (var_declaration -> var_declaration_init .)
    FLOAT           reduce using rule 10 (var_declaration -> var_declaration_init .)
    CHAR            reduce using rule 10 (var_declaration -> var_declaration_init .)
    VOID            reduce using rule 10 (var_declaration -> var_declaration_init .)
    $end            reduce using rule 10 (var_declaration -> var_declaration_init .)
    RBRACE          reduce using rule 10 (var_declaration -> var_declaration_init .)
    LBRACE          reduce using rule 10 (var_declaration -> var_declaration_init .)
    IF              reduce using rule 10 (var_declaration -> var_declaration_init .)
    WHILE           reduce using rule 10 (var_declaration -> var_declaration_init .)
    RETURN          reduce using rule 10 (var_declaration -> var_declaration_init .)
    CONTINUE        reduce using rule 10 (var_declaration -> var_declaration_init .)
    BREAK           reduce using rule 10 (var_declaration -> var_declaration_init .)
    FOR             reduce using rule 10 (var_declaration -> var_declaration_init .)
    IDENTIFIER      reduce using rule 10 (var_declaration -> var_declaration_init .)
    MINUS           reduce using rule 10 (var_declaration -> var_declaration_init .)
    NOT             reduce using rule 10 (var_declaration -> var_declaration_init .)
    INC             reduce using rule 10 (var_declaration -> var_declaration_init .)
    DEC             reduce using rule 10 (var_declaration -> var_declaration_init .)
    INT_LITERAL     reduce using rule 10 (var_declaration -> var_declaration_init .)
    FLOAT_LITERAL   reduce using rule 10 (var_declaration -> var_declaration_init .)
    CHAR_LITERAL    reduce using rule 10 (var_declaration -> var_declaration_init .)
    STRING_LITERAL  reduce using rule 10 (var_declaration -> var_declaration_init .)
    LPAREN          reduce using rule 10 (var_declaration -> var_declaration_init .)
    ELSE            reduce using rule 10 (var_declaration -> var_declaration_init .)


state 11

    (25) function_declaration -> type_specifier . IDENTIFIER LPAREN param_list RPAREN SEMICOLON
    (26) function_definition -> type_specifier . IDENTIFIER LPAREN param_list RPAREN compound_statement
    (14) array_declaration -> type_specifier . IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (15) array_declaration -> type_specifier . IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (16) array_declaration -> type_specifier . IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (17) array_declaration -> type_specifier . IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (18) array_declaration -> type_specifier . IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (11) var_direct_declaration -> type_specifier . IDENTIFIER SEMICOLON
    (12) var_pointer_declaration -> type_specifier . TIMES IDENTIFIER SEMICOLON
    (13) var_declaration_init -> type_specifier . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 17
    TIMES           shift and go to state 18


state 12

    (19) type_specifier -> INT .

    IDENTIFIER      reduce using rule 19 (type_specifier -> INT .)
    TIMES           reduce using rule 19 (type_specifier -> INT .)


state 13

    (20) type_specifier -> FLOAT .

    IDENTIFIER      reduce using rule 20 (type_specifier -> FLOAT .)
    TIMES           reduce using rule 20 (type_specifier -> FLOAT .)


state 14

    (21) type_specifier -> CHAR .

    IDENTIFIER      reduce using rule 21 (type_specifier -> CHAR .)
    TIMES           reduce using rule 21 (type_specifier -> CHAR .)


state 15

    (22) type_specifier -> VOID .

    IDENTIFIER      reduce using rule 22 (type_specifier -> VOID .)
    TIMES           reduce using rule 22 (type_specifier -> VOID .)


state 16

    (2) declaration_list -> declaration_list declaration .

    INT             reduce using rule 2 (declaration_list -> declaration_list declaration .)
    FLOAT           reduce using rule 2 (declaration_list -> declaration_list declaration .)
    CHAR            reduce using rule 2 (declaration_list -> declaration_list declaration .)
    VOID            reduce using rule 2 (declaration_list -> declaration_list declaration .)
    $end            reduce using rule 2 (declaration_list -> declaration_list declaration .)


state 17

    (25) function_declaration -> type_specifier IDENTIFIER . LPAREN param_list RPAREN SEMICOLON
    (26) function_definition -> type_specifier IDENTIFIER . LPAREN param_list RPAREN compound_statement
    (14) array_declaration -> type_specifier IDENTIFIER . LBRACKET expression RBRACKET SEMICOLON
    (15) array_declaration -> type_specifier IDENTIFIER . LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (16) array_declaration -> type_specifier IDENTIFIER . LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (17) array_declaration -> type_specifier IDENTIFIER . LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (18) array_declaration -> type_specifier IDENTIFIER . LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (11) var_direct_declaration -> type_specifier IDENTIFIER . SEMICOLON
    (13) var_declaration_init -> type_specifier IDENTIFIER . ASSIGN expression SEMICOLON

    LPAREN          shift and go to state 19
    LBRACKET        shift and go to state 21
    SEMICOLON       shift and go to state 20
    ASSIGN          shift and go to state 22


state 18

    (12) var_pointer_declaration -> type_specifier TIMES . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 23


state 19

    (25) function_declaration -> type_specifier IDENTIFIER LPAREN . param_list RPAREN SEMICOLON
    (26) function_definition -> type_specifier IDENTIFIER LPAREN . param_list RPAREN compound_statement
    (27) param_list -> . param_list COMMA param
    (28) param_list -> . param
    (29) param_list -> . empty
    (30) param -> . type_specifier IDENTIFIER
    (31) param -> . type_specifier IDENTIFIER LBRACKET RBRACKET
    (32) param -> . type_specifier TIMES IDENTIFIER
    (33) empty -> .
    (19) type_specifier -> . INT
    (20) type_specifier -> . FLOAT
    (21) type_specifier -> . CHAR
    (22) type_specifier -> . VOID

    RPAREN          reduce using rule 33 (empty -> .)
    COMMA           reduce using rule 33 (empty -> .)
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    CHAR            shift and go to state 14
    VOID            shift and go to state 15

    type_specifier                 shift and go to state 24
    param_list                     shift and go to state 25
    param                          shift and go to state 26
    empty                          shift and go to state 27

state 20

    (11) var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .

    INT             reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    CHAR            reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    $end            reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    RBRACE          reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    LBRACE          reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    IF              reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    RETURN          reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    CONTINUE        reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    BREAK           reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    INC             reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    DEC             reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    INT_LITERAL     reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    CHAR_LITERAL    reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    STRING_LITERAL  reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    LPAREN          reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    ELSE            reduce using rule 11 (var_direct_declaration -> type_specifier IDENTIFIER SEMICOLON .)


state 21

    (14) array_declaration -> type_specifier IDENTIFIER LBRACKET . expression RBRACKET SEMICOLON
    (15) array_declaration -> type_specifier IDENTIFIER LBRACKET . expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (16) array_declaration -> type_specifier IDENTIFIER LBRACKET . RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (17) array_declaration -> type_specifier IDENTIFIER LBRACKET . expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (18) array_declaration -> type_specifier IDENTIFIER LBRACKET . RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    RBRACKET        shift and go to state 30
    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 29
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 22

    (13) var_declaration_init -> type_specifier IDENTIFIER ASSIGN . expression SEMICOLON
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 46
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 23

    (12) var_pointer_declaration -> type_specifier TIMES IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 47


state 24

    (30) param -> type_specifier . IDENTIFIER
    (31) param -> type_specifier . IDENTIFIER LBRACKET RBRACKET
    (32) param -> type_specifier . TIMES IDENTIFIER

    IDENTIFIER      shift and go to state 48
    TIMES           shift and go to state 49


state 25

    (25) function_declaration -> type_specifier IDENTIFIER LPAREN param_list . RPAREN SEMICOLON
    (26) function_definition -> type_specifier IDENTIFIER LPAREN param_list . RPAREN compound_statement
    (27) param_list -> param_list . COMMA param

    RPAREN          shift and go to state 50
    COMMA           shift and go to state 51


state 26

    (28) param_list -> param .

    RPAREN          reduce using rule 28 (param_list -> param .)
    COMMA           reduce using rule 28 (param_list -> param .)


state 27

    (29) param_list -> empty .

    RPAREN          reduce using rule 29 (param_list -> empty .)
    COMMA           reduce using rule 29 (param_list -> empty .)


state 28

    (54) assignment_expression -> IDENTIFIER . ASSIGN expression
    (73) unary_expression -> IDENTIFIER . INC
    (74) unary_expression -> IDENTIFIER . DEC
    (81) function_call -> IDENTIFIER . LPAREN argument_list RPAREN
    (82) array_access -> IDENTIFIER . LBRACKET expression RBRACKET
    (75) term -> IDENTIFIER .

    ASSIGN          shift and go to state 52
    INC             shift and go to state 53
    DEC             shift and go to state 54
    LPAREN          shift and go to state 55
    LBRACKET        shift and go to state 56
    RBRACKET        reduce using rule 75 (term -> IDENTIFIER .)
    PLUS            reduce using rule 75 (term -> IDENTIFIER .)
    MINUS           reduce using rule 75 (term -> IDENTIFIER .)
    TIMES           reduce using rule 75 (term -> IDENTIFIER .)
    DIVIDE          reduce using rule 75 (term -> IDENTIFIER .)
    MOD             reduce using rule 75 (term -> IDENTIFIER .)
    EQ              reduce using rule 75 (term -> IDENTIFIER .)
    NEQ             reduce using rule 75 (term -> IDENTIFIER .)
    LT              reduce using rule 75 (term -> IDENTIFIER .)
    GT              reduce using rule 75 (term -> IDENTIFIER .)
    LTE             reduce using rule 75 (term -> IDENTIFIER .)
    GTE             reduce using rule 75 (term -> IDENTIFIER .)
    AND             reduce using rule 75 (term -> IDENTIFIER .)
    OR              reduce using rule 75 (term -> IDENTIFIER .)
    SEMICOLON       reduce using rule 75 (term -> IDENTIFIER .)
    RPAREN          reduce using rule 75 (term -> IDENTIFIER .)
    COMMA           reduce using rule 75 (term -> IDENTIFIER .)
    RBRACE          reduce using rule 75 (term -> IDENTIFIER .)


state 29

    (14) array_declaration -> type_specifier IDENTIFIER LBRACKET expression . RBRACKET SEMICOLON
    (15) array_declaration -> type_specifier IDENTIFIER LBRACKET expression . RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (17) array_declaration -> type_specifier IDENTIFIER LBRACKET expression . RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACKET        shift and go to state 57
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 30

    (16) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET . ASSIGN LBRACE array_list RBRACE SEMICOLON
    (18) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET . ASSIGN STRING_LITERAL SEMICOLON

    ASSIGN          shift and go to state 71


state 31

    (79) term -> STRING_LITERAL .

    RBRACKET        reduce using rule 79 (term -> STRING_LITERAL .)
    PLUS            reduce using rule 79 (term -> STRING_LITERAL .)
    MINUS           reduce using rule 79 (term -> STRING_LITERAL .)
    TIMES           reduce using rule 79 (term -> STRING_LITERAL .)
    DIVIDE          reduce using rule 79 (term -> STRING_LITERAL .)
    MOD             reduce using rule 79 (term -> STRING_LITERAL .)
    EQ              reduce using rule 79 (term -> STRING_LITERAL .)
    NEQ             reduce using rule 79 (term -> STRING_LITERAL .)
    LT              reduce using rule 79 (term -> STRING_LITERAL .)
    GT              reduce using rule 79 (term -> STRING_LITERAL .)
    LTE             reduce using rule 79 (term -> STRING_LITERAL .)
    GTE             reduce using rule 79 (term -> STRING_LITERAL .)
    AND             reduce using rule 79 (term -> STRING_LITERAL .)
    OR              reduce using rule 79 (term -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 79 (term -> STRING_LITERAL .)
    RPAREN          reduce using rule 79 (term -> STRING_LITERAL .)
    COMMA           reduce using rule 79 (term -> STRING_LITERAL .)
    RBRACE          reduce using rule 79 (term -> STRING_LITERAL .)


state 32

    (48) expression -> assignment_expression .

    RBRACKET        reduce using rule 48 (expression -> assignment_expression .)
    PLUS            reduce using rule 48 (expression -> assignment_expression .)
    MINUS           reduce using rule 48 (expression -> assignment_expression .)
    TIMES           reduce using rule 48 (expression -> assignment_expression .)
    DIVIDE          reduce using rule 48 (expression -> assignment_expression .)
    MOD             reduce using rule 48 (expression -> assignment_expression .)
    EQ              reduce using rule 48 (expression -> assignment_expression .)
    NEQ             reduce using rule 48 (expression -> assignment_expression .)
    LT              reduce using rule 48 (expression -> assignment_expression .)
    GT              reduce using rule 48 (expression -> assignment_expression .)
    LTE             reduce using rule 48 (expression -> assignment_expression .)
    GTE             reduce using rule 48 (expression -> assignment_expression .)
    AND             reduce using rule 48 (expression -> assignment_expression .)
    OR              reduce using rule 48 (expression -> assignment_expression .)
    SEMICOLON       reduce using rule 48 (expression -> assignment_expression .)
    RPAREN          reduce using rule 48 (expression -> assignment_expression .)
    COMMA           reduce using rule 48 (expression -> assignment_expression .)
    RBRACE          reduce using rule 48 (expression -> assignment_expression .)


state 33

    (49) expression -> binary_expression .

    RBRACKET        reduce using rule 49 (expression -> binary_expression .)
    PLUS            reduce using rule 49 (expression -> binary_expression .)
    MINUS           reduce using rule 49 (expression -> binary_expression .)
    TIMES           reduce using rule 49 (expression -> binary_expression .)
    DIVIDE          reduce using rule 49 (expression -> binary_expression .)
    MOD             reduce using rule 49 (expression -> binary_expression .)
    EQ              reduce using rule 49 (expression -> binary_expression .)
    NEQ             reduce using rule 49 (expression -> binary_expression .)
    LT              reduce using rule 49 (expression -> binary_expression .)
    GT              reduce using rule 49 (expression -> binary_expression .)
    LTE             reduce using rule 49 (expression -> binary_expression .)
    GTE             reduce using rule 49 (expression -> binary_expression .)
    AND             reduce using rule 49 (expression -> binary_expression .)
    OR              reduce using rule 49 (expression -> binary_expression .)
    SEMICOLON       reduce using rule 49 (expression -> binary_expression .)
    RPAREN          reduce using rule 49 (expression -> binary_expression .)
    COMMA           reduce using rule 49 (expression -> binary_expression .)
    RBRACE          reduce using rule 49 (expression -> binary_expression .)


state 34

    (50) expression -> unary_expression .

    RBRACKET        reduce using rule 50 (expression -> unary_expression .)
    PLUS            reduce using rule 50 (expression -> unary_expression .)
    MINUS           reduce using rule 50 (expression -> unary_expression .)
    TIMES           reduce using rule 50 (expression -> unary_expression .)
    DIVIDE          reduce using rule 50 (expression -> unary_expression .)
    MOD             reduce using rule 50 (expression -> unary_expression .)
    EQ              reduce using rule 50 (expression -> unary_expression .)
    NEQ             reduce using rule 50 (expression -> unary_expression .)
    LT              reduce using rule 50 (expression -> unary_expression .)
    GT              reduce using rule 50 (expression -> unary_expression .)
    LTE             reduce using rule 50 (expression -> unary_expression .)
    GTE             reduce using rule 50 (expression -> unary_expression .)
    AND             reduce using rule 50 (expression -> unary_expression .)
    OR              reduce using rule 50 (expression -> unary_expression .)
    SEMICOLON       reduce using rule 50 (expression -> unary_expression .)
    RPAREN          reduce using rule 50 (expression -> unary_expression .)
    COMMA           reduce using rule 50 (expression -> unary_expression .)
    RBRACE          reduce using rule 50 (expression -> unary_expression .)


state 35

    (51) expression -> function_call .

    RBRACKET        reduce using rule 51 (expression -> function_call .)
    PLUS            reduce using rule 51 (expression -> function_call .)
    MINUS           reduce using rule 51 (expression -> function_call .)
    TIMES           reduce using rule 51 (expression -> function_call .)
    DIVIDE          reduce using rule 51 (expression -> function_call .)
    MOD             reduce using rule 51 (expression -> function_call .)
    EQ              reduce using rule 51 (expression -> function_call .)
    NEQ             reduce using rule 51 (expression -> function_call .)
    LT              reduce using rule 51 (expression -> function_call .)
    GT              reduce using rule 51 (expression -> function_call .)
    LTE             reduce using rule 51 (expression -> function_call .)
    GTE             reduce using rule 51 (expression -> function_call .)
    AND             reduce using rule 51 (expression -> function_call .)
    OR              reduce using rule 51 (expression -> function_call .)
    SEMICOLON       reduce using rule 51 (expression -> function_call .)
    RPAREN          reduce using rule 51 (expression -> function_call .)
    COMMA           reduce using rule 51 (expression -> function_call .)
    RBRACE          reduce using rule 51 (expression -> function_call .)


state 36

    (52) expression -> array_access .
    (55) assignment_expression -> array_access . ASSIGN expression

    RBRACKET        reduce using rule 52 (expression -> array_access .)
    PLUS            reduce using rule 52 (expression -> array_access .)
    MINUS           reduce using rule 52 (expression -> array_access .)
    TIMES           reduce using rule 52 (expression -> array_access .)
    DIVIDE          reduce using rule 52 (expression -> array_access .)
    MOD             reduce using rule 52 (expression -> array_access .)
    EQ              reduce using rule 52 (expression -> array_access .)
    NEQ             reduce using rule 52 (expression -> array_access .)
    LT              reduce using rule 52 (expression -> array_access .)
    GT              reduce using rule 52 (expression -> array_access .)
    LTE             reduce using rule 52 (expression -> array_access .)
    GTE             reduce using rule 52 (expression -> array_access .)
    AND             reduce using rule 52 (expression -> array_access .)
    OR              reduce using rule 52 (expression -> array_access .)
    SEMICOLON       reduce using rule 52 (expression -> array_access .)
    RPAREN          reduce using rule 52 (expression -> array_access .)
    COMMA           reduce using rule 52 (expression -> array_access .)
    RBRACE          reduce using rule 52 (expression -> array_access .)
    ASSIGN          shift and go to state 72


state 37

    (53) expression -> term .

    RBRACKET        reduce using rule 53 (expression -> term .)
    PLUS            reduce using rule 53 (expression -> term .)
    MINUS           reduce using rule 53 (expression -> term .)
    TIMES           reduce using rule 53 (expression -> term .)
    DIVIDE          reduce using rule 53 (expression -> term .)
    MOD             reduce using rule 53 (expression -> term .)
    EQ              reduce using rule 53 (expression -> term .)
    NEQ             reduce using rule 53 (expression -> term .)
    LT              reduce using rule 53 (expression -> term .)
    GT              reduce using rule 53 (expression -> term .)
    LTE             reduce using rule 53 (expression -> term .)
    GTE             reduce using rule 53 (expression -> term .)
    AND             reduce using rule 53 (expression -> term .)
    OR              reduce using rule 53 (expression -> term .)
    SEMICOLON       reduce using rule 53 (expression -> term .)
    RPAREN          reduce using rule 53 (expression -> term .)
    COMMA           reduce using rule 53 (expression -> term .)
    RBRACE          reduce using rule 53 (expression -> term .)


state 38

    (69) unary_expression -> MINUS . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 73
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 39

    (70) unary_expression -> NOT . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 74
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 40

    (71) unary_expression -> INC . IDENTIFIER

    IDENTIFIER      shift and go to state 75


state 41

    (72) unary_expression -> DEC . IDENTIFIER

    IDENTIFIER      shift and go to state 76


state 42

    (80) term -> LPAREN . expression RPAREN
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 77
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 43

    (76) term -> INT_LITERAL .

    RBRACKET        reduce using rule 76 (term -> INT_LITERAL .)
    PLUS            reduce using rule 76 (term -> INT_LITERAL .)
    MINUS           reduce using rule 76 (term -> INT_LITERAL .)
    TIMES           reduce using rule 76 (term -> INT_LITERAL .)
    DIVIDE          reduce using rule 76 (term -> INT_LITERAL .)
    MOD             reduce using rule 76 (term -> INT_LITERAL .)
    EQ              reduce using rule 76 (term -> INT_LITERAL .)
    NEQ             reduce using rule 76 (term -> INT_LITERAL .)
    LT              reduce using rule 76 (term -> INT_LITERAL .)
    GT              reduce using rule 76 (term -> INT_LITERAL .)
    LTE             reduce using rule 76 (term -> INT_LITERAL .)
    GTE             reduce using rule 76 (term -> INT_LITERAL .)
    AND             reduce using rule 76 (term -> INT_LITERAL .)
    OR              reduce using rule 76 (term -> INT_LITERAL .)
    SEMICOLON       reduce using rule 76 (term -> INT_LITERAL .)
    RPAREN          reduce using rule 76 (term -> INT_LITERAL .)
    COMMA           reduce using rule 76 (term -> INT_LITERAL .)
    RBRACE          reduce using rule 76 (term -> INT_LITERAL .)


state 44

    (77) term -> FLOAT_LITERAL .

    RBRACKET        reduce using rule 77 (term -> FLOAT_LITERAL .)
    PLUS            reduce using rule 77 (term -> FLOAT_LITERAL .)
    MINUS           reduce using rule 77 (term -> FLOAT_LITERAL .)
    TIMES           reduce using rule 77 (term -> FLOAT_LITERAL .)
    DIVIDE          reduce using rule 77 (term -> FLOAT_LITERAL .)
    MOD             reduce using rule 77 (term -> FLOAT_LITERAL .)
    EQ              reduce using rule 77 (term -> FLOAT_LITERAL .)
    NEQ             reduce using rule 77 (term -> FLOAT_LITERAL .)
    LT              reduce using rule 77 (term -> FLOAT_LITERAL .)
    GT              reduce using rule 77 (term -> FLOAT_LITERAL .)
    LTE             reduce using rule 77 (term -> FLOAT_LITERAL .)
    GTE             reduce using rule 77 (term -> FLOAT_LITERAL .)
    AND             reduce using rule 77 (term -> FLOAT_LITERAL .)
    OR              reduce using rule 77 (term -> FLOAT_LITERAL .)
    SEMICOLON       reduce using rule 77 (term -> FLOAT_LITERAL .)
    RPAREN          reduce using rule 77 (term -> FLOAT_LITERAL .)
    COMMA           reduce using rule 77 (term -> FLOAT_LITERAL .)
    RBRACE          reduce using rule 77 (term -> FLOAT_LITERAL .)


state 45

    (78) term -> CHAR_LITERAL .

    RBRACKET        reduce using rule 78 (term -> CHAR_LITERAL .)
    PLUS            reduce using rule 78 (term -> CHAR_LITERAL .)
    MINUS           reduce using rule 78 (term -> CHAR_LITERAL .)
    TIMES           reduce using rule 78 (term -> CHAR_LITERAL .)
    DIVIDE          reduce using rule 78 (term -> CHAR_LITERAL .)
    MOD             reduce using rule 78 (term -> CHAR_LITERAL .)
    EQ              reduce using rule 78 (term -> CHAR_LITERAL .)
    NEQ             reduce using rule 78 (term -> CHAR_LITERAL .)
    LT              reduce using rule 78 (term -> CHAR_LITERAL .)
    GT              reduce using rule 78 (term -> CHAR_LITERAL .)
    LTE             reduce using rule 78 (term -> CHAR_LITERAL .)
    GTE             reduce using rule 78 (term -> CHAR_LITERAL .)
    AND             reduce using rule 78 (term -> CHAR_LITERAL .)
    OR              reduce using rule 78 (term -> CHAR_LITERAL .)
    SEMICOLON       reduce using rule 78 (term -> CHAR_LITERAL .)
    RPAREN          reduce using rule 78 (term -> CHAR_LITERAL .)
    COMMA           reduce using rule 78 (term -> CHAR_LITERAL .)
    RBRACE          reduce using rule 78 (term -> CHAR_LITERAL .)


state 46

    (13) var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression . SEMICOLON
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    SEMICOLON       shift and go to state 78
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 47

    (12) var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .

    INT             reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    CHAR            reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    $end            reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    RBRACE          reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    LBRACE          reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    IF              reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    RETURN          reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    CONTINUE        reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    BREAK           reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    INC             reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    DEC             reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    INT_LITERAL     reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    CHAR_LITERAL    reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    STRING_LITERAL  reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    LPAREN          reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)
    ELSE            reduce using rule 12 (var_pointer_declaration -> type_specifier TIMES IDENTIFIER SEMICOLON .)


state 48

    (30) param -> type_specifier IDENTIFIER .
    (31) param -> type_specifier IDENTIFIER . LBRACKET RBRACKET

    RPAREN          reduce using rule 30 (param -> type_specifier IDENTIFIER .)
    COMMA           reduce using rule 30 (param -> type_specifier IDENTIFIER .)
    LBRACKET        shift and go to state 79


state 49

    (32) param -> type_specifier TIMES . IDENTIFIER

    IDENTIFIER      shift and go to state 80


state 50

    (25) function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN . SEMICOLON
    (26) function_definition -> type_specifier IDENTIFIER LPAREN param_list RPAREN . compound_statement
    (34) compound_statement -> . LBRACE statement_list RBRACE

    SEMICOLON       shift and go to state 81
    LBRACE          shift and go to state 83

    compound_statement             shift and go to state 82

state 51

    (27) param_list -> param_list COMMA . param
    (30) param -> . type_specifier IDENTIFIER
    (31) param -> . type_specifier IDENTIFIER LBRACKET RBRACKET
    (32) param -> . type_specifier TIMES IDENTIFIER
    (19) type_specifier -> . INT
    (20) type_specifier -> . FLOAT
    (21) type_specifier -> . CHAR
    (22) type_specifier -> . VOID

    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    CHAR            shift and go to state 14
    VOID            shift and go to state 15

    param                          shift and go to state 84
    type_specifier                 shift and go to state 24

state 52

    (54) assignment_expression -> IDENTIFIER ASSIGN . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 85
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 53

    (73) unary_expression -> IDENTIFIER INC .

    RBRACKET        reduce using rule 73 (unary_expression -> IDENTIFIER INC .)
    PLUS            reduce using rule 73 (unary_expression -> IDENTIFIER INC .)
    MINUS           reduce using rule 73 (unary_expression -> IDENTIFIER INC .)
    TIMES           reduce using rule 73 (unary_expression -> IDENTIFIER INC .)
    DIVIDE          reduce using rule 73 (unary_expression -> IDENTIFIER INC .)
    MOD             reduce using rule 73 (unary_expression -> IDENTIFIER INC .)
    EQ              reduce using rule 73 (unary_expression -> IDENTIFIER INC .)
    NEQ             reduce using rule 73 (unary_expression -> IDENTIFIER INC .)
    LT              reduce using rule 73 (unary_expression -> IDENTIFIER INC .)
    GT              reduce using rule 73 (unary_expression -> IDENTIFIER INC .)
    LTE             reduce using rule 73 (unary_expression -> IDENTIFIER INC .)
    GTE             reduce using rule 73 (unary_expression -> IDENTIFIER INC .)
    AND             reduce using rule 73 (unary_expression -> IDENTIFIER INC .)
    OR              reduce using rule 73 (unary_expression -> IDENTIFIER INC .)
    SEMICOLON       reduce using rule 73 (unary_expression -> IDENTIFIER INC .)
    RPAREN          reduce using rule 73 (unary_expression -> IDENTIFIER INC .)
    COMMA           reduce using rule 73 (unary_expression -> IDENTIFIER INC .)
    RBRACE          reduce using rule 73 (unary_expression -> IDENTIFIER INC .)


state 54

    (74) unary_expression -> IDENTIFIER DEC .

    RBRACKET        reduce using rule 74 (unary_expression -> IDENTIFIER DEC .)
    PLUS            reduce using rule 74 (unary_expression -> IDENTIFIER DEC .)
    MINUS           reduce using rule 74 (unary_expression -> IDENTIFIER DEC .)
    TIMES           reduce using rule 74 (unary_expression -> IDENTIFIER DEC .)
    DIVIDE          reduce using rule 74 (unary_expression -> IDENTIFIER DEC .)
    MOD             reduce using rule 74 (unary_expression -> IDENTIFIER DEC .)
    EQ              reduce using rule 74 (unary_expression -> IDENTIFIER DEC .)
    NEQ             reduce using rule 74 (unary_expression -> IDENTIFIER DEC .)
    LT              reduce using rule 74 (unary_expression -> IDENTIFIER DEC .)
    GT              reduce using rule 74 (unary_expression -> IDENTIFIER DEC .)
    LTE             reduce using rule 74 (unary_expression -> IDENTIFIER DEC .)
    GTE             reduce using rule 74 (unary_expression -> IDENTIFIER DEC .)
    AND             reduce using rule 74 (unary_expression -> IDENTIFIER DEC .)
    OR              reduce using rule 74 (unary_expression -> IDENTIFIER DEC .)
    SEMICOLON       reduce using rule 74 (unary_expression -> IDENTIFIER DEC .)
    RPAREN          reduce using rule 74 (unary_expression -> IDENTIFIER DEC .)
    COMMA           reduce using rule 74 (unary_expression -> IDENTIFIER DEC .)
    RBRACE          reduce using rule 74 (unary_expression -> IDENTIFIER DEC .)


state 55

    (81) function_call -> IDENTIFIER LPAREN . argument_list RPAREN
    (83) argument_list -> . argument_list COMMA expression
    (84) argument_list -> . expression
    (85) argument_list -> . empty
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (33) empty -> .
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    RPAREN          reduce using rule 33 (empty -> .)
    COMMA           reduce using rule 33 (empty -> .)
    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    argument_list                  shift and go to state 86
    expression                     shift and go to state 87
    empty                          shift and go to state 88
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 56

    (82) array_access -> IDENTIFIER LBRACKET . expression RBRACKET
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 89
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 57

    (14) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET . SEMICOLON
    (15) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET . ASSIGN LBRACE array_list RBRACE SEMICOLON
    (17) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET . ASSIGN STRING_LITERAL SEMICOLON

    SEMICOLON       shift and go to state 90
    ASSIGN          shift and go to state 91


state 58

    (56) binary_expression -> expression PLUS . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 92
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 59

    (57) binary_expression -> expression MINUS . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 93
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 60

    (58) binary_expression -> expression TIMES . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 94
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 61

    (59) binary_expression -> expression DIVIDE . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 95
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 62

    (60) binary_expression -> expression MOD . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 96
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 63

    (61) binary_expression -> expression EQ . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 97
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 64

    (62) binary_expression -> expression NEQ . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 98
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 65

    (63) binary_expression -> expression LT . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 99
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 66

    (64) binary_expression -> expression GT . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 100
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 67

    (65) binary_expression -> expression LTE . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 101
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 68

    (66) binary_expression -> expression GTE . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 102
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 69

    (67) binary_expression -> expression AND . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 103
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 70

    (68) binary_expression -> expression OR . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 104
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 71

    (16) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN . LBRACE array_list RBRACE SEMICOLON
    (18) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN . STRING_LITERAL SEMICOLON

    LBRACE          shift and go to state 105
    STRING_LITERAL  shift and go to state 106


state 72

    (55) assignment_expression -> array_access ASSIGN . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    array_access                   shift and go to state 36
    expression                     shift and go to state 107
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    term                           shift and go to state 37

state 73

    (69) unary_expression -> MINUS expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACKET        reduce using rule 69 (unary_expression -> MINUS expression .)
    PLUS            reduce using rule 69 (unary_expression -> MINUS expression .)
    MINUS           reduce using rule 69 (unary_expression -> MINUS expression .)
    TIMES           reduce using rule 69 (unary_expression -> MINUS expression .)
    DIVIDE          reduce using rule 69 (unary_expression -> MINUS expression .)
    MOD             reduce using rule 69 (unary_expression -> MINUS expression .)
    EQ              reduce using rule 69 (unary_expression -> MINUS expression .)
    NEQ             reduce using rule 69 (unary_expression -> MINUS expression .)
    LT              reduce using rule 69 (unary_expression -> MINUS expression .)
    GT              reduce using rule 69 (unary_expression -> MINUS expression .)
    LTE             reduce using rule 69 (unary_expression -> MINUS expression .)
    GTE             reduce using rule 69 (unary_expression -> MINUS expression .)
    AND             reduce using rule 69 (unary_expression -> MINUS expression .)
    OR              reduce using rule 69 (unary_expression -> MINUS expression .)
    SEMICOLON       reduce using rule 69 (unary_expression -> MINUS expression .)
    RPAREN          reduce using rule 69 (unary_expression -> MINUS expression .)
    COMMA           reduce using rule 69 (unary_expression -> MINUS expression .)
    RBRACE          reduce using rule 69 (unary_expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 58 ]
  ! MINUS           [ shift and go to state 59 ]
  ! TIMES           [ shift and go to state 60 ]
  ! DIVIDE          [ shift and go to state 61 ]
  ! MOD             [ shift and go to state 62 ]
  ! EQ              [ shift and go to state 63 ]
  ! NEQ             [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GT              [ shift and go to state 66 ]
  ! LTE             [ shift and go to state 67 ]
  ! GTE             [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 74

    (70) unary_expression -> NOT expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACKET        reduce using rule 70 (unary_expression -> NOT expression .)
    PLUS            reduce using rule 70 (unary_expression -> NOT expression .)
    MINUS           reduce using rule 70 (unary_expression -> NOT expression .)
    TIMES           reduce using rule 70 (unary_expression -> NOT expression .)
    DIVIDE          reduce using rule 70 (unary_expression -> NOT expression .)
    MOD             reduce using rule 70 (unary_expression -> NOT expression .)
    EQ              reduce using rule 70 (unary_expression -> NOT expression .)
    NEQ             reduce using rule 70 (unary_expression -> NOT expression .)
    LT              reduce using rule 70 (unary_expression -> NOT expression .)
    GT              reduce using rule 70 (unary_expression -> NOT expression .)
    LTE             reduce using rule 70 (unary_expression -> NOT expression .)
    GTE             reduce using rule 70 (unary_expression -> NOT expression .)
    AND             reduce using rule 70 (unary_expression -> NOT expression .)
    OR              reduce using rule 70 (unary_expression -> NOT expression .)
    SEMICOLON       reduce using rule 70 (unary_expression -> NOT expression .)
    RPAREN          reduce using rule 70 (unary_expression -> NOT expression .)
    COMMA           reduce using rule 70 (unary_expression -> NOT expression .)
    RBRACE          reduce using rule 70 (unary_expression -> NOT expression .)

  ! PLUS            [ shift and go to state 58 ]
  ! MINUS           [ shift and go to state 59 ]
  ! TIMES           [ shift and go to state 60 ]
  ! DIVIDE          [ shift and go to state 61 ]
  ! MOD             [ shift and go to state 62 ]
  ! EQ              [ shift and go to state 63 ]
  ! NEQ             [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GT              [ shift and go to state 66 ]
  ! LTE             [ shift and go to state 67 ]
  ! GTE             [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 75

    (71) unary_expression -> INC IDENTIFIER .

    RBRACKET        reduce using rule 71 (unary_expression -> INC IDENTIFIER .)
    PLUS            reduce using rule 71 (unary_expression -> INC IDENTIFIER .)
    MINUS           reduce using rule 71 (unary_expression -> INC IDENTIFIER .)
    TIMES           reduce using rule 71 (unary_expression -> INC IDENTIFIER .)
    DIVIDE          reduce using rule 71 (unary_expression -> INC IDENTIFIER .)
    MOD             reduce using rule 71 (unary_expression -> INC IDENTIFIER .)
    EQ              reduce using rule 71 (unary_expression -> INC IDENTIFIER .)
    NEQ             reduce using rule 71 (unary_expression -> INC IDENTIFIER .)
    LT              reduce using rule 71 (unary_expression -> INC IDENTIFIER .)
    GT              reduce using rule 71 (unary_expression -> INC IDENTIFIER .)
    LTE             reduce using rule 71 (unary_expression -> INC IDENTIFIER .)
    GTE             reduce using rule 71 (unary_expression -> INC IDENTIFIER .)
    AND             reduce using rule 71 (unary_expression -> INC IDENTIFIER .)
    OR              reduce using rule 71 (unary_expression -> INC IDENTIFIER .)
    SEMICOLON       reduce using rule 71 (unary_expression -> INC IDENTIFIER .)
    RPAREN          reduce using rule 71 (unary_expression -> INC IDENTIFIER .)
    COMMA           reduce using rule 71 (unary_expression -> INC IDENTIFIER .)
    RBRACE          reduce using rule 71 (unary_expression -> INC IDENTIFIER .)


state 76

    (72) unary_expression -> DEC IDENTIFIER .

    RBRACKET        reduce using rule 72 (unary_expression -> DEC IDENTIFIER .)
    PLUS            reduce using rule 72 (unary_expression -> DEC IDENTIFIER .)
    MINUS           reduce using rule 72 (unary_expression -> DEC IDENTIFIER .)
    TIMES           reduce using rule 72 (unary_expression -> DEC IDENTIFIER .)
    DIVIDE          reduce using rule 72 (unary_expression -> DEC IDENTIFIER .)
    MOD             reduce using rule 72 (unary_expression -> DEC IDENTIFIER .)
    EQ              reduce using rule 72 (unary_expression -> DEC IDENTIFIER .)
    NEQ             reduce using rule 72 (unary_expression -> DEC IDENTIFIER .)
    LT              reduce using rule 72 (unary_expression -> DEC IDENTIFIER .)
    GT              reduce using rule 72 (unary_expression -> DEC IDENTIFIER .)
    LTE             reduce using rule 72 (unary_expression -> DEC IDENTIFIER .)
    GTE             reduce using rule 72 (unary_expression -> DEC IDENTIFIER .)
    AND             reduce using rule 72 (unary_expression -> DEC IDENTIFIER .)
    OR              reduce using rule 72 (unary_expression -> DEC IDENTIFIER .)
    SEMICOLON       reduce using rule 72 (unary_expression -> DEC IDENTIFIER .)
    RPAREN          reduce using rule 72 (unary_expression -> DEC IDENTIFIER .)
    COMMA           reduce using rule 72 (unary_expression -> DEC IDENTIFIER .)
    RBRACE          reduce using rule 72 (unary_expression -> DEC IDENTIFIER .)


state 77

    (80) term -> LPAREN expression . RPAREN
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RPAREN          shift and go to state 108
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 78

    (13) var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .

    INT             reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    FLOAT           reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    CHAR            reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    CONTINUE        reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    BREAK           reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    INC             reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    DEC             reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    INT_LITERAL     reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    CHAR_LITERAL    reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_LITERAL  reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    ELSE            reduce using rule 13 (var_declaration_init -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)


state 79

    (31) param -> type_specifier IDENTIFIER LBRACKET . RBRACKET

    RBRACKET        shift and go to state 109


state 80

    (32) param -> type_specifier TIMES IDENTIFIER .

    RPAREN          reduce using rule 32 (param -> type_specifier TIMES IDENTIFIER .)
    COMMA           reduce using rule 32 (param -> type_specifier TIMES IDENTIFIER .)


state 81

    (25) function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN SEMICOLON .

    INT             reduce using rule 25 (function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN SEMICOLON .)
    FLOAT           reduce using rule 25 (function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN SEMICOLON .)
    CHAR            reduce using rule 25 (function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN SEMICOLON .)
    VOID            reduce using rule 25 (function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN SEMICOLON .)
    $end            reduce using rule 25 (function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN SEMICOLON .)


state 82

    (26) function_definition -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement .

    INT             reduce using rule 26 (function_definition -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement .)
    FLOAT           reduce using rule 26 (function_definition -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement .)
    CHAR            reduce using rule 26 (function_definition -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement .)
    VOID            reduce using rule 26 (function_definition -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement .)
    $end            reduce using rule 26 (function_definition -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement .)


state 83

    (34) compound_statement -> LBRACE . statement_list RBRACE
    (35) statement_list -> . statement_list statement
    (36) statement_list -> . statement
    (37) statement -> . expression_statement
    (38) statement -> . compound_statement
    (39) statement -> . selection_statement
    (40) statement -> . iteration_statement
    (41) statement -> . return_statement
    (42) statement -> . continue_statement
    (43) statement -> . break_statement
    (44) statement -> . var_declaration
    (45) statement -> . array_declaration
    (46) statement -> . empty
    (47) expression_statement -> . expression SEMICOLON
    (34) compound_statement -> . LBRACE statement_list RBRACE
    (86) selection_statement -> . IF LPAREN expression RPAREN statement
    (87) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (88) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (89) iteration_statement -> . for_expression_statement
    (90) iteration_statement -> . for_var_declaration
    (93) return_statement -> . RETURN expression SEMICOLON
    (94) continue_statement -> . CONTINUE SEMICOLON
    (95) break_statement -> . BREAK SEMICOLON
    (8) var_declaration -> . var_direct_declaration
    (9) var_declaration -> . var_pointer_declaration
    (10) var_declaration -> . var_declaration_init
    (14) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (15) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (16) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (17) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (18) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (33) empty -> .
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (91) for_expression_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
    (92) for_var_declaration -> . FOR LPAREN var_declaration expression_statement expression RPAREN statement
    (11) var_direct_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (12) var_pointer_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (13) var_declaration_init -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (19) type_specifier -> . INT
    (20) type_specifier -> . FLOAT
    (21) type_specifier -> . CHAR
    (22) type_specifier -> . VOID
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for FLOAT_LITERAL resolved as shift
  ! shift/reduce conflict for CHAR_LITERAL resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 83
    IF              shift and go to state 123
    WHILE           shift and go to state 124
    RETURN          shift and go to state 127
    CONTINUE        shift and go to state 128
    BREAK           shift and go to state 129
    RBRACE          reduce using rule 33 (empty -> .)
    FOR             shift and go to state 131
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    CHAR            shift and go to state 14
    VOID            shift and go to state 15
    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

  ! LBRACE          [ reduce using rule 33 (empty -> .) ]
  ! IF              [ reduce using rule 33 (empty -> .) ]
  ! WHILE           [ reduce using rule 33 (empty -> .) ]
  ! RETURN          [ reduce using rule 33 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 33 (empty -> .) ]
  ! BREAK           [ reduce using rule 33 (empty -> .) ]
  ! FOR             [ reduce using rule 33 (empty -> .) ]
  ! INT             [ reduce using rule 33 (empty -> .) ]
  ! FLOAT           [ reduce using rule 33 (empty -> .) ]
  ! CHAR            [ reduce using rule 33 (empty -> .) ]
  ! VOID            [ reduce using rule 33 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 33 (empty -> .) ]
  ! MINUS           [ reduce using rule 33 (empty -> .) ]
  ! NOT             [ reduce using rule 33 (empty -> .) ]
  ! INC             [ reduce using rule 33 (empty -> .) ]
  ! DEC             [ reduce using rule 33 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 33 (empty -> .) ]
  ! FLOAT_LITERAL   [ reduce using rule 33 (empty -> .) ]
  ! CHAR_LITERAL    [ reduce using rule 33 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 33 (empty -> .) ]
  ! LPAREN          [ reduce using rule 33 (empty -> .) ]

    statement_list                 shift and go to state 110
    statement                      shift and go to state 111
    expression_statement           shift and go to state 112
    compound_statement             shift and go to state 113
    selection_statement            shift and go to state 114
    iteration_statement            shift and go to state 115
    return_statement               shift and go to state 116
    continue_statement             shift and go to state 117
    break_statement                shift and go to state 118
    var_declaration                shift and go to state 119
    array_declaration              shift and go to state 120
    empty                          shift and go to state 121
    expression                     shift and go to state 122
    for_expression_statement       shift and go to state 125
    for_var_declaration            shift and go to state 126
    var_direct_declaration         shift and go to state 8
    var_pointer_declaration        shift and go to state 9
    var_declaration_init           shift and go to state 10
    type_specifier                 shift and go to state 130
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 84

    (27) param_list -> param_list COMMA param .

    RPAREN          reduce using rule 27 (param_list -> param_list COMMA param .)
    COMMA           reduce using rule 27 (param_list -> param_list COMMA param .)


state 85

    (54) assignment_expression -> IDENTIFIER ASSIGN expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RBRACKET        reduce using rule 54 (assignment_expression -> IDENTIFIER ASSIGN expression .)
    SEMICOLON       reduce using rule 54 (assignment_expression -> IDENTIFIER ASSIGN expression .)
    RPAREN          reduce using rule 54 (assignment_expression -> IDENTIFIER ASSIGN expression .)
    COMMA           reduce using rule 54 (assignment_expression -> IDENTIFIER ASSIGN expression .)
    RBRACE          reduce using rule 54 (assignment_expression -> IDENTIFIER ASSIGN expression .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70

  ! PLUS            [ reduce using rule 54 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 54 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! TIMES           [ reduce using rule 54 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! DIVIDE          [ reduce using rule 54 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! MOD             [ reduce using rule 54 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! EQ              [ reduce using rule 54 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! NEQ             [ reduce using rule 54 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! LT              [ reduce using rule 54 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! GT              [ reduce using rule 54 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! LTE             [ reduce using rule 54 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! GTE             [ reduce using rule 54 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! AND             [ reduce using rule 54 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! OR              [ reduce using rule 54 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]


state 86

    (81) function_call -> IDENTIFIER LPAREN argument_list . RPAREN
    (83) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 132
    COMMA           shift and go to state 133


state 87

    (84) argument_list -> expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RPAREN          reduce using rule 84 (argument_list -> expression .)
    COMMA           reduce using rule 84 (argument_list -> expression .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 88

    (85) argument_list -> empty .

    RPAREN          reduce using rule 85 (argument_list -> empty .)
    COMMA           reduce using rule 85 (argument_list -> empty .)


state 89

    (82) array_access -> IDENTIFIER LBRACKET expression . RBRACKET
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACKET        shift and go to state 134
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 90

    (14) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .

    INT             reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    FLOAT           reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    CHAR            reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    VOID            reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    $end            reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    LBRACE          reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    IF              reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    WHILE           reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    RETURN          reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    CONTINUE        reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    BREAK           reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    FOR             reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    MINUS           reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    NOT             reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    INC             reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    DEC             reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    INT_LITERAL     reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    CHAR_LITERAL    reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    STRING_LITERAL  reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    LPAREN          reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)
    ELSE            reduce using rule 14 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON .)


state 91

    (15) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN . LBRACE array_list RBRACE SEMICOLON
    (17) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN . STRING_LITERAL SEMICOLON

    LBRACE          shift and go to state 135
    STRING_LITERAL  shift and go to state 136


state 92

    (56) binary_expression -> expression PLUS expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACKET        reduce using rule 56 (binary_expression -> expression PLUS expression .)
    PLUS            reduce using rule 56 (binary_expression -> expression PLUS expression .)
    MINUS           reduce using rule 56 (binary_expression -> expression PLUS expression .)
    EQ              reduce using rule 56 (binary_expression -> expression PLUS expression .)
    NEQ             reduce using rule 56 (binary_expression -> expression PLUS expression .)
    LT              reduce using rule 56 (binary_expression -> expression PLUS expression .)
    GT              reduce using rule 56 (binary_expression -> expression PLUS expression .)
    LTE             reduce using rule 56 (binary_expression -> expression PLUS expression .)
    GTE             reduce using rule 56 (binary_expression -> expression PLUS expression .)
    AND             reduce using rule 56 (binary_expression -> expression PLUS expression .)
    OR              reduce using rule 56 (binary_expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 56 (binary_expression -> expression PLUS expression .)
    RPAREN          reduce using rule 56 (binary_expression -> expression PLUS expression .)
    COMMA           reduce using rule 56 (binary_expression -> expression PLUS expression .)
    RBRACE          reduce using rule 56 (binary_expression -> expression PLUS expression .)
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62

  ! TIMES           [ reduce using rule 56 (binary_expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 56 (binary_expression -> expression PLUS expression .) ]
  ! MOD             [ reduce using rule 56 (binary_expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 58 ]
  ! MINUS           [ shift and go to state 59 ]
  ! EQ              [ shift and go to state 63 ]
  ! NEQ             [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GT              [ shift and go to state 66 ]
  ! LTE             [ shift and go to state 67 ]
  ! GTE             [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 93

    (57) binary_expression -> expression MINUS expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACKET        reduce using rule 57 (binary_expression -> expression MINUS expression .)
    PLUS            reduce using rule 57 (binary_expression -> expression MINUS expression .)
    MINUS           reduce using rule 57 (binary_expression -> expression MINUS expression .)
    EQ              reduce using rule 57 (binary_expression -> expression MINUS expression .)
    NEQ             reduce using rule 57 (binary_expression -> expression MINUS expression .)
    LT              reduce using rule 57 (binary_expression -> expression MINUS expression .)
    GT              reduce using rule 57 (binary_expression -> expression MINUS expression .)
    LTE             reduce using rule 57 (binary_expression -> expression MINUS expression .)
    GTE             reduce using rule 57 (binary_expression -> expression MINUS expression .)
    AND             reduce using rule 57 (binary_expression -> expression MINUS expression .)
    OR              reduce using rule 57 (binary_expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 57 (binary_expression -> expression MINUS expression .)
    RPAREN          reduce using rule 57 (binary_expression -> expression MINUS expression .)
    COMMA           reduce using rule 57 (binary_expression -> expression MINUS expression .)
    RBRACE          reduce using rule 57 (binary_expression -> expression MINUS expression .)
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62

  ! TIMES           [ reduce using rule 57 (binary_expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 57 (binary_expression -> expression MINUS expression .) ]
  ! MOD             [ reduce using rule 57 (binary_expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 58 ]
  ! MINUS           [ shift and go to state 59 ]
  ! EQ              [ shift and go to state 63 ]
  ! NEQ             [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GT              [ shift and go to state 66 ]
  ! LTE             [ shift and go to state 67 ]
  ! GTE             [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 94

    (58) binary_expression -> expression TIMES expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACKET        reduce using rule 58 (binary_expression -> expression TIMES expression .)
    PLUS            reduce using rule 58 (binary_expression -> expression TIMES expression .)
    MINUS           reduce using rule 58 (binary_expression -> expression TIMES expression .)
    TIMES           reduce using rule 58 (binary_expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 58 (binary_expression -> expression TIMES expression .)
    MOD             reduce using rule 58 (binary_expression -> expression TIMES expression .)
    EQ              reduce using rule 58 (binary_expression -> expression TIMES expression .)
    NEQ             reduce using rule 58 (binary_expression -> expression TIMES expression .)
    LT              reduce using rule 58 (binary_expression -> expression TIMES expression .)
    GT              reduce using rule 58 (binary_expression -> expression TIMES expression .)
    LTE             reduce using rule 58 (binary_expression -> expression TIMES expression .)
    GTE             reduce using rule 58 (binary_expression -> expression TIMES expression .)
    AND             reduce using rule 58 (binary_expression -> expression TIMES expression .)
    OR              reduce using rule 58 (binary_expression -> expression TIMES expression .)
    SEMICOLON       reduce using rule 58 (binary_expression -> expression TIMES expression .)
    RPAREN          reduce using rule 58 (binary_expression -> expression TIMES expression .)
    COMMA           reduce using rule 58 (binary_expression -> expression TIMES expression .)
    RBRACE          reduce using rule 58 (binary_expression -> expression TIMES expression .)

  ! PLUS            [ shift and go to state 58 ]
  ! MINUS           [ shift and go to state 59 ]
  ! TIMES           [ shift and go to state 60 ]
  ! DIVIDE          [ shift and go to state 61 ]
  ! MOD             [ shift and go to state 62 ]
  ! EQ              [ shift and go to state 63 ]
  ! NEQ             [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GT              [ shift and go to state 66 ]
  ! LTE             [ shift and go to state 67 ]
  ! GTE             [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 95

    (59) binary_expression -> expression DIVIDE expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACKET        reduce using rule 59 (binary_expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 59 (binary_expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 59 (binary_expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 59 (binary_expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 59 (binary_expression -> expression DIVIDE expression .)
    MOD             reduce using rule 59 (binary_expression -> expression DIVIDE expression .)
    EQ              reduce using rule 59 (binary_expression -> expression DIVIDE expression .)
    NEQ             reduce using rule 59 (binary_expression -> expression DIVIDE expression .)
    LT              reduce using rule 59 (binary_expression -> expression DIVIDE expression .)
    GT              reduce using rule 59 (binary_expression -> expression DIVIDE expression .)
    LTE             reduce using rule 59 (binary_expression -> expression DIVIDE expression .)
    GTE             reduce using rule 59 (binary_expression -> expression DIVIDE expression .)
    AND             reduce using rule 59 (binary_expression -> expression DIVIDE expression .)
    OR              reduce using rule 59 (binary_expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 59 (binary_expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 59 (binary_expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 59 (binary_expression -> expression DIVIDE expression .)
    RBRACE          reduce using rule 59 (binary_expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 58 ]
  ! MINUS           [ shift and go to state 59 ]
  ! TIMES           [ shift and go to state 60 ]
  ! DIVIDE          [ shift and go to state 61 ]
  ! MOD             [ shift and go to state 62 ]
  ! EQ              [ shift and go to state 63 ]
  ! NEQ             [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GT              [ shift and go to state 66 ]
  ! LTE             [ shift and go to state 67 ]
  ! GTE             [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 96

    (60) binary_expression -> expression MOD expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACKET        reduce using rule 60 (binary_expression -> expression MOD expression .)
    PLUS            reduce using rule 60 (binary_expression -> expression MOD expression .)
    MINUS           reduce using rule 60 (binary_expression -> expression MOD expression .)
    TIMES           reduce using rule 60 (binary_expression -> expression MOD expression .)
    DIVIDE          reduce using rule 60 (binary_expression -> expression MOD expression .)
    MOD             reduce using rule 60 (binary_expression -> expression MOD expression .)
    EQ              reduce using rule 60 (binary_expression -> expression MOD expression .)
    NEQ             reduce using rule 60 (binary_expression -> expression MOD expression .)
    LT              reduce using rule 60 (binary_expression -> expression MOD expression .)
    GT              reduce using rule 60 (binary_expression -> expression MOD expression .)
    LTE             reduce using rule 60 (binary_expression -> expression MOD expression .)
    GTE             reduce using rule 60 (binary_expression -> expression MOD expression .)
    AND             reduce using rule 60 (binary_expression -> expression MOD expression .)
    OR              reduce using rule 60 (binary_expression -> expression MOD expression .)
    SEMICOLON       reduce using rule 60 (binary_expression -> expression MOD expression .)
    RPAREN          reduce using rule 60 (binary_expression -> expression MOD expression .)
    COMMA           reduce using rule 60 (binary_expression -> expression MOD expression .)
    RBRACE          reduce using rule 60 (binary_expression -> expression MOD expression .)

  ! PLUS            [ shift and go to state 58 ]
  ! MINUS           [ shift and go to state 59 ]
  ! TIMES           [ shift and go to state 60 ]
  ! DIVIDE          [ shift and go to state 61 ]
  ! MOD             [ shift and go to state 62 ]
  ! EQ              [ shift and go to state 63 ]
  ! NEQ             [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GT              [ shift and go to state 66 ]
  ! LTE             [ shift and go to state 67 ]
  ! GTE             [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 97

    (61) binary_expression -> expression EQ expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACKET        reduce using rule 61 (binary_expression -> expression EQ expression .)
    EQ              reduce using rule 61 (binary_expression -> expression EQ expression .)
    NEQ             reduce using rule 61 (binary_expression -> expression EQ expression .)
    AND             reduce using rule 61 (binary_expression -> expression EQ expression .)
    OR              reduce using rule 61 (binary_expression -> expression EQ expression .)
    SEMICOLON       reduce using rule 61 (binary_expression -> expression EQ expression .)
    RPAREN          reduce using rule 61 (binary_expression -> expression EQ expression .)
    COMMA           reduce using rule 61 (binary_expression -> expression EQ expression .)
    RBRACE          reduce using rule 61 (binary_expression -> expression EQ expression .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68

  ! PLUS            [ reduce using rule 61 (binary_expression -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 61 (binary_expression -> expression EQ expression .) ]
  ! TIMES           [ reduce using rule 61 (binary_expression -> expression EQ expression .) ]
  ! DIVIDE          [ reduce using rule 61 (binary_expression -> expression EQ expression .) ]
  ! MOD             [ reduce using rule 61 (binary_expression -> expression EQ expression .) ]
  ! LT              [ reduce using rule 61 (binary_expression -> expression EQ expression .) ]
  ! GT              [ reduce using rule 61 (binary_expression -> expression EQ expression .) ]
  ! LTE             [ reduce using rule 61 (binary_expression -> expression EQ expression .) ]
  ! GTE             [ reduce using rule 61 (binary_expression -> expression EQ expression .) ]
  ! EQ              [ shift and go to state 63 ]
  ! NEQ             [ shift and go to state 64 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 98

    (62) binary_expression -> expression NEQ expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACKET        reduce using rule 62 (binary_expression -> expression NEQ expression .)
    EQ              reduce using rule 62 (binary_expression -> expression NEQ expression .)
    NEQ             reduce using rule 62 (binary_expression -> expression NEQ expression .)
    AND             reduce using rule 62 (binary_expression -> expression NEQ expression .)
    OR              reduce using rule 62 (binary_expression -> expression NEQ expression .)
    SEMICOLON       reduce using rule 62 (binary_expression -> expression NEQ expression .)
    RPAREN          reduce using rule 62 (binary_expression -> expression NEQ expression .)
    COMMA           reduce using rule 62 (binary_expression -> expression NEQ expression .)
    RBRACE          reduce using rule 62 (binary_expression -> expression NEQ expression .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68

  ! PLUS            [ reduce using rule 62 (binary_expression -> expression NEQ expression .) ]
  ! MINUS           [ reduce using rule 62 (binary_expression -> expression NEQ expression .) ]
  ! TIMES           [ reduce using rule 62 (binary_expression -> expression NEQ expression .) ]
  ! DIVIDE          [ reduce using rule 62 (binary_expression -> expression NEQ expression .) ]
  ! MOD             [ reduce using rule 62 (binary_expression -> expression NEQ expression .) ]
  ! LT              [ reduce using rule 62 (binary_expression -> expression NEQ expression .) ]
  ! GT              [ reduce using rule 62 (binary_expression -> expression NEQ expression .) ]
  ! LTE             [ reduce using rule 62 (binary_expression -> expression NEQ expression .) ]
  ! GTE             [ reduce using rule 62 (binary_expression -> expression NEQ expression .) ]
  ! EQ              [ shift and go to state 63 ]
  ! NEQ             [ shift and go to state 64 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 99

    (63) binary_expression -> expression LT expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACKET        reduce using rule 63 (binary_expression -> expression LT expression .)
    EQ              reduce using rule 63 (binary_expression -> expression LT expression .)
    NEQ             reduce using rule 63 (binary_expression -> expression LT expression .)
    LT              reduce using rule 63 (binary_expression -> expression LT expression .)
    GT              reduce using rule 63 (binary_expression -> expression LT expression .)
    LTE             reduce using rule 63 (binary_expression -> expression LT expression .)
    GTE             reduce using rule 63 (binary_expression -> expression LT expression .)
    AND             reduce using rule 63 (binary_expression -> expression LT expression .)
    OR              reduce using rule 63 (binary_expression -> expression LT expression .)
    SEMICOLON       reduce using rule 63 (binary_expression -> expression LT expression .)
    RPAREN          reduce using rule 63 (binary_expression -> expression LT expression .)
    COMMA           reduce using rule 63 (binary_expression -> expression LT expression .)
    RBRACE          reduce using rule 63 (binary_expression -> expression LT expression .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62

  ! PLUS            [ reduce using rule 63 (binary_expression -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 63 (binary_expression -> expression LT expression .) ]
  ! TIMES           [ reduce using rule 63 (binary_expression -> expression LT expression .) ]
  ! DIVIDE          [ reduce using rule 63 (binary_expression -> expression LT expression .) ]
  ! MOD             [ reduce using rule 63 (binary_expression -> expression LT expression .) ]
  ! EQ              [ shift and go to state 63 ]
  ! NEQ             [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GT              [ shift and go to state 66 ]
  ! LTE             [ shift and go to state 67 ]
  ! GTE             [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 100

    (64) binary_expression -> expression GT expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACKET        reduce using rule 64 (binary_expression -> expression GT expression .)
    EQ              reduce using rule 64 (binary_expression -> expression GT expression .)
    NEQ             reduce using rule 64 (binary_expression -> expression GT expression .)
    LT              reduce using rule 64 (binary_expression -> expression GT expression .)
    GT              reduce using rule 64 (binary_expression -> expression GT expression .)
    LTE             reduce using rule 64 (binary_expression -> expression GT expression .)
    GTE             reduce using rule 64 (binary_expression -> expression GT expression .)
    AND             reduce using rule 64 (binary_expression -> expression GT expression .)
    OR              reduce using rule 64 (binary_expression -> expression GT expression .)
    SEMICOLON       reduce using rule 64 (binary_expression -> expression GT expression .)
    RPAREN          reduce using rule 64 (binary_expression -> expression GT expression .)
    COMMA           reduce using rule 64 (binary_expression -> expression GT expression .)
    RBRACE          reduce using rule 64 (binary_expression -> expression GT expression .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62

  ! PLUS            [ reduce using rule 64 (binary_expression -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 64 (binary_expression -> expression GT expression .) ]
  ! TIMES           [ reduce using rule 64 (binary_expression -> expression GT expression .) ]
  ! DIVIDE          [ reduce using rule 64 (binary_expression -> expression GT expression .) ]
  ! MOD             [ reduce using rule 64 (binary_expression -> expression GT expression .) ]
  ! EQ              [ shift and go to state 63 ]
  ! NEQ             [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GT              [ shift and go to state 66 ]
  ! LTE             [ shift and go to state 67 ]
  ! GTE             [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 101

    (65) binary_expression -> expression LTE expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACKET        reduce using rule 65 (binary_expression -> expression LTE expression .)
    EQ              reduce using rule 65 (binary_expression -> expression LTE expression .)
    NEQ             reduce using rule 65 (binary_expression -> expression LTE expression .)
    LT              reduce using rule 65 (binary_expression -> expression LTE expression .)
    GT              reduce using rule 65 (binary_expression -> expression LTE expression .)
    LTE             reduce using rule 65 (binary_expression -> expression LTE expression .)
    GTE             reduce using rule 65 (binary_expression -> expression LTE expression .)
    AND             reduce using rule 65 (binary_expression -> expression LTE expression .)
    OR              reduce using rule 65 (binary_expression -> expression LTE expression .)
    SEMICOLON       reduce using rule 65 (binary_expression -> expression LTE expression .)
    RPAREN          reduce using rule 65 (binary_expression -> expression LTE expression .)
    COMMA           reduce using rule 65 (binary_expression -> expression LTE expression .)
    RBRACE          reduce using rule 65 (binary_expression -> expression LTE expression .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62

  ! PLUS            [ reduce using rule 65 (binary_expression -> expression LTE expression .) ]
  ! MINUS           [ reduce using rule 65 (binary_expression -> expression LTE expression .) ]
  ! TIMES           [ reduce using rule 65 (binary_expression -> expression LTE expression .) ]
  ! DIVIDE          [ reduce using rule 65 (binary_expression -> expression LTE expression .) ]
  ! MOD             [ reduce using rule 65 (binary_expression -> expression LTE expression .) ]
  ! EQ              [ shift and go to state 63 ]
  ! NEQ             [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GT              [ shift and go to state 66 ]
  ! LTE             [ shift and go to state 67 ]
  ! GTE             [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 102

    (66) binary_expression -> expression GTE expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACKET        reduce using rule 66 (binary_expression -> expression GTE expression .)
    EQ              reduce using rule 66 (binary_expression -> expression GTE expression .)
    NEQ             reduce using rule 66 (binary_expression -> expression GTE expression .)
    LT              reduce using rule 66 (binary_expression -> expression GTE expression .)
    GT              reduce using rule 66 (binary_expression -> expression GTE expression .)
    LTE             reduce using rule 66 (binary_expression -> expression GTE expression .)
    GTE             reduce using rule 66 (binary_expression -> expression GTE expression .)
    AND             reduce using rule 66 (binary_expression -> expression GTE expression .)
    OR              reduce using rule 66 (binary_expression -> expression GTE expression .)
    SEMICOLON       reduce using rule 66 (binary_expression -> expression GTE expression .)
    RPAREN          reduce using rule 66 (binary_expression -> expression GTE expression .)
    COMMA           reduce using rule 66 (binary_expression -> expression GTE expression .)
    RBRACE          reduce using rule 66 (binary_expression -> expression GTE expression .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62

  ! PLUS            [ reduce using rule 66 (binary_expression -> expression GTE expression .) ]
  ! MINUS           [ reduce using rule 66 (binary_expression -> expression GTE expression .) ]
  ! TIMES           [ reduce using rule 66 (binary_expression -> expression GTE expression .) ]
  ! DIVIDE          [ reduce using rule 66 (binary_expression -> expression GTE expression .) ]
  ! MOD             [ reduce using rule 66 (binary_expression -> expression GTE expression .) ]
  ! EQ              [ shift and go to state 63 ]
  ! NEQ             [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GT              [ shift and go to state 66 ]
  ! LTE             [ shift and go to state 67 ]
  ! GTE             [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 103

    (67) binary_expression -> expression AND expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACKET        reduce using rule 67 (binary_expression -> expression AND expression .)
    AND             reduce using rule 67 (binary_expression -> expression AND expression .)
    OR              reduce using rule 67 (binary_expression -> expression AND expression .)
    SEMICOLON       reduce using rule 67 (binary_expression -> expression AND expression .)
    RPAREN          reduce using rule 67 (binary_expression -> expression AND expression .)
    COMMA           reduce using rule 67 (binary_expression -> expression AND expression .)
    RBRACE          reduce using rule 67 (binary_expression -> expression AND expression .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68

  ! PLUS            [ reduce using rule 67 (binary_expression -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 67 (binary_expression -> expression AND expression .) ]
  ! TIMES           [ reduce using rule 67 (binary_expression -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 67 (binary_expression -> expression AND expression .) ]
  ! MOD             [ reduce using rule 67 (binary_expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 67 (binary_expression -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 67 (binary_expression -> expression AND expression .) ]
  ! LT              [ reduce using rule 67 (binary_expression -> expression AND expression .) ]
  ! GT              [ reduce using rule 67 (binary_expression -> expression AND expression .) ]
  ! LTE             [ reduce using rule 67 (binary_expression -> expression AND expression .) ]
  ! GTE             [ reduce using rule 67 (binary_expression -> expression AND expression .) ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 104

    (68) binary_expression -> expression OR expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACKET        reduce using rule 68 (binary_expression -> expression OR expression .)
    OR              reduce using rule 68 (binary_expression -> expression OR expression .)
    SEMICOLON       reduce using rule 68 (binary_expression -> expression OR expression .)
    RPAREN          reduce using rule 68 (binary_expression -> expression OR expression .)
    COMMA           reduce using rule 68 (binary_expression -> expression OR expression .)
    RBRACE          reduce using rule 68 (binary_expression -> expression OR expression .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68
    AND             shift and go to state 69

  ! PLUS            [ reduce using rule 68 (binary_expression -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 68 (binary_expression -> expression OR expression .) ]
  ! TIMES           [ reduce using rule 68 (binary_expression -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 68 (binary_expression -> expression OR expression .) ]
  ! MOD             [ reduce using rule 68 (binary_expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 68 (binary_expression -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 68 (binary_expression -> expression OR expression .) ]
  ! LT              [ reduce using rule 68 (binary_expression -> expression OR expression .) ]
  ! GT              [ reduce using rule 68 (binary_expression -> expression OR expression .) ]
  ! LTE             [ reduce using rule 68 (binary_expression -> expression OR expression .) ]
  ! GTE             [ reduce using rule 68 (binary_expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 68 (binary_expression -> expression OR expression .) ]
  ! OR              [ shift and go to state 70 ]


state 105

    (16) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE . array_list RBRACE SEMICOLON
    (23) array_list -> . array_list COMMA expression
    (24) array_list -> . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    array_list                     shift and go to state 137
    expression                     shift and go to state 138
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 106

    (18) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL . SEMICOLON

    SEMICOLON       shift and go to state 139


state 107

    (55) assignment_expression -> array_access ASSIGN expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RBRACKET        reduce using rule 55 (assignment_expression -> array_access ASSIGN expression .)
    SEMICOLON       reduce using rule 55 (assignment_expression -> array_access ASSIGN expression .)
    RPAREN          reduce using rule 55 (assignment_expression -> array_access ASSIGN expression .)
    COMMA           reduce using rule 55 (assignment_expression -> array_access ASSIGN expression .)
    RBRACE          reduce using rule 55 (assignment_expression -> array_access ASSIGN expression .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70

  ! PLUS            [ reduce using rule 55 (assignment_expression -> array_access ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 55 (assignment_expression -> array_access ASSIGN expression .) ]
  ! TIMES           [ reduce using rule 55 (assignment_expression -> array_access ASSIGN expression .) ]
  ! DIVIDE          [ reduce using rule 55 (assignment_expression -> array_access ASSIGN expression .) ]
  ! MOD             [ reduce using rule 55 (assignment_expression -> array_access ASSIGN expression .) ]
  ! EQ              [ reduce using rule 55 (assignment_expression -> array_access ASSIGN expression .) ]
  ! NEQ             [ reduce using rule 55 (assignment_expression -> array_access ASSIGN expression .) ]
  ! LT              [ reduce using rule 55 (assignment_expression -> array_access ASSIGN expression .) ]
  ! GT              [ reduce using rule 55 (assignment_expression -> array_access ASSIGN expression .) ]
  ! LTE             [ reduce using rule 55 (assignment_expression -> array_access ASSIGN expression .) ]
  ! GTE             [ reduce using rule 55 (assignment_expression -> array_access ASSIGN expression .) ]
  ! AND             [ reduce using rule 55 (assignment_expression -> array_access ASSIGN expression .) ]
  ! OR              [ reduce using rule 55 (assignment_expression -> array_access ASSIGN expression .) ]


state 108

    (80) term -> LPAREN expression RPAREN .

    RBRACKET        reduce using rule 80 (term -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 80 (term -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 80 (term -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 80 (term -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 80 (term -> LPAREN expression RPAREN .)
    MOD             reduce using rule 80 (term -> LPAREN expression RPAREN .)
    EQ              reduce using rule 80 (term -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 80 (term -> LPAREN expression RPAREN .)
    LT              reduce using rule 80 (term -> LPAREN expression RPAREN .)
    GT              reduce using rule 80 (term -> LPAREN expression RPAREN .)
    LTE             reduce using rule 80 (term -> LPAREN expression RPAREN .)
    GTE             reduce using rule 80 (term -> LPAREN expression RPAREN .)
    AND             reduce using rule 80 (term -> LPAREN expression RPAREN .)
    OR              reduce using rule 80 (term -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 80 (term -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 80 (term -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 80 (term -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 80 (term -> LPAREN expression RPAREN .)


state 109

    (31) param -> type_specifier IDENTIFIER LBRACKET RBRACKET .

    RPAREN          reduce using rule 31 (param -> type_specifier IDENTIFIER LBRACKET RBRACKET .)
    COMMA           reduce using rule 31 (param -> type_specifier IDENTIFIER LBRACKET RBRACKET .)


state 110

    (34) compound_statement -> LBRACE statement_list . RBRACE
    (35) statement_list -> statement_list . statement
    (37) statement -> . expression_statement
    (38) statement -> . compound_statement
    (39) statement -> . selection_statement
    (40) statement -> . iteration_statement
    (41) statement -> . return_statement
    (42) statement -> . continue_statement
    (43) statement -> . break_statement
    (44) statement -> . var_declaration
    (45) statement -> . array_declaration
    (46) statement -> . empty
    (47) expression_statement -> . expression SEMICOLON
    (34) compound_statement -> . LBRACE statement_list RBRACE
    (86) selection_statement -> . IF LPAREN expression RPAREN statement
    (87) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (88) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (89) iteration_statement -> . for_expression_statement
    (90) iteration_statement -> . for_var_declaration
    (93) return_statement -> . RETURN expression SEMICOLON
    (94) continue_statement -> . CONTINUE SEMICOLON
    (95) break_statement -> . BREAK SEMICOLON
    (8) var_declaration -> . var_direct_declaration
    (9) var_declaration -> . var_pointer_declaration
    (10) var_declaration -> . var_declaration_init
    (14) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (15) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (16) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (17) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (18) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (33) empty -> .
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (91) for_expression_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
    (92) for_var_declaration -> . FOR LPAREN var_declaration expression_statement expression RPAREN statement
    (11) var_direct_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (12) var_pointer_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (13) var_declaration_init -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (19) type_specifier -> . INT
    (20) type_specifier -> . FLOAT
    (21) type_specifier -> . CHAR
    (22) type_specifier -> . VOID
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for FLOAT_LITERAL resolved as shift
  ! shift/reduce conflict for CHAR_LITERAL resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    RBRACE          shift and go to state 140
    LBRACE          shift and go to state 83
    IF              shift and go to state 123
    WHILE           shift and go to state 124
    RETURN          shift and go to state 127
    CONTINUE        shift and go to state 128
    BREAK           shift and go to state 129
    FOR             shift and go to state 131
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    CHAR            shift and go to state 14
    VOID            shift and go to state 15
    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

  ! RBRACE          [ reduce using rule 33 (empty -> .) ]
  ! LBRACE          [ reduce using rule 33 (empty -> .) ]
  ! IF              [ reduce using rule 33 (empty -> .) ]
  ! WHILE           [ reduce using rule 33 (empty -> .) ]
  ! RETURN          [ reduce using rule 33 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 33 (empty -> .) ]
  ! BREAK           [ reduce using rule 33 (empty -> .) ]
  ! FOR             [ reduce using rule 33 (empty -> .) ]
  ! INT             [ reduce using rule 33 (empty -> .) ]
  ! FLOAT           [ reduce using rule 33 (empty -> .) ]
  ! CHAR            [ reduce using rule 33 (empty -> .) ]
  ! VOID            [ reduce using rule 33 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 33 (empty -> .) ]
  ! MINUS           [ reduce using rule 33 (empty -> .) ]
  ! NOT             [ reduce using rule 33 (empty -> .) ]
  ! INC             [ reduce using rule 33 (empty -> .) ]
  ! DEC             [ reduce using rule 33 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 33 (empty -> .) ]
  ! FLOAT_LITERAL   [ reduce using rule 33 (empty -> .) ]
  ! CHAR_LITERAL    [ reduce using rule 33 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 33 (empty -> .) ]
  ! LPAREN          [ reduce using rule 33 (empty -> .) ]

    statement                      shift and go to state 141
    expression_statement           shift and go to state 112
    compound_statement             shift and go to state 113
    selection_statement            shift and go to state 114
    iteration_statement            shift and go to state 115
    return_statement               shift and go to state 116
    continue_statement             shift and go to state 117
    break_statement                shift and go to state 118
    var_declaration                shift and go to state 119
    array_declaration              shift and go to state 120
    empty                          shift and go to state 121
    expression                     shift and go to state 122
    for_expression_statement       shift and go to state 125
    for_var_declaration            shift and go to state 126
    var_direct_declaration         shift and go to state 8
    var_pointer_declaration        shift and go to state 9
    var_declaration_init           shift and go to state 10
    type_specifier                 shift and go to state 130
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 111

    (36) statement_list -> statement .

    RBRACE          reduce using rule 36 (statement_list -> statement .)
    LBRACE          reduce using rule 36 (statement_list -> statement .)
    IF              reduce using rule 36 (statement_list -> statement .)
    WHILE           reduce using rule 36 (statement_list -> statement .)
    RETURN          reduce using rule 36 (statement_list -> statement .)
    CONTINUE        reduce using rule 36 (statement_list -> statement .)
    BREAK           reduce using rule 36 (statement_list -> statement .)
    FOR             reduce using rule 36 (statement_list -> statement .)
    INT             reduce using rule 36 (statement_list -> statement .)
    FLOAT           reduce using rule 36 (statement_list -> statement .)
    CHAR            reduce using rule 36 (statement_list -> statement .)
    VOID            reduce using rule 36 (statement_list -> statement .)
    IDENTIFIER      reduce using rule 36 (statement_list -> statement .)
    MINUS           reduce using rule 36 (statement_list -> statement .)
    NOT             reduce using rule 36 (statement_list -> statement .)
    INC             reduce using rule 36 (statement_list -> statement .)
    DEC             reduce using rule 36 (statement_list -> statement .)
    INT_LITERAL     reduce using rule 36 (statement_list -> statement .)
    FLOAT_LITERAL   reduce using rule 36 (statement_list -> statement .)
    CHAR_LITERAL    reduce using rule 36 (statement_list -> statement .)
    STRING_LITERAL  reduce using rule 36 (statement_list -> statement .)
    LPAREN          reduce using rule 36 (statement_list -> statement .)


state 112

    (37) statement -> expression_statement .

    RBRACE          reduce using rule 37 (statement -> expression_statement .)
    LBRACE          reduce using rule 37 (statement -> expression_statement .)
    IF              reduce using rule 37 (statement -> expression_statement .)
    WHILE           reduce using rule 37 (statement -> expression_statement .)
    RETURN          reduce using rule 37 (statement -> expression_statement .)
    CONTINUE        reduce using rule 37 (statement -> expression_statement .)
    BREAK           reduce using rule 37 (statement -> expression_statement .)
    FOR             reduce using rule 37 (statement -> expression_statement .)
    INT             reduce using rule 37 (statement -> expression_statement .)
    FLOAT           reduce using rule 37 (statement -> expression_statement .)
    CHAR            reduce using rule 37 (statement -> expression_statement .)
    VOID            reduce using rule 37 (statement -> expression_statement .)
    IDENTIFIER      reduce using rule 37 (statement -> expression_statement .)
    MINUS           reduce using rule 37 (statement -> expression_statement .)
    NOT             reduce using rule 37 (statement -> expression_statement .)
    INC             reduce using rule 37 (statement -> expression_statement .)
    DEC             reduce using rule 37 (statement -> expression_statement .)
    INT_LITERAL     reduce using rule 37 (statement -> expression_statement .)
    FLOAT_LITERAL   reduce using rule 37 (statement -> expression_statement .)
    CHAR_LITERAL    reduce using rule 37 (statement -> expression_statement .)
    STRING_LITERAL  reduce using rule 37 (statement -> expression_statement .)
    LPAREN          reduce using rule 37 (statement -> expression_statement .)
    ELSE            reduce using rule 37 (statement -> expression_statement .)


state 113

    (38) statement -> compound_statement .

    RBRACE          reduce using rule 38 (statement -> compound_statement .)
    LBRACE          reduce using rule 38 (statement -> compound_statement .)
    IF              reduce using rule 38 (statement -> compound_statement .)
    WHILE           reduce using rule 38 (statement -> compound_statement .)
    RETURN          reduce using rule 38 (statement -> compound_statement .)
    CONTINUE        reduce using rule 38 (statement -> compound_statement .)
    BREAK           reduce using rule 38 (statement -> compound_statement .)
    FOR             reduce using rule 38 (statement -> compound_statement .)
    INT             reduce using rule 38 (statement -> compound_statement .)
    FLOAT           reduce using rule 38 (statement -> compound_statement .)
    CHAR            reduce using rule 38 (statement -> compound_statement .)
    VOID            reduce using rule 38 (statement -> compound_statement .)
    IDENTIFIER      reduce using rule 38 (statement -> compound_statement .)
    MINUS           reduce using rule 38 (statement -> compound_statement .)
    NOT             reduce using rule 38 (statement -> compound_statement .)
    INC             reduce using rule 38 (statement -> compound_statement .)
    DEC             reduce using rule 38 (statement -> compound_statement .)
    INT_LITERAL     reduce using rule 38 (statement -> compound_statement .)
    FLOAT_LITERAL   reduce using rule 38 (statement -> compound_statement .)
    CHAR_LITERAL    reduce using rule 38 (statement -> compound_statement .)
    STRING_LITERAL  reduce using rule 38 (statement -> compound_statement .)
    LPAREN          reduce using rule 38 (statement -> compound_statement .)
    ELSE            reduce using rule 38 (statement -> compound_statement .)


state 114

    (39) statement -> selection_statement .

    RBRACE          reduce using rule 39 (statement -> selection_statement .)
    LBRACE          reduce using rule 39 (statement -> selection_statement .)
    IF              reduce using rule 39 (statement -> selection_statement .)
    WHILE           reduce using rule 39 (statement -> selection_statement .)
    RETURN          reduce using rule 39 (statement -> selection_statement .)
    CONTINUE        reduce using rule 39 (statement -> selection_statement .)
    BREAK           reduce using rule 39 (statement -> selection_statement .)
    FOR             reduce using rule 39 (statement -> selection_statement .)
    INT             reduce using rule 39 (statement -> selection_statement .)
    FLOAT           reduce using rule 39 (statement -> selection_statement .)
    CHAR            reduce using rule 39 (statement -> selection_statement .)
    VOID            reduce using rule 39 (statement -> selection_statement .)
    IDENTIFIER      reduce using rule 39 (statement -> selection_statement .)
    MINUS           reduce using rule 39 (statement -> selection_statement .)
    NOT             reduce using rule 39 (statement -> selection_statement .)
    INC             reduce using rule 39 (statement -> selection_statement .)
    DEC             reduce using rule 39 (statement -> selection_statement .)
    INT_LITERAL     reduce using rule 39 (statement -> selection_statement .)
    FLOAT_LITERAL   reduce using rule 39 (statement -> selection_statement .)
    CHAR_LITERAL    reduce using rule 39 (statement -> selection_statement .)
    STRING_LITERAL  reduce using rule 39 (statement -> selection_statement .)
    LPAREN          reduce using rule 39 (statement -> selection_statement .)
    ELSE            reduce using rule 39 (statement -> selection_statement .)


state 115

    (40) statement -> iteration_statement .

    RBRACE          reduce using rule 40 (statement -> iteration_statement .)
    LBRACE          reduce using rule 40 (statement -> iteration_statement .)
    IF              reduce using rule 40 (statement -> iteration_statement .)
    WHILE           reduce using rule 40 (statement -> iteration_statement .)
    RETURN          reduce using rule 40 (statement -> iteration_statement .)
    CONTINUE        reduce using rule 40 (statement -> iteration_statement .)
    BREAK           reduce using rule 40 (statement -> iteration_statement .)
    FOR             reduce using rule 40 (statement -> iteration_statement .)
    INT             reduce using rule 40 (statement -> iteration_statement .)
    FLOAT           reduce using rule 40 (statement -> iteration_statement .)
    CHAR            reduce using rule 40 (statement -> iteration_statement .)
    VOID            reduce using rule 40 (statement -> iteration_statement .)
    IDENTIFIER      reduce using rule 40 (statement -> iteration_statement .)
    MINUS           reduce using rule 40 (statement -> iteration_statement .)
    NOT             reduce using rule 40 (statement -> iteration_statement .)
    INC             reduce using rule 40 (statement -> iteration_statement .)
    DEC             reduce using rule 40 (statement -> iteration_statement .)
    INT_LITERAL     reduce using rule 40 (statement -> iteration_statement .)
    FLOAT_LITERAL   reduce using rule 40 (statement -> iteration_statement .)
    CHAR_LITERAL    reduce using rule 40 (statement -> iteration_statement .)
    STRING_LITERAL  reduce using rule 40 (statement -> iteration_statement .)
    LPAREN          reduce using rule 40 (statement -> iteration_statement .)
    ELSE            reduce using rule 40 (statement -> iteration_statement .)


state 116

    (41) statement -> return_statement .

    RBRACE          reduce using rule 41 (statement -> return_statement .)
    LBRACE          reduce using rule 41 (statement -> return_statement .)
    IF              reduce using rule 41 (statement -> return_statement .)
    WHILE           reduce using rule 41 (statement -> return_statement .)
    RETURN          reduce using rule 41 (statement -> return_statement .)
    CONTINUE        reduce using rule 41 (statement -> return_statement .)
    BREAK           reduce using rule 41 (statement -> return_statement .)
    FOR             reduce using rule 41 (statement -> return_statement .)
    INT             reduce using rule 41 (statement -> return_statement .)
    FLOAT           reduce using rule 41 (statement -> return_statement .)
    CHAR            reduce using rule 41 (statement -> return_statement .)
    VOID            reduce using rule 41 (statement -> return_statement .)
    IDENTIFIER      reduce using rule 41 (statement -> return_statement .)
    MINUS           reduce using rule 41 (statement -> return_statement .)
    NOT             reduce using rule 41 (statement -> return_statement .)
    INC             reduce using rule 41 (statement -> return_statement .)
    DEC             reduce using rule 41 (statement -> return_statement .)
    INT_LITERAL     reduce using rule 41 (statement -> return_statement .)
    FLOAT_LITERAL   reduce using rule 41 (statement -> return_statement .)
    CHAR_LITERAL    reduce using rule 41 (statement -> return_statement .)
    STRING_LITERAL  reduce using rule 41 (statement -> return_statement .)
    LPAREN          reduce using rule 41 (statement -> return_statement .)
    ELSE            reduce using rule 41 (statement -> return_statement .)


state 117

    (42) statement -> continue_statement .

    RBRACE          reduce using rule 42 (statement -> continue_statement .)
    LBRACE          reduce using rule 42 (statement -> continue_statement .)
    IF              reduce using rule 42 (statement -> continue_statement .)
    WHILE           reduce using rule 42 (statement -> continue_statement .)
    RETURN          reduce using rule 42 (statement -> continue_statement .)
    CONTINUE        reduce using rule 42 (statement -> continue_statement .)
    BREAK           reduce using rule 42 (statement -> continue_statement .)
    FOR             reduce using rule 42 (statement -> continue_statement .)
    INT             reduce using rule 42 (statement -> continue_statement .)
    FLOAT           reduce using rule 42 (statement -> continue_statement .)
    CHAR            reduce using rule 42 (statement -> continue_statement .)
    VOID            reduce using rule 42 (statement -> continue_statement .)
    IDENTIFIER      reduce using rule 42 (statement -> continue_statement .)
    MINUS           reduce using rule 42 (statement -> continue_statement .)
    NOT             reduce using rule 42 (statement -> continue_statement .)
    INC             reduce using rule 42 (statement -> continue_statement .)
    DEC             reduce using rule 42 (statement -> continue_statement .)
    INT_LITERAL     reduce using rule 42 (statement -> continue_statement .)
    FLOAT_LITERAL   reduce using rule 42 (statement -> continue_statement .)
    CHAR_LITERAL    reduce using rule 42 (statement -> continue_statement .)
    STRING_LITERAL  reduce using rule 42 (statement -> continue_statement .)
    LPAREN          reduce using rule 42 (statement -> continue_statement .)
    ELSE            reduce using rule 42 (statement -> continue_statement .)


state 118

    (43) statement -> break_statement .

    RBRACE          reduce using rule 43 (statement -> break_statement .)
    LBRACE          reduce using rule 43 (statement -> break_statement .)
    IF              reduce using rule 43 (statement -> break_statement .)
    WHILE           reduce using rule 43 (statement -> break_statement .)
    RETURN          reduce using rule 43 (statement -> break_statement .)
    CONTINUE        reduce using rule 43 (statement -> break_statement .)
    BREAK           reduce using rule 43 (statement -> break_statement .)
    FOR             reduce using rule 43 (statement -> break_statement .)
    INT             reduce using rule 43 (statement -> break_statement .)
    FLOAT           reduce using rule 43 (statement -> break_statement .)
    CHAR            reduce using rule 43 (statement -> break_statement .)
    VOID            reduce using rule 43 (statement -> break_statement .)
    IDENTIFIER      reduce using rule 43 (statement -> break_statement .)
    MINUS           reduce using rule 43 (statement -> break_statement .)
    NOT             reduce using rule 43 (statement -> break_statement .)
    INC             reduce using rule 43 (statement -> break_statement .)
    DEC             reduce using rule 43 (statement -> break_statement .)
    INT_LITERAL     reduce using rule 43 (statement -> break_statement .)
    FLOAT_LITERAL   reduce using rule 43 (statement -> break_statement .)
    CHAR_LITERAL    reduce using rule 43 (statement -> break_statement .)
    STRING_LITERAL  reduce using rule 43 (statement -> break_statement .)
    LPAREN          reduce using rule 43 (statement -> break_statement .)
    ELSE            reduce using rule 43 (statement -> break_statement .)


state 119

    (44) statement -> var_declaration .

    RBRACE          reduce using rule 44 (statement -> var_declaration .)
    LBRACE          reduce using rule 44 (statement -> var_declaration .)
    IF              reduce using rule 44 (statement -> var_declaration .)
    WHILE           reduce using rule 44 (statement -> var_declaration .)
    RETURN          reduce using rule 44 (statement -> var_declaration .)
    CONTINUE        reduce using rule 44 (statement -> var_declaration .)
    BREAK           reduce using rule 44 (statement -> var_declaration .)
    FOR             reduce using rule 44 (statement -> var_declaration .)
    INT             reduce using rule 44 (statement -> var_declaration .)
    FLOAT           reduce using rule 44 (statement -> var_declaration .)
    CHAR            reduce using rule 44 (statement -> var_declaration .)
    VOID            reduce using rule 44 (statement -> var_declaration .)
    IDENTIFIER      reduce using rule 44 (statement -> var_declaration .)
    MINUS           reduce using rule 44 (statement -> var_declaration .)
    NOT             reduce using rule 44 (statement -> var_declaration .)
    INC             reduce using rule 44 (statement -> var_declaration .)
    DEC             reduce using rule 44 (statement -> var_declaration .)
    INT_LITERAL     reduce using rule 44 (statement -> var_declaration .)
    FLOAT_LITERAL   reduce using rule 44 (statement -> var_declaration .)
    CHAR_LITERAL    reduce using rule 44 (statement -> var_declaration .)
    STRING_LITERAL  reduce using rule 44 (statement -> var_declaration .)
    LPAREN          reduce using rule 44 (statement -> var_declaration .)
    ELSE            reduce using rule 44 (statement -> var_declaration .)


state 120

    (45) statement -> array_declaration .

    RBRACE          reduce using rule 45 (statement -> array_declaration .)
    LBRACE          reduce using rule 45 (statement -> array_declaration .)
    IF              reduce using rule 45 (statement -> array_declaration .)
    WHILE           reduce using rule 45 (statement -> array_declaration .)
    RETURN          reduce using rule 45 (statement -> array_declaration .)
    CONTINUE        reduce using rule 45 (statement -> array_declaration .)
    BREAK           reduce using rule 45 (statement -> array_declaration .)
    FOR             reduce using rule 45 (statement -> array_declaration .)
    INT             reduce using rule 45 (statement -> array_declaration .)
    FLOAT           reduce using rule 45 (statement -> array_declaration .)
    CHAR            reduce using rule 45 (statement -> array_declaration .)
    VOID            reduce using rule 45 (statement -> array_declaration .)
    IDENTIFIER      reduce using rule 45 (statement -> array_declaration .)
    MINUS           reduce using rule 45 (statement -> array_declaration .)
    NOT             reduce using rule 45 (statement -> array_declaration .)
    INC             reduce using rule 45 (statement -> array_declaration .)
    DEC             reduce using rule 45 (statement -> array_declaration .)
    INT_LITERAL     reduce using rule 45 (statement -> array_declaration .)
    FLOAT_LITERAL   reduce using rule 45 (statement -> array_declaration .)
    CHAR_LITERAL    reduce using rule 45 (statement -> array_declaration .)
    STRING_LITERAL  reduce using rule 45 (statement -> array_declaration .)
    LPAREN          reduce using rule 45 (statement -> array_declaration .)
    ELSE            reduce using rule 45 (statement -> array_declaration .)


state 121

    (46) statement -> empty .

    RBRACE          reduce using rule 46 (statement -> empty .)
    LBRACE          reduce using rule 46 (statement -> empty .)
    IF              reduce using rule 46 (statement -> empty .)
    WHILE           reduce using rule 46 (statement -> empty .)
    RETURN          reduce using rule 46 (statement -> empty .)
    CONTINUE        reduce using rule 46 (statement -> empty .)
    BREAK           reduce using rule 46 (statement -> empty .)
    FOR             reduce using rule 46 (statement -> empty .)
    INT             reduce using rule 46 (statement -> empty .)
    FLOAT           reduce using rule 46 (statement -> empty .)
    CHAR            reduce using rule 46 (statement -> empty .)
    VOID            reduce using rule 46 (statement -> empty .)
    IDENTIFIER      reduce using rule 46 (statement -> empty .)
    MINUS           reduce using rule 46 (statement -> empty .)
    NOT             reduce using rule 46 (statement -> empty .)
    INC             reduce using rule 46 (statement -> empty .)
    DEC             reduce using rule 46 (statement -> empty .)
    INT_LITERAL     reduce using rule 46 (statement -> empty .)
    FLOAT_LITERAL   reduce using rule 46 (statement -> empty .)
    CHAR_LITERAL    reduce using rule 46 (statement -> empty .)
    STRING_LITERAL  reduce using rule 46 (statement -> empty .)
    LPAREN          reduce using rule 46 (statement -> empty .)
    ELSE            reduce using rule 46 (statement -> empty .)


state 122

    (47) expression_statement -> expression . SEMICOLON
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    SEMICOLON       shift and go to state 142
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 123

    (86) selection_statement -> IF . LPAREN expression RPAREN statement
    (87) selection_statement -> IF . LPAREN expression RPAREN statement ELSE statement

    LPAREN          shift and go to state 143


state 124

    (88) iteration_statement -> WHILE . LPAREN expression RPAREN statement

    LPAREN          shift and go to state 144


state 125

    (89) iteration_statement -> for_expression_statement .

    RBRACE          reduce using rule 89 (iteration_statement -> for_expression_statement .)
    LBRACE          reduce using rule 89 (iteration_statement -> for_expression_statement .)
    IF              reduce using rule 89 (iteration_statement -> for_expression_statement .)
    WHILE           reduce using rule 89 (iteration_statement -> for_expression_statement .)
    RETURN          reduce using rule 89 (iteration_statement -> for_expression_statement .)
    CONTINUE        reduce using rule 89 (iteration_statement -> for_expression_statement .)
    BREAK           reduce using rule 89 (iteration_statement -> for_expression_statement .)
    FOR             reduce using rule 89 (iteration_statement -> for_expression_statement .)
    INT             reduce using rule 89 (iteration_statement -> for_expression_statement .)
    FLOAT           reduce using rule 89 (iteration_statement -> for_expression_statement .)
    CHAR            reduce using rule 89 (iteration_statement -> for_expression_statement .)
    VOID            reduce using rule 89 (iteration_statement -> for_expression_statement .)
    IDENTIFIER      reduce using rule 89 (iteration_statement -> for_expression_statement .)
    MINUS           reduce using rule 89 (iteration_statement -> for_expression_statement .)
    NOT             reduce using rule 89 (iteration_statement -> for_expression_statement .)
    INC             reduce using rule 89 (iteration_statement -> for_expression_statement .)
    DEC             reduce using rule 89 (iteration_statement -> for_expression_statement .)
    INT_LITERAL     reduce using rule 89 (iteration_statement -> for_expression_statement .)
    FLOAT_LITERAL   reduce using rule 89 (iteration_statement -> for_expression_statement .)
    CHAR_LITERAL    reduce using rule 89 (iteration_statement -> for_expression_statement .)
    STRING_LITERAL  reduce using rule 89 (iteration_statement -> for_expression_statement .)
    LPAREN          reduce using rule 89 (iteration_statement -> for_expression_statement .)
    ELSE            reduce using rule 89 (iteration_statement -> for_expression_statement .)


state 126

    (90) iteration_statement -> for_var_declaration .

    RBRACE          reduce using rule 90 (iteration_statement -> for_var_declaration .)
    LBRACE          reduce using rule 90 (iteration_statement -> for_var_declaration .)
    IF              reduce using rule 90 (iteration_statement -> for_var_declaration .)
    WHILE           reduce using rule 90 (iteration_statement -> for_var_declaration .)
    RETURN          reduce using rule 90 (iteration_statement -> for_var_declaration .)
    CONTINUE        reduce using rule 90 (iteration_statement -> for_var_declaration .)
    BREAK           reduce using rule 90 (iteration_statement -> for_var_declaration .)
    FOR             reduce using rule 90 (iteration_statement -> for_var_declaration .)
    INT             reduce using rule 90 (iteration_statement -> for_var_declaration .)
    FLOAT           reduce using rule 90 (iteration_statement -> for_var_declaration .)
    CHAR            reduce using rule 90 (iteration_statement -> for_var_declaration .)
    VOID            reduce using rule 90 (iteration_statement -> for_var_declaration .)
    IDENTIFIER      reduce using rule 90 (iteration_statement -> for_var_declaration .)
    MINUS           reduce using rule 90 (iteration_statement -> for_var_declaration .)
    NOT             reduce using rule 90 (iteration_statement -> for_var_declaration .)
    INC             reduce using rule 90 (iteration_statement -> for_var_declaration .)
    DEC             reduce using rule 90 (iteration_statement -> for_var_declaration .)
    INT_LITERAL     reduce using rule 90 (iteration_statement -> for_var_declaration .)
    FLOAT_LITERAL   reduce using rule 90 (iteration_statement -> for_var_declaration .)
    CHAR_LITERAL    reduce using rule 90 (iteration_statement -> for_var_declaration .)
    STRING_LITERAL  reduce using rule 90 (iteration_statement -> for_var_declaration .)
    LPAREN          reduce using rule 90 (iteration_statement -> for_var_declaration .)
    ELSE            reduce using rule 90 (iteration_statement -> for_var_declaration .)


state 127

    (93) return_statement -> RETURN . expression SEMICOLON
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 145
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 128

    (94) continue_statement -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 146


state 129

    (95) break_statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 147


state 130

    (14) array_declaration -> type_specifier . IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (15) array_declaration -> type_specifier . IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (16) array_declaration -> type_specifier . IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (17) array_declaration -> type_specifier . IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (18) array_declaration -> type_specifier . IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (11) var_direct_declaration -> type_specifier . IDENTIFIER SEMICOLON
    (12) var_pointer_declaration -> type_specifier . TIMES IDENTIFIER SEMICOLON
    (13) var_declaration_init -> type_specifier . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 148
    TIMES           shift and go to state 18


state 131

    (91) for_expression_statement -> FOR . LPAREN expression_statement expression_statement expression RPAREN statement
    (92) for_var_declaration -> FOR . LPAREN var_declaration expression_statement expression RPAREN statement

    LPAREN          shift and go to state 149


state 132

    (81) function_call -> IDENTIFIER LPAREN argument_list RPAREN .

    RBRACKET        reduce using rule 81 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    PLUS            reduce using rule 81 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 81 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 81 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    DIVIDE          reduce using rule 81 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    MOD             reduce using rule 81 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    EQ              reduce using rule 81 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    NEQ             reduce using rule 81 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    LT              reduce using rule 81 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    GT              reduce using rule 81 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    LTE             reduce using rule 81 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    GTE             reduce using rule 81 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    AND             reduce using rule 81 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    OR              reduce using rule 81 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 81 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 81 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 81 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACE          reduce using rule 81 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)


state 133

    (83) argument_list -> argument_list COMMA . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 150
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 134

    (82) array_access -> IDENTIFIER LBRACKET expression RBRACKET .

    ASSIGN          reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    MOD             reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    EQ              reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    NEQ             reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    LT              reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    GT              reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    LTE             reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    GTE             reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    AND             reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    OR              reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    RBRACE          reduce using rule 82 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)


state 135

    (15) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE . array_list RBRACE SEMICOLON
    (23) array_list -> . array_list COMMA expression
    (24) array_list -> . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 138
    array_list                     shift and go to state 151
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 136

    (17) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL . SEMICOLON

    SEMICOLON       shift and go to state 152


state 137

    (16) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list . RBRACE SEMICOLON
    (23) array_list -> array_list . COMMA expression

    RBRACE          shift and go to state 153
    COMMA           shift and go to state 154


state 138

    (24) array_list -> expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACE          reduce using rule 24 (array_list -> expression .)
    COMMA           reduce using rule 24 (array_list -> expression .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 139

    (18) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .

    INT             reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    FLOAT           reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    CHAR            reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    VOID            reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    $end            reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    RBRACE          reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    LBRACE          reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    IF              reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    WHILE           reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    RETURN          reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    CONTINUE        reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    BREAK           reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    FOR             reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    IDENTIFIER      reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    MINUS           reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    NOT             reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    INC             reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    DEC             reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    INT_LITERAL     reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    CHAR_LITERAL    reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    STRING_LITERAL  reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    LPAREN          reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    ELSE            reduce using rule 18 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)


state 140

    (34) compound_statement -> LBRACE statement_list RBRACE .

    INT             reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    FLOAT           reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    CHAR            reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    VOID            reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    $end            reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    IF              reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    CONTINUE        reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    BREAK           reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    FOR             reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    IDENTIFIER      reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    MINUS           reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    NOT             reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    INC             reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    DEC             reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    INT_LITERAL     reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    FLOAT_LITERAL   reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    CHAR_LITERAL    reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    STRING_LITERAL  reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)
    ELSE            reduce using rule 34 (compound_statement -> LBRACE statement_list RBRACE .)


state 141

    (35) statement_list -> statement_list statement .

    RBRACE          reduce using rule 35 (statement_list -> statement_list statement .)
    LBRACE          reduce using rule 35 (statement_list -> statement_list statement .)
    IF              reduce using rule 35 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 35 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 35 (statement_list -> statement_list statement .)
    CONTINUE        reduce using rule 35 (statement_list -> statement_list statement .)
    BREAK           reduce using rule 35 (statement_list -> statement_list statement .)
    FOR             reduce using rule 35 (statement_list -> statement_list statement .)
    INT             reduce using rule 35 (statement_list -> statement_list statement .)
    FLOAT           reduce using rule 35 (statement_list -> statement_list statement .)
    CHAR            reduce using rule 35 (statement_list -> statement_list statement .)
    VOID            reduce using rule 35 (statement_list -> statement_list statement .)
    IDENTIFIER      reduce using rule 35 (statement_list -> statement_list statement .)
    MINUS           reduce using rule 35 (statement_list -> statement_list statement .)
    NOT             reduce using rule 35 (statement_list -> statement_list statement .)
    INC             reduce using rule 35 (statement_list -> statement_list statement .)
    DEC             reduce using rule 35 (statement_list -> statement_list statement .)
    INT_LITERAL     reduce using rule 35 (statement_list -> statement_list statement .)
    FLOAT_LITERAL   reduce using rule 35 (statement_list -> statement_list statement .)
    CHAR_LITERAL    reduce using rule 35 (statement_list -> statement_list statement .)
    STRING_LITERAL  reduce using rule 35 (statement_list -> statement_list statement .)
    LPAREN          reduce using rule 35 (statement_list -> statement_list statement .)


state 142

    (47) expression_statement -> expression SEMICOLON .

    RBRACE          reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    LBRACE          reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    IF              reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    WHILE           reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    RETURN          reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    CONTINUE        reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    BREAK           reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    FOR             reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    INT             reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    FLOAT           reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    CHAR            reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    VOID            reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    MINUS           reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    NOT             reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    INC             reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    DEC             reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    INT_LITERAL     reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    CHAR_LITERAL    reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    STRING_LITERAL  reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    LPAREN          reduce using rule 47 (expression_statement -> expression SEMICOLON .)
    ELSE            reduce using rule 47 (expression_statement -> expression SEMICOLON .)


state 143

    (86) selection_statement -> IF LPAREN . expression RPAREN statement
    (87) selection_statement -> IF LPAREN . expression RPAREN statement ELSE statement
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 155
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 144

    (88) iteration_statement -> WHILE LPAREN . expression RPAREN statement
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 156
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 145

    (93) return_statement -> RETURN expression . SEMICOLON
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    SEMICOLON       shift and go to state 157
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 146

    (94) continue_statement -> CONTINUE SEMICOLON .

    RBRACE          reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    LBRACE          reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    IF              reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    INT             reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    CHAR            reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    VOID            reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    IDENTIFIER      reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    MINUS           reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    NOT             reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    INC             reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    DEC             reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    INT_LITERAL     reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    CHAR_LITERAL    reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    STRING_LITERAL  reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 94 (continue_statement -> CONTINUE SEMICOLON .)


state 147

    (95) break_statement -> BREAK SEMICOLON .

    RBRACE          reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    IF              reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    RETURN          reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    FOR             reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    INT             reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    CHAR            reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    VOID            reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    IDENTIFIER      reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    MINUS           reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    NOT             reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    INC             reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    DEC             reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    INT_LITERAL     reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    CHAR_LITERAL    reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    STRING_LITERAL  reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 95 (break_statement -> BREAK SEMICOLON .)
    ELSE            reduce using rule 95 (break_statement -> BREAK SEMICOLON .)


state 148

    (14) array_declaration -> type_specifier IDENTIFIER . LBRACKET expression RBRACKET SEMICOLON
    (15) array_declaration -> type_specifier IDENTIFIER . LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (16) array_declaration -> type_specifier IDENTIFIER . LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (17) array_declaration -> type_specifier IDENTIFIER . LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (18) array_declaration -> type_specifier IDENTIFIER . LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (11) var_direct_declaration -> type_specifier IDENTIFIER . SEMICOLON
    (13) var_declaration_init -> type_specifier IDENTIFIER . ASSIGN expression SEMICOLON

    LBRACKET        shift and go to state 21
    SEMICOLON       shift and go to state 20
    ASSIGN          shift and go to state 22


state 149

    (91) for_expression_statement -> FOR LPAREN . expression_statement expression_statement expression RPAREN statement
    (92) for_var_declaration -> FOR LPAREN . var_declaration expression_statement expression RPAREN statement
    (47) expression_statement -> . expression SEMICOLON
    (8) var_declaration -> . var_direct_declaration
    (9) var_declaration -> . var_pointer_declaration
    (10) var_declaration -> . var_declaration_init
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (11) var_direct_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (12) var_pointer_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (13) var_declaration_init -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN
    (19) type_specifier -> . INT
    (20) type_specifier -> . FLOAT
    (21) type_specifier -> . CHAR
    (22) type_specifier -> . VOID

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    CHAR            shift and go to state 14
    VOID            shift and go to state 15

    expression_statement           shift and go to state 158
    expression                     shift and go to state 122
    var_declaration                shift and go to state 159
    var_direct_declaration         shift and go to state 8
    var_pointer_declaration        shift and go to state 9
    var_declaration_init           shift and go to state 10
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37
    type_specifier                 shift and go to state 160

state 150

    (83) argument_list -> argument_list COMMA expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RPAREN          reduce using rule 83 (argument_list -> argument_list COMMA expression .)
    COMMA           reduce using rule 83 (argument_list -> argument_list COMMA expression .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 151

    (15) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list . RBRACE SEMICOLON
    (23) array_list -> array_list . COMMA expression

    RBRACE          shift and go to state 161
    COMMA           shift and go to state 154


state 152

    (17) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .

    INT             reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    FLOAT           reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    CHAR            reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    VOID            reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    $end            reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    RBRACE          reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    LBRACE          reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    IF              reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    WHILE           reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    RETURN          reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    CONTINUE        reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    BREAK           reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    FOR             reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    IDENTIFIER      reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    MINUS           reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    NOT             reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    INC             reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    DEC             reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    INT_LITERAL     reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    CHAR_LITERAL    reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    STRING_LITERAL  reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    LPAREN          reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)
    ELSE            reduce using rule 17 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON .)


state 153

    (16) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 162


state 154

    (23) array_list -> array_list COMMA . expression
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 163
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 155

    (86) selection_statement -> IF LPAREN expression . RPAREN statement
    (87) selection_statement -> IF LPAREN expression . RPAREN statement ELSE statement
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RPAREN          shift and go to state 164
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 156

    (88) iteration_statement -> WHILE LPAREN expression . RPAREN statement
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RPAREN          shift and go to state 165
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 157

    (93) return_statement -> RETURN expression SEMICOLON .

    RBRACE          reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    LBRACE          reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    CONTINUE        reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    BREAK           reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    INT             reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    FLOAT           reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    CHAR            reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    VOID            reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    MINUS           reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    NOT             reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    INC             reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    DEC             reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    INT_LITERAL     reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    CHAR_LITERAL    reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    STRING_LITERAL  reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    LPAREN          reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 93 (return_statement -> RETURN expression SEMICOLON .)


state 158

    (91) for_expression_statement -> FOR LPAREN expression_statement . expression_statement expression RPAREN statement
    (47) expression_statement -> . expression SEMICOLON
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression_statement           shift and go to state 166
    expression                     shift and go to state 122
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 159

    (92) for_var_declaration -> FOR LPAREN var_declaration . expression_statement expression RPAREN statement
    (47) expression_statement -> . expression SEMICOLON
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression_statement           shift and go to state 167
    expression                     shift and go to state 122
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 160

    (11) var_direct_declaration -> type_specifier . IDENTIFIER SEMICOLON
    (12) var_pointer_declaration -> type_specifier . TIMES IDENTIFIER SEMICOLON
    (13) var_declaration_init -> type_specifier . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 168
    TIMES           shift and go to state 18


state 161

    (15) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 169


state 162

    (16) array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .

    INT             reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    FLOAT           reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    CHAR            reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    VOID            reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    $end            reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    RBRACE          reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    LBRACE          reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    IF              reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    WHILE           reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    RETURN          reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    CONTINUE        reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    BREAK           reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    FOR             reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    IDENTIFIER      reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    MINUS           reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    NOT             reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    INC             reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    DEC             reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    INT_LITERAL     reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    CHAR_LITERAL    reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    STRING_LITERAL  reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    LPAREN          reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    ELSE            reduce using rule 16 (array_declaration -> type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)


state 163

    (23) array_list -> array_list COMMA expression .
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RBRACE          reduce using rule 23 (array_list -> array_list COMMA expression .)
    COMMA           reduce using rule 23 (array_list -> array_list COMMA expression .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 164

    (86) selection_statement -> IF LPAREN expression RPAREN . statement
    (87) selection_statement -> IF LPAREN expression RPAREN . statement ELSE statement
    (37) statement -> . expression_statement
    (38) statement -> . compound_statement
    (39) statement -> . selection_statement
    (40) statement -> . iteration_statement
    (41) statement -> . return_statement
    (42) statement -> . continue_statement
    (43) statement -> . break_statement
    (44) statement -> . var_declaration
    (45) statement -> . array_declaration
    (46) statement -> . empty
    (47) expression_statement -> . expression SEMICOLON
    (34) compound_statement -> . LBRACE statement_list RBRACE
    (86) selection_statement -> . IF LPAREN expression RPAREN statement
    (87) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (88) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (89) iteration_statement -> . for_expression_statement
    (90) iteration_statement -> . for_var_declaration
    (93) return_statement -> . RETURN expression SEMICOLON
    (94) continue_statement -> . CONTINUE SEMICOLON
    (95) break_statement -> . BREAK SEMICOLON
    (8) var_declaration -> . var_direct_declaration
    (9) var_declaration -> . var_pointer_declaration
    (10) var_declaration -> . var_declaration_init
    (14) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (15) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (16) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (17) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (18) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (33) empty -> .
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (91) for_expression_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
    (92) for_var_declaration -> . FOR LPAREN var_declaration expression_statement expression RPAREN statement
    (11) var_direct_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (12) var_pointer_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (13) var_declaration_init -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (19) type_specifier -> . INT
    (20) type_specifier -> . FLOAT
    (21) type_specifier -> . CHAR
    (22) type_specifier -> . VOID
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for FLOAT_LITERAL resolved as shift
  ! shift/reduce conflict for CHAR_LITERAL resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 83
    IF              shift and go to state 123
    WHILE           shift and go to state 124
    RETURN          shift and go to state 127
    CONTINUE        shift and go to state 128
    BREAK           shift and go to state 129
    ELSE            reduce using rule 33 (empty -> .)
    RBRACE          reduce using rule 33 (empty -> .)
    FOR             shift and go to state 131
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    CHAR            shift and go to state 14
    VOID            shift and go to state 15
    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

  ! LBRACE          [ reduce using rule 33 (empty -> .) ]
  ! IF              [ reduce using rule 33 (empty -> .) ]
  ! WHILE           [ reduce using rule 33 (empty -> .) ]
  ! RETURN          [ reduce using rule 33 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 33 (empty -> .) ]
  ! BREAK           [ reduce using rule 33 (empty -> .) ]
  ! FOR             [ reduce using rule 33 (empty -> .) ]
  ! INT             [ reduce using rule 33 (empty -> .) ]
  ! FLOAT           [ reduce using rule 33 (empty -> .) ]
  ! CHAR            [ reduce using rule 33 (empty -> .) ]
  ! VOID            [ reduce using rule 33 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 33 (empty -> .) ]
  ! MINUS           [ reduce using rule 33 (empty -> .) ]
  ! NOT             [ reduce using rule 33 (empty -> .) ]
  ! INC             [ reduce using rule 33 (empty -> .) ]
  ! DEC             [ reduce using rule 33 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 33 (empty -> .) ]
  ! FLOAT_LITERAL   [ reduce using rule 33 (empty -> .) ]
  ! CHAR_LITERAL    [ reduce using rule 33 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 33 (empty -> .) ]
  ! LPAREN          [ reduce using rule 33 (empty -> .) ]

    expression                     shift and go to state 122
    statement                      shift and go to state 170
    expression_statement           shift and go to state 112
    compound_statement             shift and go to state 113
    selection_statement            shift and go to state 114
    iteration_statement            shift and go to state 115
    return_statement               shift and go to state 116
    continue_statement             shift and go to state 117
    break_statement                shift and go to state 118
    var_declaration                shift and go to state 119
    array_declaration              shift and go to state 120
    empty                          shift and go to state 121
    for_expression_statement       shift and go to state 125
    for_var_declaration            shift and go to state 126
    var_direct_declaration         shift and go to state 8
    var_pointer_declaration        shift and go to state 9
    var_declaration_init           shift and go to state 10
    type_specifier                 shift and go to state 130
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 165

    (88) iteration_statement -> WHILE LPAREN expression RPAREN . statement
    (37) statement -> . expression_statement
    (38) statement -> . compound_statement
    (39) statement -> . selection_statement
    (40) statement -> . iteration_statement
    (41) statement -> . return_statement
    (42) statement -> . continue_statement
    (43) statement -> . break_statement
    (44) statement -> . var_declaration
    (45) statement -> . array_declaration
    (46) statement -> . empty
    (47) expression_statement -> . expression SEMICOLON
    (34) compound_statement -> . LBRACE statement_list RBRACE
    (86) selection_statement -> . IF LPAREN expression RPAREN statement
    (87) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (88) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (89) iteration_statement -> . for_expression_statement
    (90) iteration_statement -> . for_var_declaration
    (93) return_statement -> . RETURN expression SEMICOLON
    (94) continue_statement -> . CONTINUE SEMICOLON
    (95) break_statement -> . BREAK SEMICOLON
    (8) var_declaration -> . var_direct_declaration
    (9) var_declaration -> . var_pointer_declaration
    (10) var_declaration -> . var_declaration_init
    (14) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (15) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (16) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (17) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (18) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (33) empty -> .
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (91) for_expression_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
    (92) for_var_declaration -> . FOR LPAREN var_declaration expression_statement expression RPAREN statement
    (11) var_direct_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (12) var_pointer_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (13) var_declaration_init -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (19) type_specifier -> . INT
    (20) type_specifier -> . FLOAT
    (21) type_specifier -> . CHAR
    (22) type_specifier -> . VOID
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for FLOAT_LITERAL resolved as shift
  ! shift/reduce conflict for CHAR_LITERAL resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 83
    IF              shift and go to state 123
    WHILE           shift and go to state 124
    RETURN          shift and go to state 127
    CONTINUE        shift and go to state 128
    BREAK           shift and go to state 129
    ELSE            reduce using rule 33 (empty -> .)
    RBRACE          reduce using rule 33 (empty -> .)
    FOR             shift and go to state 131
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    CHAR            shift and go to state 14
    VOID            shift and go to state 15
    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

  ! LBRACE          [ reduce using rule 33 (empty -> .) ]
  ! IF              [ reduce using rule 33 (empty -> .) ]
  ! WHILE           [ reduce using rule 33 (empty -> .) ]
  ! RETURN          [ reduce using rule 33 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 33 (empty -> .) ]
  ! BREAK           [ reduce using rule 33 (empty -> .) ]
  ! FOR             [ reduce using rule 33 (empty -> .) ]
  ! INT             [ reduce using rule 33 (empty -> .) ]
  ! FLOAT           [ reduce using rule 33 (empty -> .) ]
  ! CHAR            [ reduce using rule 33 (empty -> .) ]
  ! VOID            [ reduce using rule 33 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 33 (empty -> .) ]
  ! MINUS           [ reduce using rule 33 (empty -> .) ]
  ! NOT             [ reduce using rule 33 (empty -> .) ]
  ! INC             [ reduce using rule 33 (empty -> .) ]
  ! DEC             [ reduce using rule 33 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 33 (empty -> .) ]
  ! FLOAT_LITERAL   [ reduce using rule 33 (empty -> .) ]
  ! CHAR_LITERAL    [ reduce using rule 33 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 33 (empty -> .) ]
  ! LPAREN          [ reduce using rule 33 (empty -> .) ]

    expression                     shift and go to state 122
    statement                      shift and go to state 171
    expression_statement           shift and go to state 112
    compound_statement             shift and go to state 113
    selection_statement            shift and go to state 114
    iteration_statement            shift and go to state 115
    return_statement               shift and go to state 116
    continue_statement             shift and go to state 117
    break_statement                shift and go to state 118
    var_declaration                shift and go to state 119
    array_declaration              shift and go to state 120
    empty                          shift and go to state 121
    for_expression_statement       shift and go to state 125
    for_var_declaration            shift and go to state 126
    var_direct_declaration         shift and go to state 8
    var_pointer_declaration        shift and go to state 9
    var_declaration_init           shift and go to state 10
    type_specifier                 shift and go to state 130
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 166

    (91) for_expression_statement -> FOR LPAREN expression_statement expression_statement . expression RPAREN statement
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 172
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 167

    (92) for_var_declaration -> FOR LPAREN var_declaration expression_statement . expression RPAREN statement
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

    expression                     shift and go to state 173
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 168

    (11) var_direct_declaration -> type_specifier IDENTIFIER . SEMICOLON
    (13) var_declaration_init -> type_specifier IDENTIFIER . ASSIGN expression SEMICOLON

    SEMICOLON       shift and go to state 20
    ASSIGN          shift and go to state 22


state 169

    (15) array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .

    INT             reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    FLOAT           reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    CHAR            reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    VOID            reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    $end            reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    RBRACE          reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    LBRACE          reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    IF              reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    WHILE           reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    RETURN          reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    CONTINUE        reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    BREAK           reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    FOR             reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    IDENTIFIER      reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    MINUS           reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    NOT             reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    INC             reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    DEC             reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    INT_LITERAL     reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    CHAR_LITERAL    reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    STRING_LITERAL  reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    LPAREN          reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)
    ELSE            reduce using rule 15 (array_declaration -> type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON .)


state 170

    (86) selection_statement -> IF LPAREN expression RPAREN statement .
    (87) selection_statement -> IF LPAREN expression RPAREN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    RBRACE          reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    LBRACE          reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    IF              reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    WHILE           reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    RETURN          reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    CONTINUE        reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    BREAK           reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    FOR             reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    INT             reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    FLOAT           reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    CHAR            reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    VOID            reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    IDENTIFIER      reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    MINUS           reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    NOT             reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    INC             reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    DEC             reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    INT_LITERAL     reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    FLOAT_LITERAL   reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    CHAR_LITERAL    reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    STRING_LITERAL  reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    LPAREN          reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .)
    ELSE            shift and go to state 174

  ! ELSE            [ reduce using rule 86 (selection_statement -> IF LPAREN expression RPAREN statement .) ]


state 171

    (88) iteration_statement -> WHILE LPAREN expression RPAREN statement .

    RBRACE          reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    LBRACE          reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    IF              reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    WHILE           reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    RETURN          reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    CONTINUE        reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    BREAK           reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    FOR             reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    INT             reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    FLOAT           reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    CHAR            reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    VOID            reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    IDENTIFIER      reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    MINUS           reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    NOT             reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    INC             reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    DEC             reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    INT_LITERAL     reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    FLOAT_LITERAL   reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    CHAR_LITERAL    reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    STRING_LITERAL  reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    LPAREN          reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    ELSE            reduce using rule 88 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)


state 172

    (91) for_expression_statement -> FOR LPAREN expression_statement expression_statement expression . RPAREN statement
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RPAREN          shift and go to state 175
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 173

    (92) for_var_declaration -> FOR LPAREN var_declaration expression_statement expression . RPAREN statement
    (56) binary_expression -> expression . PLUS expression
    (57) binary_expression -> expression . MINUS expression
    (58) binary_expression -> expression . TIMES expression
    (59) binary_expression -> expression . DIVIDE expression
    (60) binary_expression -> expression . MOD expression
    (61) binary_expression -> expression . EQ expression
    (62) binary_expression -> expression . NEQ expression
    (63) binary_expression -> expression . LT expression
    (64) binary_expression -> expression . GT expression
    (65) binary_expression -> expression . LTE expression
    (66) binary_expression -> expression . GTE expression
    (67) binary_expression -> expression . AND expression
    (68) binary_expression -> expression . OR expression

    RPAREN          shift and go to state 176
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64
    LT              shift and go to state 65
    GT              shift and go to state 66
    LTE             shift and go to state 67
    GTE             shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 174

    (87) selection_statement -> IF LPAREN expression RPAREN statement ELSE . statement
    (37) statement -> . expression_statement
    (38) statement -> . compound_statement
    (39) statement -> . selection_statement
    (40) statement -> . iteration_statement
    (41) statement -> . return_statement
    (42) statement -> . continue_statement
    (43) statement -> . break_statement
    (44) statement -> . var_declaration
    (45) statement -> . array_declaration
    (46) statement -> . empty
    (47) expression_statement -> . expression SEMICOLON
    (34) compound_statement -> . LBRACE statement_list RBRACE
    (86) selection_statement -> . IF LPAREN expression RPAREN statement
    (87) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (88) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (89) iteration_statement -> . for_expression_statement
    (90) iteration_statement -> . for_var_declaration
    (93) return_statement -> . RETURN expression SEMICOLON
    (94) continue_statement -> . CONTINUE SEMICOLON
    (95) break_statement -> . BREAK SEMICOLON
    (8) var_declaration -> . var_direct_declaration
    (9) var_declaration -> . var_pointer_declaration
    (10) var_declaration -> . var_declaration_init
    (14) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (15) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (16) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (17) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (18) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (33) empty -> .
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (91) for_expression_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
    (92) for_var_declaration -> . FOR LPAREN var_declaration expression_statement expression RPAREN statement
    (11) var_direct_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (12) var_pointer_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (13) var_declaration_init -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (19) type_specifier -> . INT
    (20) type_specifier -> . FLOAT
    (21) type_specifier -> . CHAR
    (22) type_specifier -> . VOID
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for FLOAT_LITERAL resolved as shift
  ! shift/reduce conflict for CHAR_LITERAL resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 83
    IF              shift and go to state 123
    WHILE           shift and go to state 124
    RETURN          shift and go to state 127
    CONTINUE        shift and go to state 128
    BREAK           shift and go to state 129
    ELSE            reduce using rule 33 (empty -> .)
    RBRACE          reduce using rule 33 (empty -> .)
    FOR             shift and go to state 131
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    CHAR            shift and go to state 14
    VOID            shift and go to state 15
    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

  ! LBRACE          [ reduce using rule 33 (empty -> .) ]
  ! IF              [ reduce using rule 33 (empty -> .) ]
  ! WHILE           [ reduce using rule 33 (empty -> .) ]
  ! RETURN          [ reduce using rule 33 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 33 (empty -> .) ]
  ! BREAK           [ reduce using rule 33 (empty -> .) ]
  ! FOR             [ reduce using rule 33 (empty -> .) ]
  ! INT             [ reduce using rule 33 (empty -> .) ]
  ! FLOAT           [ reduce using rule 33 (empty -> .) ]
  ! CHAR            [ reduce using rule 33 (empty -> .) ]
  ! VOID            [ reduce using rule 33 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 33 (empty -> .) ]
  ! MINUS           [ reduce using rule 33 (empty -> .) ]
  ! NOT             [ reduce using rule 33 (empty -> .) ]
  ! INC             [ reduce using rule 33 (empty -> .) ]
  ! DEC             [ reduce using rule 33 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 33 (empty -> .) ]
  ! FLOAT_LITERAL   [ reduce using rule 33 (empty -> .) ]
  ! CHAR_LITERAL    [ reduce using rule 33 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 33 (empty -> .) ]
  ! LPAREN          [ reduce using rule 33 (empty -> .) ]

    expression                     shift and go to state 122
    statement                      shift and go to state 177
    expression_statement           shift and go to state 112
    compound_statement             shift and go to state 113
    selection_statement            shift and go to state 114
    iteration_statement            shift and go to state 115
    return_statement               shift and go to state 116
    continue_statement             shift and go to state 117
    break_statement                shift and go to state 118
    var_declaration                shift and go to state 119
    array_declaration              shift and go to state 120
    empty                          shift and go to state 121
    for_expression_statement       shift and go to state 125
    for_var_declaration            shift and go to state 126
    var_direct_declaration         shift and go to state 8
    var_pointer_declaration        shift and go to state 9
    var_declaration_init           shift and go to state 10
    type_specifier                 shift and go to state 130
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 175

    (91) for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN . statement
    (37) statement -> . expression_statement
    (38) statement -> . compound_statement
    (39) statement -> . selection_statement
    (40) statement -> . iteration_statement
    (41) statement -> . return_statement
    (42) statement -> . continue_statement
    (43) statement -> . break_statement
    (44) statement -> . var_declaration
    (45) statement -> . array_declaration
    (46) statement -> . empty
    (47) expression_statement -> . expression SEMICOLON
    (34) compound_statement -> . LBRACE statement_list RBRACE
    (86) selection_statement -> . IF LPAREN expression RPAREN statement
    (87) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (88) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (89) iteration_statement -> . for_expression_statement
    (90) iteration_statement -> . for_var_declaration
    (93) return_statement -> . RETURN expression SEMICOLON
    (94) continue_statement -> . CONTINUE SEMICOLON
    (95) break_statement -> . BREAK SEMICOLON
    (8) var_declaration -> . var_direct_declaration
    (9) var_declaration -> . var_pointer_declaration
    (10) var_declaration -> . var_declaration_init
    (14) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (15) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (16) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (17) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (18) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (33) empty -> .
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (91) for_expression_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
    (92) for_var_declaration -> . FOR LPAREN var_declaration expression_statement expression RPAREN statement
    (11) var_direct_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (12) var_pointer_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (13) var_declaration_init -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (19) type_specifier -> . INT
    (20) type_specifier -> . FLOAT
    (21) type_specifier -> . CHAR
    (22) type_specifier -> . VOID
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for FLOAT_LITERAL resolved as shift
  ! shift/reduce conflict for CHAR_LITERAL resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 83
    IF              shift and go to state 123
    WHILE           shift and go to state 124
    RETURN          shift and go to state 127
    CONTINUE        shift and go to state 128
    BREAK           shift and go to state 129
    ELSE            reduce using rule 33 (empty -> .)
    RBRACE          reduce using rule 33 (empty -> .)
    FOR             shift and go to state 131
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    CHAR            shift and go to state 14
    VOID            shift and go to state 15
    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

  ! LBRACE          [ reduce using rule 33 (empty -> .) ]
  ! IF              [ reduce using rule 33 (empty -> .) ]
  ! WHILE           [ reduce using rule 33 (empty -> .) ]
  ! RETURN          [ reduce using rule 33 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 33 (empty -> .) ]
  ! BREAK           [ reduce using rule 33 (empty -> .) ]
  ! FOR             [ reduce using rule 33 (empty -> .) ]
  ! INT             [ reduce using rule 33 (empty -> .) ]
  ! FLOAT           [ reduce using rule 33 (empty -> .) ]
  ! CHAR            [ reduce using rule 33 (empty -> .) ]
  ! VOID            [ reduce using rule 33 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 33 (empty -> .) ]
  ! MINUS           [ reduce using rule 33 (empty -> .) ]
  ! NOT             [ reduce using rule 33 (empty -> .) ]
  ! INC             [ reduce using rule 33 (empty -> .) ]
  ! DEC             [ reduce using rule 33 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 33 (empty -> .) ]
  ! FLOAT_LITERAL   [ reduce using rule 33 (empty -> .) ]
  ! CHAR_LITERAL    [ reduce using rule 33 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 33 (empty -> .) ]
  ! LPAREN          [ reduce using rule 33 (empty -> .) ]

    expression_statement           shift and go to state 112
    expression                     shift and go to state 122
    statement                      shift and go to state 178
    compound_statement             shift and go to state 113
    selection_statement            shift and go to state 114
    iteration_statement            shift and go to state 115
    return_statement               shift and go to state 116
    continue_statement             shift and go to state 117
    break_statement                shift and go to state 118
    var_declaration                shift and go to state 119
    array_declaration              shift and go to state 120
    empty                          shift and go to state 121
    for_expression_statement       shift and go to state 125
    for_var_declaration            shift and go to state 126
    var_direct_declaration         shift and go to state 8
    var_pointer_declaration        shift and go to state 9
    var_declaration_init           shift and go to state 10
    type_specifier                 shift and go to state 130
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 176

    (92) for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN . statement
    (37) statement -> . expression_statement
    (38) statement -> . compound_statement
    (39) statement -> . selection_statement
    (40) statement -> . iteration_statement
    (41) statement -> . return_statement
    (42) statement -> . continue_statement
    (43) statement -> . break_statement
    (44) statement -> . var_declaration
    (45) statement -> . array_declaration
    (46) statement -> . empty
    (47) expression_statement -> . expression SEMICOLON
    (34) compound_statement -> . LBRACE statement_list RBRACE
    (86) selection_statement -> . IF LPAREN expression RPAREN statement
    (87) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (88) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (89) iteration_statement -> . for_expression_statement
    (90) iteration_statement -> . for_var_declaration
    (93) return_statement -> . RETURN expression SEMICOLON
    (94) continue_statement -> . CONTINUE SEMICOLON
    (95) break_statement -> . BREAK SEMICOLON
    (8) var_declaration -> . var_direct_declaration
    (9) var_declaration -> . var_pointer_declaration
    (10) var_declaration -> . var_declaration_init
    (14) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET SEMICOLON
    (15) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (16) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE array_list RBRACE SEMICOLON
    (17) array_declaration -> . type_specifier IDENTIFIER LBRACKET expression RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (18) array_declaration -> . type_specifier IDENTIFIER LBRACKET RBRACKET ASSIGN STRING_LITERAL SEMICOLON
    (33) empty -> .
    (48) expression -> . assignment_expression
    (49) expression -> . binary_expression
    (50) expression -> . unary_expression
    (51) expression -> . function_call
    (52) expression -> . array_access
    (53) expression -> . term
    (91) for_expression_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
    (92) for_var_declaration -> . FOR LPAREN var_declaration expression_statement expression RPAREN statement
    (11) var_direct_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (12) var_pointer_declaration -> . type_specifier TIMES IDENTIFIER SEMICOLON
    (13) var_declaration_init -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (19) type_specifier -> . INT
    (20) type_specifier -> . FLOAT
    (21) type_specifier -> . CHAR
    (22) type_specifier -> . VOID
    (54) assignment_expression -> . IDENTIFIER ASSIGN expression
    (55) assignment_expression -> . array_access ASSIGN expression
    (56) binary_expression -> . expression PLUS expression
    (57) binary_expression -> . expression MINUS expression
    (58) binary_expression -> . expression TIMES expression
    (59) binary_expression -> . expression DIVIDE expression
    (60) binary_expression -> . expression MOD expression
    (61) binary_expression -> . expression EQ expression
    (62) binary_expression -> . expression NEQ expression
    (63) binary_expression -> . expression LT expression
    (64) binary_expression -> . expression GT expression
    (65) binary_expression -> . expression LTE expression
    (66) binary_expression -> . expression GTE expression
    (67) binary_expression -> . expression AND expression
    (68) binary_expression -> . expression OR expression
    (69) unary_expression -> . MINUS expression
    (70) unary_expression -> . NOT expression
    (71) unary_expression -> . INC IDENTIFIER
    (72) unary_expression -> . DEC IDENTIFIER
    (73) unary_expression -> . IDENTIFIER INC
    (74) unary_expression -> . IDENTIFIER DEC
    (81) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (82) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (75) term -> . IDENTIFIER
    (76) term -> . INT_LITERAL
    (77) term -> . FLOAT_LITERAL
    (78) term -> . CHAR_LITERAL
    (79) term -> . STRING_LITERAL
    (80) term -> . LPAREN expression RPAREN

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for FLOAT_LITERAL resolved as shift
  ! shift/reduce conflict for CHAR_LITERAL resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 83
    IF              shift and go to state 123
    WHILE           shift and go to state 124
    RETURN          shift and go to state 127
    CONTINUE        shift and go to state 128
    BREAK           shift and go to state 129
    ELSE            reduce using rule 33 (empty -> .)
    RBRACE          reduce using rule 33 (empty -> .)
    FOR             shift and go to state 131
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    CHAR            shift and go to state 14
    VOID            shift and go to state 15
    IDENTIFIER      shift and go to state 28
    MINUS           shift and go to state 38
    NOT             shift and go to state 39
    INC             shift and go to state 40
    DEC             shift and go to state 41
    INT_LITERAL     shift and go to state 43
    FLOAT_LITERAL   shift and go to state 44
    CHAR_LITERAL    shift and go to state 45
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 42

  ! LBRACE          [ reduce using rule 33 (empty -> .) ]
  ! IF              [ reduce using rule 33 (empty -> .) ]
  ! WHILE           [ reduce using rule 33 (empty -> .) ]
  ! RETURN          [ reduce using rule 33 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 33 (empty -> .) ]
  ! BREAK           [ reduce using rule 33 (empty -> .) ]
  ! FOR             [ reduce using rule 33 (empty -> .) ]
  ! INT             [ reduce using rule 33 (empty -> .) ]
  ! FLOAT           [ reduce using rule 33 (empty -> .) ]
  ! CHAR            [ reduce using rule 33 (empty -> .) ]
  ! VOID            [ reduce using rule 33 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 33 (empty -> .) ]
  ! MINUS           [ reduce using rule 33 (empty -> .) ]
  ! NOT             [ reduce using rule 33 (empty -> .) ]
  ! INC             [ reduce using rule 33 (empty -> .) ]
  ! DEC             [ reduce using rule 33 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 33 (empty -> .) ]
  ! FLOAT_LITERAL   [ reduce using rule 33 (empty -> .) ]
  ! CHAR_LITERAL    [ reduce using rule 33 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 33 (empty -> .) ]
  ! LPAREN          [ reduce using rule 33 (empty -> .) ]

    var_declaration                shift and go to state 119
    expression_statement           shift and go to state 112
    expression                     shift and go to state 122
    statement                      shift and go to state 179
    compound_statement             shift and go to state 113
    selection_statement            shift and go to state 114
    iteration_statement            shift and go to state 115
    return_statement               shift and go to state 116
    continue_statement             shift and go to state 117
    break_statement                shift and go to state 118
    array_declaration              shift and go to state 120
    empty                          shift and go to state 121
    for_expression_statement       shift and go to state 125
    for_var_declaration            shift and go to state 126
    var_direct_declaration         shift and go to state 8
    var_pointer_declaration        shift and go to state 9
    var_declaration_init           shift and go to state 10
    type_specifier                 shift and go to state 130
    assignment_expression          shift and go to state 32
    binary_expression              shift and go to state 33
    unary_expression               shift and go to state 34
    function_call                  shift and go to state 35
    array_access                   shift and go to state 36
    term                           shift and go to state 37

state 177

    (87) selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .

    RBRACE          reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    LBRACE          reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    IF              reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    WHILE           reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    RETURN          reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    CONTINUE        reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    BREAK           reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    FOR             reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    INT             reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    FLOAT           reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    CHAR            reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    VOID            reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    IDENTIFIER      reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    MINUS           reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    NOT             reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    INC             reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    DEC             reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    INT_LITERAL     reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    FLOAT_LITERAL   reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    CHAR_LITERAL    reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    STRING_LITERAL  reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    LPAREN          reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    ELSE            reduce using rule 87 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)


state 178

    (91) for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .

    RBRACE          reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    LBRACE          reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    IF              reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    WHILE           reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    RETURN          reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    CONTINUE        reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    BREAK           reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    FOR             reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    INT             reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    FLOAT           reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    CHAR            reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    VOID            reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    IDENTIFIER      reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    MINUS           reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    NOT             reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    INC             reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    DEC             reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    INT_LITERAL     reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    FLOAT_LITERAL   reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    CHAR_LITERAL    reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    STRING_LITERAL  reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    LPAREN          reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    ELSE            reduce using rule 91 (for_expression_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)


state 179

    (92) for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .

    RBRACE          reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    LBRACE          reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    IF              reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    WHILE           reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    RETURN          reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    CONTINUE        reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    BREAK           reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    FOR             reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    INT             reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    FLOAT           reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    CHAR            reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    VOID            reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    IDENTIFIER      reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    MINUS           reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    NOT             reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    INC             reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    DEC             reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    INT_LITERAL     reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    FLOAT_LITERAL   reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    CHAR_LITERAL    reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    STRING_LITERAL  reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    LPAREN          reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)
    ELSE            reduce using rule 92 (for_var_declaration -> FOR LPAREN var_declaration expression_statement expression RPAREN statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACE in state 83 resolved as shift
WARNING: shift/reduce conflict for IF in state 83 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 83 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 83 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 83 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 83 resolved as shift
WARNING: shift/reduce conflict for FOR in state 83 resolved as shift
WARNING: shift/reduce conflict for INT in state 83 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 83 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 83 resolved as shift
WARNING: shift/reduce conflict for VOID in state 83 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 83 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 83 resolved as shift
WARNING: shift/reduce conflict for NOT in state 83 resolved as shift
WARNING: shift/reduce conflict for INC in state 83 resolved as shift
WARNING: shift/reduce conflict for DEC in state 83 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 83 resolved as shift
WARNING: shift/reduce conflict for FLOAT_LITERAL in state 83 resolved as shift
WARNING: shift/reduce conflict for CHAR_LITERAL in state 83 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 83 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 83 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 85 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 85 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 85 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 85 resolved as shift
WARNING: shift/reduce conflict for MOD in state 85 resolved as shift
WARNING: shift/reduce conflict for EQ in state 85 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 85 resolved as shift
WARNING: shift/reduce conflict for LT in state 85 resolved as shift
WARNING: shift/reduce conflict for GT in state 85 resolved as shift
WARNING: shift/reduce conflict for LTE in state 85 resolved as shift
WARNING: shift/reduce conflict for GTE in state 85 resolved as shift
WARNING: shift/reduce conflict for AND in state 85 resolved as shift
WARNING: shift/reduce conflict for OR in state 85 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 107 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 107 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 107 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 107 resolved as shift
WARNING: shift/reduce conflict for MOD in state 107 resolved as shift
WARNING: shift/reduce conflict for EQ in state 107 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 107 resolved as shift
WARNING: shift/reduce conflict for LT in state 107 resolved as shift
WARNING: shift/reduce conflict for GT in state 107 resolved as shift
WARNING: shift/reduce conflict for LTE in state 107 resolved as shift
WARNING: shift/reduce conflict for GTE in state 107 resolved as shift
WARNING: shift/reduce conflict for AND in state 107 resolved as shift
WARNING: shift/reduce conflict for OR in state 107 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 110 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 110 resolved as shift
WARNING: shift/reduce conflict for IF in state 110 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 110 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 110 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 110 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 110 resolved as shift
WARNING: shift/reduce conflict for FOR in state 110 resolved as shift
WARNING: shift/reduce conflict for INT in state 110 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 110 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 110 resolved as shift
WARNING: shift/reduce conflict for VOID in state 110 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 110 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 110 resolved as shift
WARNING: shift/reduce conflict for NOT in state 110 resolved as shift
WARNING: shift/reduce conflict for INC in state 110 resolved as shift
WARNING: shift/reduce conflict for DEC in state 110 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 110 resolved as shift
WARNING: shift/reduce conflict for FLOAT_LITERAL in state 110 resolved as shift
WARNING: shift/reduce conflict for CHAR_LITERAL in state 110 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 110 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 110 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 164 resolved as shift
WARNING: shift/reduce conflict for IF in state 164 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 164 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 164 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 164 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 164 resolved as shift
WARNING: shift/reduce conflict for FOR in state 164 resolved as shift
WARNING: shift/reduce conflict for INT in state 164 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 164 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 164 resolved as shift
WARNING: shift/reduce conflict for VOID in state 164 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 164 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 164 resolved as shift
WARNING: shift/reduce conflict for NOT in state 164 resolved as shift
WARNING: shift/reduce conflict for INC in state 164 resolved as shift
WARNING: shift/reduce conflict for DEC in state 164 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 164 resolved as shift
WARNING: shift/reduce conflict for FLOAT_LITERAL in state 164 resolved as shift
WARNING: shift/reduce conflict for CHAR_LITERAL in state 164 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 164 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 164 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 165 resolved as shift
WARNING: shift/reduce conflict for IF in state 165 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 165 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 165 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 165 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 165 resolved as shift
WARNING: shift/reduce conflict for FOR in state 165 resolved as shift
WARNING: shift/reduce conflict for INT in state 165 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 165 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 165 resolved as shift
WARNING: shift/reduce conflict for VOID in state 165 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 165 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 165 resolved as shift
WARNING: shift/reduce conflict for NOT in state 165 resolved as shift
WARNING: shift/reduce conflict for INC in state 165 resolved as shift
WARNING: shift/reduce conflict for DEC in state 165 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 165 resolved as shift
WARNING: shift/reduce conflict for FLOAT_LITERAL in state 165 resolved as shift
WARNING: shift/reduce conflict for CHAR_LITERAL in state 165 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 165 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 165 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 170 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 174 resolved as shift
WARNING: shift/reduce conflict for IF in state 174 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 174 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 174 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 174 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 174 resolved as shift
WARNING: shift/reduce conflict for FOR in state 174 resolved as shift
WARNING: shift/reduce conflict for INT in state 174 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 174 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 174 resolved as shift
WARNING: shift/reduce conflict for VOID in state 174 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 174 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 174 resolved as shift
WARNING: shift/reduce conflict for NOT in state 174 resolved as shift
WARNING: shift/reduce conflict for INC in state 174 resolved as shift
WARNING: shift/reduce conflict for DEC in state 174 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 174 resolved as shift
WARNING: shift/reduce conflict for FLOAT_LITERAL in state 174 resolved as shift
WARNING: shift/reduce conflict for CHAR_LITERAL in state 174 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 174 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 174 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 175 resolved as shift
WARNING: shift/reduce conflict for IF in state 175 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 175 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 175 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 175 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 175 resolved as shift
WARNING: shift/reduce conflict for FOR in state 175 resolved as shift
WARNING: shift/reduce conflict for INT in state 175 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 175 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 175 resolved as shift
WARNING: shift/reduce conflict for VOID in state 175 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 175 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 175 resolved as shift
WARNING: shift/reduce conflict for NOT in state 175 resolved as shift
WARNING: shift/reduce conflict for INC in state 175 resolved as shift
WARNING: shift/reduce conflict for DEC in state 175 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 175 resolved as shift
WARNING: shift/reduce conflict for FLOAT_LITERAL in state 175 resolved as shift
WARNING: shift/reduce conflict for CHAR_LITERAL in state 175 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 175 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 175 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 176 resolved as shift
WARNING: shift/reduce conflict for IF in state 176 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 176 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 176 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 176 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 176 resolved as shift
WARNING: shift/reduce conflict for FOR in state 176 resolved as shift
WARNING: shift/reduce conflict for INT in state 176 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 176 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 176 resolved as shift
WARNING: shift/reduce conflict for VOID in state 176 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 176 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 176 resolved as shift
WARNING: shift/reduce conflict for NOT in state 176 resolved as shift
WARNING: shift/reduce conflict for INC in state 176 resolved as shift
WARNING: shift/reduce conflict for DEC in state 176 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 176 resolved as shift
WARNING: shift/reduce conflict for FLOAT_LITERAL in state 176 resolved as shift
WARNING: shift/reduce conflict for CHAR_LITERAL in state 176 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 176 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 176 resolved as shift
