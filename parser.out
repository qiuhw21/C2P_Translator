Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    CHAR_LITERAL
    COMMENT_MULTI
    COMMENT_SINGLE
    CONTINUE
    FLOAT_LITERAL
    LBRACKET
    RBRACKET
    STRING_LITERAL

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration_list
Rule 2     declaration_list -> declaration_list declaration
Rule 3     declaration_list -> declaration
Rule 4     declaration -> var_declaration
Rule 5     declaration -> function_declaration
Rule 6     var_declaration -> type_specifier IDENTIFIER SEMICOLON
Rule 7     var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON
Rule 8     type_specifier -> INT
Rule 9     type_specifier -> FLOAT
Rule 10    type_specifier -> CHAR
Rule 11    type_specifier -> VOID
Rule 12    function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement
Rule 13    param_list -> param_list COMMA param
Rule 14    param_list -> param
Rule 15    param_list -> empty
Rule 16    param -> type_specifier IDENTIFIER
Rule 17    empty -> <empty>
Rule 18    compound_statement -> LBRACE statement_list RBRACE
Rule 19    statement_list -> statement_list statement
Rule 20    statement_list -> statement
Rule 21    statement -> expression_statement
Rule 22    statement -> compound_statement
Rule 23    statement -> selection_statement
Rule 24    statement -> iteration_statement
Rule 25    statement -> return_statement
Rule 26    statement -> var_declaration
Rule 27    statement -> empty
Rule 28    expression_statement -> expression SEMICOLON
Rule 29    expression -> assignment_expression
Rule 30    expression -> binary_expression
Rule 31    expression -> unary_expression
Rule 32    expression -> term
Rule 33    assignment_expression -> IDENTIFIER ASSIGN expression
Rule 34    binary_expression -> expression PLUS expression
Rule 35    binary_expression -> expression MINUS expression
Rule 36    binary_expression -> expression TIMES expression
Rule 37    binary_expression -> expression DIVIDE expression
Rule 38    binary_expression -> expression MOD expression
Rule 39    binary_expression -> expression EQ expression
Rule 40    binary_expression -> expression NEQ expression
Rule 41    binary_expression -> expression LT expression
Rule 42    binary_expression -> expression GT expression
Rule 43    binary_expression -> expression LTE expression
Rule 44    binary_expression -> expression GTE expression
Rule 45    binary_expression -> expression AND expression
Rule 46    binary_expression -> expression OR expression
Rule 47    unary_expression -> MINUS expression
Rule 48    unary_expression -> NOT expression
Rule 49    unary_expression -> INC IDENTIFIER
Rule 50    unary_expression -> DEC IDENTIFIER
Rule 51    term -> IDENTIFIER
Rule 52    term -> INT_LITERAL
Rule 53    term -> LPAREN expression RPAREN
Rule 54    term -> function_call
Rule 55    function_call -> IDENTIFIER LPAREN argument_list RPAREN
Rule 56    argument_list -> argument_list COMMA expression
Rule 57    argument_list -> expression
Rule 58    argument_list -> empty
Rule 59    selection_statement -> IF LPAREN expression RPAREN compound_statement
Rule 60    selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement
Rule 61    iteration_statement -> WHILE LPAREN expression RPAREN statement
Rule 62    iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement
Rule 63    return_statement -> RETURN expression SEMICOLON

Terminals, with rules where they appear

AND                  : 45
ASSIGN               : 7 33
BREAK                : 
CHAR                 : 10
CHAR_LITERAL         : 
COMMA                : 13 56
COMMENT_MULTI        : 
COMMENT_SINGLE       : 
CONTINUE             : 
DEC                  : 50
DIVIDE               : 37
ELSE                 : 60
EQ                   : 39
FLOAT                : 9
FLOAT_LITERAL        : 
FOR                  : 62
GT                   : 42
GTE                  : 44
IDENTIFIER           : 6 7 12 16 33 49 50 51 55
IF                   : 59 60
INC                  : 49
INT                  : 8
INT_LITERAL          : 52
LBRACE               : 18
LBRACKET             : 
LPAREN               : 12 53 55 59 60 61 62
LT                   : 41
LTE                  : 43
MINUS                : 35 47
MOD                  : 38
NEQ                  : 40
NOT                  : 48
OR                   : 46
PLUS                 : 34
RBRACE               : 18
RBRACKET             : 
RETURN               : 63
RPAREN               : 12 53 55 59 60 61 62
SEMICOLON            : 6 7 28 63
STRING_LITERAL       : 
TIMES                : 36
VOID                 : 11
WHILE                : 61
error                : 

Nonterminals, with rules where they appear

argument_list        : 55 56
assignment_expression : 29
binary_expression    : 30
compound_statement   : 12 22 59 60 60
declaration          : 2 3
declaration_list     : 1 2
empty                : 15 27 58
expression           : 7 28 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 48 53 56 57 59 60 61 62 63
expression_statement : 21 62 62
function_call        : 54
function_declaration : 5
iteration_statement  : 24
param                : 13 14
param_list           : 12 13
program              : 0
return_statement     : 25
selection_statement  : 23
statement            : 19 20 61 62
statement_list       : 18 19
term                 : 32
type_specifier       : 6 7 12 16
unary_expression     : 31
var_declaration      : 4 26

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration_list
    (2) declaration_list -> . declaration_list declaration
    (3) declaration_list -> . declaration
    (4) declaration -> . var_declaration
    (5) declaration -> . function_declaration
    (6) var_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (7) var_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (12) function_declaration -> . type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement
    (8) type_specifier -> . INT
    (9) type_specifier -> . FLOAT
    (10) type_specifier -> . CHAR
    (11) type_specifier -> . VOID

    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    CHAR            shift and go to state 9
    VOID            shift and go to state 10

    program                        shift and go to state 1
    declaration_list               shift and go to state 2
    declaration                    shift and go to state 3
    var_declaration                shift and go to state 4
    function_declaration           shift and go to state 5
    type_specifier                 shift and go to state 6

state 1

    (0) S' -> program .



state 2

    (1) program -> declaration_list .
    (2) declaration_list -> declaration_list . declaration
    (4) declaration -> . var_declaration
    (5) declaration -> . function_declaration
    (6) var_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (7) var_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (12) function_declaration -> . type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement
    (8) type_specifier -> . INT
    (9) type_specifier -> . FLOAT
    (10) type_specifier -> . CHAR
    (11) type_specifier -> . VOID

    $end            reduce using rule 1 (program -> declaration_list .)
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    CHAR            shift and go to state 9
    VOID            shift and go to state 10

    declaration                    shift and go to state 11
    var_declaration                shift and go to state 4
    function_declaration           shift and go to state 5
    type_specifier                 shift and go to state 6

state 3

    (3) declaration_list -> declaration .

    INT             reduce using rule 3 (declaration_list -> declaration .)
    FLOAT           reduce using rule 3 (declaration_list -> declaration .)
    CHAR            reduce using rule 3 (declaration_list -> declaration .)
    VOID            reduce using rule 3 (declaration_list -> declaration .)
    $end            reduce using rule 3 (declaration_list -> declaration .)


state 4

    (4) declaration -> var_declaration .

    INT             reduce using rule 4 (declaration -> var_declaration .)
    FLOAT           reduce using rule 4 (declaration -> var_declaration .)
    CHAR            reduce using rule 4 (declaration -> var_declaration .)
    VOID            reduce using rule 4 (declaration -> var_declaration .)
    $end            reduce using rule 4 (declaration -> var_declaration .)


state 5

    (5) declaration -> function_declaration .

    INT             reduce using rule 5 (declaration -> function_declaration .)
    FLOAT           reduce using rule 5 (declaration -> function_declaration .)
    CHAR            reduce using rule 5 (declaration -> function_declaration .)
    VOID            reduce using rule 5 (declaration -> function_declaration .)
    $end            reduce using rule 5 (declaration -> function_declaration .)


state 6

    (6) var_declaration -> type_specifier . IDENTIFIER SEMICOLON
    (7) var_declaration -> type_specifier . IDENTIFIER ASSIGN expression SEMICOLON
    (12) function_declaration -> type_specifier . IDENTIFIER LPAREN param_list RPAREN compound_statement

    IDENTIFIER      shift and go to state 12


state 7

    (8) type_specifier -> INT .

    IDENTIFIER      reduce using rule 8 (type_specifier -> INT .)


state 8

    (9) type_specifier -> FLOAT .

    IDENTIFIER      reduce using rule 9 (type_specifier -> FLOAT .)


state 9

    (10) type_specifier -> CHAR .

    IDENTIFIER      reduce using rule 10 (type_specifier -> CHAR .)


state 10

    (11) type_specifier -> VOID .

    IDENTIFIER      reduce using rule 11 (type_specifier -> VOID .)


state 11

    (2) declaration_list -> declaration_list declaration .

    INT             reduce using rule 2 (declaration_list -> declaration_list declaration .)
    FLOAT           reduce using rule 2 (declaration_list -> declaration_list declaration .)
    CHAR            reduce using rule 2 (declaration_list -> declaration_list declaration .)
    VOID            reduce using rule 2 (declaration_list -> declaration_list declaration .)
    $end            reduce using rule 2 (declaration_list -> declaration_list declaration .)


state 12

    (6) var_declaration -> type_specifier IDENTIFIER . SEMICOLON
    (7) var_declaration -> type_specifier IDENTIFIER . ASSIGN expression SEMICOLON
    (12) function_declaration -> type_specifier IDENTIFIER . LPAREN param_list RPAREN compound_statement

    SEMICOLON       shift and go to state 13
    ASSIGN          shift and go to state 14
    LPAREN          shift and go to state 15


state 13

    (6) var_declaration -> type_specifier IDENTIFIER SEMICOLON .

    INT             reduce using rule 6 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 6 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    CHAR            reduce using rule 6 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 6 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    $end            reduce using rule 6 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    RBRACE          reduce using rule 6 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    LBRACE          reduce using rule 6 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    IF              reduce using rule 6 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 6 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 6 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    RETURN          reduce using rule 6 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 6 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 6 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 6 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    INC             reduce using rule 6 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    DEC             reduce using rule 6 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    INT_LITERAL     reduce using rule 6 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    LPAREN          reduce using rule 6 (var_declaration -> type_specifier IDENTIFIER SEMICOLON .)


state 14

    (7) var_declaration -> type_specifier IDENTIFIER ASSIGN . expression SEMICOLON
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 17
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 15

    (12) function_declaration -> type_specifier IDENTIFIER LPAREN . param_list RPAREN compound_statement
    (13) param_list -> . param_list COMMA param
    (14) param_list -> . param
    (15) param_list -> . empty
    (16) param -> . type_specifier IDENTIFIER
    (17) empty -> .
    (8) type_specifier -> . INT
    (9) type_specifier -> . FLOAT
    (10) type_specifier -> . CHAR
    (11) type_specifier -> . VOID

    RPAREN          reduce using rule 17 (empty -> .)
    COMMA           reduce using rule 17 (empty -> .)
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    CHAR            shift and go to state 9
    VOID            shift and go to state 10

    type_specifier                 shift and go to state 29
    param_list                     shift and go to state 30
    param                          shift and go to state 31
    empty                          shift and go to state 32

state 16

    (33) assignment_expression -> IDENTIFIER . ASSIGN expression
    (51) term -> IDENTIFIER .
    (55) function_call -> IDENTIFIER . LPAREN argument_list RPAREN

    ASSIGN          shift and go to state 33
    SEMICOLON       reduce using rule 51 (term -> IDENTIFIER .)
    PLUS            reduce using rule 51 (term -> IDENTIFIER .)
    MINUS           reduce using rule 51 (term -> IDENTIFIER .)
    TIMES           reduce using rule 51 (term -> IDENTIFIER .)
    DIVIDE          reduce using rule 51 (term -> IDENTIFIER .)
    MOD             reduce using rule 51 (term -> IDENTIFIER .)
    EQ              reduce using rule 51 (term -> IDENTIFIER .)
    NEQ             reduce using rule 51 (term -> IDENTIFIER .)
    LT              reduce using rule 51 (term -> IDENTIFIER .)
    GT              reduce using rule 51 (term -> IDENTIFIER .)
    LTE             reduce using rule 51 (term -> IDENTIFIER .)
    GTE             reduce using rule 51 (term -> IDENTIFIER .)
    AND             reduce using rule 51 (term -> IDENTIFIER .)
    OR              reduce using rule 51 (term -> IDENTIFIER .)
    RPAREN          reduce using rule 51 (term -> IDENTIFIER .)
    COMMA           reduce using rule 51 (term -> IDENTIFIER .)
    LPAREN          shift and go to state 34


state 17

    (7) var_declaration -> type_specifier IDENTIFIER ASSIGN expression . SEMICOLON
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    SEMICOLON       shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    EQ              shift and go to state 41
    NEQ             shift and go to state 42
    LT              shift and go to state 43
    GT              shift and go to state 44
    LTE             shift and go to state 45
    GTE             shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 18

    (29) expression -> assignment_expression .

    SEMICOLON       reduce using rule 29 (expression -> assignment_expression .)
    PLUS            reduce using rule 29 (expression -> assignment_expression .)
    MINUS           reduce using rule 29 (expression -> assignment_expression .)
    TIMES           reduce using rule 29 (expression -> assignment_expression .)
    DIVIDE          reduce using rule 29 (expression -> assignment_expression .)
    MOD             reduce using rule 29 (expression -> assignment_expression .)
    EQ              reduce using rule 29 (expression -> assignment_expression .)
    NEQ             reduce using rule 29 (expression -> assignment_expression .)
    LT              reduce using rule 29 (expression -> assignment_expression .)
    GT              reduce using rule 29 (expression -> assignment_expression .)
    LTE             reduce using rule 29 (expression -> assignment_expression .)
    GTE             reduce using rule 29 (expression -> assignment_expression .)
    AND             reduce using rule 29 (expression -> assignment_expression .)
    OR              reduce using rule 29 (expression -> assignment_expression .)
    RPAREN          reduce using rule 29 (expression -> assignment_expression .)
    COMMA           reduce using rule 29 (expression -> assignment_expression .)


state 19

    (30) expression -> binary_expression .

    SEMICOLON       reduce using rule 30 (expression -> binary_expression .)
    PLUS            reduce using rule 30 (expression -> binary_expression .)
    MINUS           reduce using rule 30 (expression -> binary_expression .)
    TIMES           reduce using rule 30 (expression -> binary_expression .)
    DIVIDE          reduce using rule 30 (expression -> binary_expression .)
    MOD             reduce using rule 30 (expression -> binary_expression .)
    EQ              reduce using rule 30 (expression -> binary_expression .)
    NEQ             reduce using rule 30 (expression -> binary_expression .)
    LT              reduce using rule 30 (expression -> binary_expression .)
    GT              reduce using rule 30 (expression -> binary_expression .)
    LTE             reduce using rule 30 (expression -> binary_expression .)
    GTE             reduce using rule 30 (expression -> binary_expression .)
    AND             reduce using rule 30 (expression -> binary_expression .)
    OR              reduce using rule 30 (expression -> binary_expression .)
    RPAREN          reduce using rule 30 (expression -> binary_expression .)
    COMMA           reduce using rule 30 (expression -> binary_expression .)


state 20

    (31) expression -> unary_expression .

    SEMICOLON       reduce using rule 31 (expression -> unary_expression .)
    PLUS            reduce using rule 31 (expression -> unary_expression .)
    MINUS           reduce using rule 31 (expression -> unary_expression .)
    TIMES           reduce using rule 31 (expression -> unary_expression .)
    DIVIDE          reduce using rule 31 (expression -> unary_expression .)
    MOD             reduce using rule 31 (expression -> unary_expression .)
    EQ              reduce using rule 31 (expression -> unary_expression .)
    NEQ             reduce using rule 31 (expression -> unary_expression .)
    LT              reduce using rule 31 (expression -> unary_expression .)
    GT              reduce using rule 31 (expression -> unary_expression .)
    LTE             reduce using rule 31 (expression -> unary_expression .)
    GTE             reduce using rule 31 (expression -> unary_expression .)
    AND             reduce using rule 31 (expression -> unary_expression .)
    OR              reduce using rule 31 (expression -> unary_expression .)
    RPAREN          reduce using rule 31 (expression -> unary_expression .)
    COMMA           reduce using rule 31 (expression -> unary_expression .)


state 21

    (32) expression -> term .

    SEMICOLON       reduce using rule 32 (expression -> term .)
    PLUS            reduce using rule 32 (expression -> term .)
    MINUS           reduce using rule 32 (expression -> term .)
    TIMES           reduce using rule 32 (expression -> term .)
    DIVIDE          reduce using rule 32 (expression -> term .)
    MOD             reduce using rule 32 (expression -> term .)
    EQ              reduce using rule 32 (expression -> term .)
    NEQ             reduce using rule 32 (expression -> term .)
    LT              reduce using rule 32 (expression -> term .)
    GT              reduce using rule 32 (expression -> term .)
    LTE             reduce using rule 32 (expression -> term .)
    GTE             reduce using rule 32 (expression -> term .)
    AND             reduce using rule 32 (expression -> term .)
    OR              reduce using rule 32 (expression -> term .)
    RPAREN          reduce using rule 32 (expression -> term .)
    COMMA           reduce using rule 32 (expression -> term .)


state 22

    (47) unary_expression -> MINUS . expression
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 49
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 23

    (48) unary_expression -> NOT . expression
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 50
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 24

    (49) unary_expression -> INC . IDENTIFIER

    IDENTIFIER      shift and go to state 51


state 25

    (50) unary_expression -> DEC . IDENTIFIER

    IDENTIFIER      shift and go to state 52


state 26

    (52) term -> INT_LITERAL .

    SEMICOLON       reduce using rule 52 (term -> INT_LITERAL .)
    PLUS            reduce using rule 52 (term -> INT_LITERAL .)
    MINUS           reduce using rule 52 (term -> INT_LITERAL .)
    TIMES           reduce using rule 52 (term -> INT_LITERAL .)
    DIVIDE          reduce using rule 52 (term -> INT_LITERAL .)
    MOD             reduce using rule 52 (term -> INT_LITERAL .)
    EQ              reduce using rule 52 (term -> INT_LITERAL .)
    NEQ             reduce using rule 52 (term -> INT_LITERAL .)
    LT              reduce using rule 52 (term -> INT_LITERAL .)
    GT              reduce using rule 52 (term -> INT_LITERAL .)
    LTE             reduce using rule 52 (term -> INT_LITERAL .)
    GTE             reduce using rule 52 (term -> INT_LITERAL .)
    AND             reduce using rule 52 (term -> INT_LITERAL .)
    OR              reduce using rule 52 (term -> INT_LITERAL .)
    RPAREN          reduce using rule 52 (term -> INT_LITERAL .)
    COMMA           reduce using rule 52 (term -> INT_LITERAL .)


state 27

    (53) term -> LPAREN . expression RPAREN
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 53
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 28

    (54) term -> function_call .

    SEMICOLON       reduce using rule 54 (term -> function_call .)
    PLUS            reduce using rule 54 (term -> function_call .)
    MINUS           reduce using rule 54 (term -> function_call .)
    TIMES           reduce using rule 54 (term -> function_call .)
    DIVIDE          reduce using rule 54 (term -> function_call .)
    MOD             reduce using rule 54 (term -> function_call .)
    EQ              reduce using rule 54 (term -> function_call .)
    NEQ             reduce using rule 54 (term -> function_call .)
    LT              reduce using rule 54 (term -> function_call .)
    GT              reduce using rule 54 (term -> function_call .)
    LTE             reduce using rule 54 (term -> function_call .)
    GTE             reduce using rule 54 (term -> function_call .)
    AND             reduce using rule 54 (term -> function_call .)
    OR              reduce using rule 54 (term -> function_call .)
    RPAREN          reduce using rule 54 (term -> function_call .)
    COMMA           reduce using rule 54 (term -> function_call .)


state 29

    (16) param -> type_specifier . IDENTIFIER

    IDENTIFIER      shift and go to state 54


state 30

    (12) function_declaration -> type_specifier IDENTIFIER LPAREN param_list . RPAREN compound_statement
    (13) param_list -> param_list . COMMA param

    RPAREN          shift and go to state 55
    COMMA           shift and go to state 56


state 31

    (14) param_list -> param .

    RPAREN          reduce using rule 14 (param_list -> param .)
    COMMA           reduce using rule 14 (param_list -> param .)


state 32

    (15) param_list -> empty .

    RPAREN          reduce using rule 15 (param_list -> empty .)
    COMMA           reduce using rule 15 (param_list -> empty .)


state 33

    (33) assignment_expression -> IDENTIFIER ASSIGN . expression
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 57
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 34

    (55) function_call -> IDENTIFIER LPAREN . argument_list RPAREN
    (56) argument_list -> . argument_list COMMA expression
    (57) argument_list -> . expression
    (58) argument_list -> . empty
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (17) empty -> .
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    RPAREN          reduce using rule 17 (empty -> .)
    COMMA           reduce using rule 17 (empty -> .)
    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    argument_list                  shift and go to state 58
    expression                     shift and go to state 59
    empty                          shift and go to state 60
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 35

    (7) var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .

    INT             reduce using rule 7 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    FLOAT           reduce using rule 7 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    CHAR            reduce using rule 7 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 7 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 7 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 7 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 7 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 7 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 7 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 7 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 7 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 7 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 7 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 7 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    INC             reduce using rule 7 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    DEC             reduce using rule 7 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    INT_LITERAL     reduce using rule 7 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 7 (var_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)


state 36

    (34) binary_expression -> expression PLUS . expression
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 61
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 37

    (35) binary_expression -> expression MINUS . expression
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 62
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 38

    (36) binary_expression -> expression TIMES . expression
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 63
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 39

    (37) binary_expression -> expression DIVIDE . expression
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 64
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 40

    (38) binary_expression -> expression MOD . expression
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 65
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 41

    (39) binary_expression -> expression EQ . expression
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 66
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 42

    (40) binary_expression -> expression NEQ . expression
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 67
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 43

    (41) binary_expression -> expression LT . expression
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 68
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 44

    (42) binary_expression -> expression GT . expression
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 69
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 45

    (43) binary_expression -> expression LTE . expression
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 70
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 46

    (44) binary_expression -> expression GTE . expression
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 71
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 47

    (45) binary_expression -> expression AND . expression
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 72
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 48

    (46) binary_expression -> expression OR . expression
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 73
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 49

    (47) unary_expression -> MINUS expression .
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 47 (unary_expression -> MINUS expression .)
    PLUS            reduce using rule 47 (unary_expression -> MINUS expression .)
    MINUS           reduce using rule 47 (unary_expression -> MINUS expression .)
    TIMES           reduce using rule 47 (unary_expression -> MINUS expression .)
    DIVIDE          reduce using rule 47 (unary_expression -> MINUS expression .)
    MOD             reduce using rule 47 (unary_expression -> MINUS expression .)
    EQ              reduce using rule 47 (unary_expression -> MINUS expression .)
    NEQ             reduce using rule 47 (unary_expression -> MINUS expression .)
    LT              reduce using rule 47 (unary_expression -> MINUS expression .)
    GT              reduce using rule 47 (unary_expression -> MINUS expression .)
    LTE             reduce using rule 47 (unary_expression -> MINUS expression .)
    GTE             reduce using rule 47 (unary_expression -> MINUS expression .)
    AND             reduce using rule 47 (unary_expression -> MINUS expression .)
    OR              reduce using rule 47 (unary_expression -> MINUS expression .)
    RPAREN          reduce using rule 47 (unary_expression -> MINUS expression .)
    COMMA           reduce using rule 47 (unary_expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! TIMES           [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 40 ]
  ! EQ              [ shift and go to state 41 ]
  ! NEQ             [ shift and go to state 42 ]
  ! LT              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! LTE             [ shift and go to state 45 ]
  ! GTE             [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 50

    (48) unary_expression -> NOT expression .
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 48 (unary_expression -> NOT expression .)
    PLUS            reduce using rule 48 (unary_expression -> NOT expression .)
    MINUS           reduce using rule 48 (unary_expression -> NOT expression .)
    TIMES           reduce using rule 48 (unary_expression -> NOT expression .)
    DIVIDE          reduce using rule 48 (unary_expression -> NOT expression .)
    MOD             reduce using rule 48 (unary_expression -> NOT expression .)
    EQ              reduce using rule 48 (unary_expression -> NOT expression .)
    NEQ             reduce using rule 48 (unary_expression -> NOT expression .)
    LT              reduce using rule 48 (unary_expression -> NOT expression .)
    GT              reduce using rule 48 (unary_expression -> NOT expression .)
    LTE             reduce using rule 48 (unary_expression -> NOT expression .)
    GTE             reduce using rule 48 (unary_expression -> NOT expression .)
    AND             reduce using rule 48 (unary_expression -> NOT expression .)
    OR              reduce using rule 48 (unary_expression -> NOT expression .)
    RPAREN          reduce using rule 48 (unary_expression -> NOT expression .)
    COMMA           reduce using rule 48 (unary_expression -> NOT expression .)

  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! TIMES           [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 40 ]
  ! EQ              [ shift and go to state 41 ]
  ! NEQ             [ shift and go to state 42 ]
  ! LT              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! LTE             [ shift and go to state 45 ]
  ! GTE             [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 51

    (49) unary_expression -> INC IDENTIFIER .

    SEMICOLON       reduce using rule 49 (unary_expression -> INC IDENTIFIER .)
    PLUS            reduce using rule 49 (unary_expression -> INC IDENTIFIER .)
    MINUS           reduce using rule 49 (unary_expression -> INC IDENTIFIER .)
    TIMES           reduce using rule 49 (unary_expression -> INC IDENTIFIER .)
    DIVIDE          reduce using rule 49 (unary_expression -> INC IDENTIFIER .)
    MOD             reduce using rule 49 (unary_expression -> INC IDENTIFIER .)
    EQ              reduce using rule 49 (unary_expression -> INC IDENTIFIER .)
    NEQ             reduce using rule 49 (unary_expression -> INC IDENTIFIER .)
    LT              reduce using rule 49 (unary_expression -> INC IDENTIFIER .)
    GT              reduce using rule 49 (unary_expression -> INC IDENTIFIER .)
    LTE             reduce using rule 49 (unary_expression -> INC IDENTIFIER .)
    GTE             reduce using rule 49 (unary_expression -> INC IDENTIFIER .)
    AND             reduce using rule 49 (unary_expression -> INC IDENTIFIER .)
    OR              reduce using rule 49 (unary_expression -> INC IDENTIFIER .)
    RPAREN          reduce using rule 49 (unary_expression -> INC IDENTIFIER .)
    COMMA           reduce using rule 49 (unary_expression -> INC IDENTIFIER .)


state 52

    (50) unary_expression -> DEC IDENTIFIER .

    SEMICOLON       reduce using rule 50 (unary_expression -> DEC IDENTIFIER .)
    PLUS            reduce using rule 50 (unary_expression -> DEC IDENTIFIER .)
    MINUS           reduce using rule 50 (unary_expression -> DEC IDENTIFIER .)
    TIMES           reduce using rule 50 (unary_expression -> DEC IDENTIFIER .)
    DIVIDE          reduce using rule 50 (unary_expression -> DEC IDENTIFIER .)
    MOD             reduce using rule 50 (unary_expression -> DEC IDENTIFIER .)
    EQ              reduce using rule 50 (unary_expression -> DEC IDENTIFIER .)
    NEQ             reduce using rule 50 (unary_expression -> DEC IDENTIFIER .)
    LT              reduce using rule 50 (unary_expression -> DEC IDENTIFIER .)
    GT              reduce using rule 50 (unary_expression -> DEC IDENTIFIER .)
    LTE             reduce using rule 50 (unary_expression -> DEC IDENTIFIER .)
    GTE             reduce using rule 50 (unary_expression -> DEC IDENTIFIER .)
    AND             reduce using rule 50 (unary_expression -> DEC IDENTIFIER .)
    OR              reduce using rule 50 (unary_expression -> DEC IDENTIFIER .)
    RPAREN          reduce using rule 50 (unary_expression -> DEC IDENTIFIER .)
    COMMA           reduce using rule 50 (unary_expression -> DEC IDENTIFIER .)


state 53

    (53) term -> LPAREN expression . RPAREN
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    RPAREN          shift and go to state 74
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    EQ              shift and go to state 41
    NEQ             shift and go to state 42
    LT              shift and go to state 43
    GT              shift and go to state 44
    LTE             shift and go to state 45
    GTE             shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 54

    (16) param -> type_specifier IDENTIFIER .

    RPAREN          reduce using rule 16 (param -> type_specifier IDENTIFIER .)
    COMMA           reduce using rule 16 (param -> type_specifier IDENTIFIER .)


state 55

    (12) function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN . compound_statement
    (18) compound_statement -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 76

    compound_statement             shift and go to state 75

state 56

    (13) param_list -> param_list COMMA . param
    (16) param -> . type_specifier IDENTIFIER
    (8) type_specifier -> . INT
    (9) type_specifier -> . FLOAT
    (10) type_specifier -> . CHAR
    (11) type_specifier -> . VOID

    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    CHAR            shift and go to state 9
    VOID            shift and go to state 10

    param                          shift and go to state 77
    type_specifier                 shift and go to state 29

state 57

    (33) assignment_expression -> IDENTIFIER ASSIGN expression .
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 33 (assignment_expression -> IDENTIFIER ASSIGN expression .)
    RPAREN          reduce using rule 33 (assignment_expression -> IDENTIFIER ASSIGN expression .)
    COMMA           reduce using rule 33 (assignment_expression -> IDENTIFIER ASSIGN expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    EQ              shift and go to state 41
    NEQ             shift and go to state 42
    LT              shift and go to state 43
    GT              shift and go to state 44
    LTE             shift and go to state 45
    GTE             shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48

  ! PLUS            [ reduce using rule 33 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 33 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! TIMES           [ reduce using rule 33 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! DIVIDE          [ reduce using rule 33 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! MOD             [ reduce using rule 33 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! EQ              [ reduce using rule 33 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! NEQ             [ reduce using rule 33 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! LT              [ reduce using rule 33 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! GT              [ reduce using rule 33 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! LTE             [ reduce using rule 33 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! GTE             [ reduce using rule 33 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! AND             [ reduce using rule 33 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]
  ! OR              [ reduce using rule 33 (assignment_expression -> IDENTIFIER ASSIGN expression .) ]


state 58

    (55) function_call -> IDENTIFIER LPAREN argument_list . RPAREN
    (56) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 78
    COMMA           shift and go to state 79


state 59

    (57) argument_list -> expression .
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    RPAREN          reduce using rule 57 (argument_list -> expression .)
    COMMA           reduce using rule 57 (argument_list -> expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    EQ              shift and go to state 41
    NEQ             shift and go to state 42
    LT              shift and go to state 43
    GT              shift and go to state 44
    LTE             shift and go to state 45
    GTE             shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 60

    (58) argument_list -> empty .

    RPAREN          reduce using rule 58 (argument_list -> empty .)
    COMMA           reduce using rule 58 (argument_list -> empty .)


state 61

    (34) binary_expression -> expression PLUS expression .
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 34 (binary_expression -> expression PLUS expression .)
    PLUS            reduce using rule 34 (binary_expression -> expression PLUS expression .)
    MINUS           reduce using rule 34 (binary_expression -> expression PLUS expression .)
    EQ              reduce using rule 34 (binary_expression -> expression PLUS expression .)
    NEQ             reduce using rule 34 (binary_expression -> expression PLUS expression .)
    LT              reduce using rule 34 (binary_expression -> expression PLUS expression .)
    GT              reduce using rule 34 (binary_expression -> expression PLUS expression .)
    LTE             reduce using rule 34 (binary_expression -> expression PLUS expression .)
    GTE             reduce using rule 34 (binary_expression -> expression PLUS expression .)
    AND             reduce using rule 34 (binary_expression -> expression PLUS expression .)
    OR              reduce using rule 34 (binary_expression -> expression PLUS expression .)
    RPAREN          reduce using rule 34 (binary_expression -> expression PLUS expression .)
    COMMA           reduce using rule 34 (binary_expression -> expression PLUS expression .)
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40

  ! TIMES           [ reduce using rule 34 (binary_expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 34 (binary_expression -> expression PLUS expression .) ]
  ! MOD             [ reduce using rule 34 (binary_expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! EQ              [ shift and go to state 41 ]
  ! NEQ             [ shift and go to state 42 ]
  ! LT              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! LTE             [ shift and go to state 45 ]
  ! GTE             [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 62

    (35) binary_expression -> expression MINUS expression .
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 35 (binary_expression -> expression MINUS expression .)
    PLUS            reduce using rule 35 (binary_expression -> expression MINUS expression .)
    MINUS           reduce using rule 35 (binary_expression -> expression MINUS expression .)
    EQ              reduce using rule 35 (binary_expression -> expression MINUS expression .)
    NEQ             reduce using rule 35 (binary_expression -> expression MINUS expression .)
    LT              reduce using rule 35 (binary_expression -> expression MINUS expression .)
    GT              reduce using rule 35 (binary_expression -> expression MINUS expression .)
    LTE             reduce using rule 35 (binary_expression -> expression MINUS expression .)
    GTE             reduce using rule 35 (binary_expression -> expression MINUS expression .)
    AND             reduce using rule 35 (binary_expression -> expression MINUS expression .)
    OR              reduce using rule 35 (binary_expression -> expression MINUS expression .)
    RPAREN          reduce using rule 35 (binary_expression -> expression MINUS expression .)
    COMMA           reduce using rule 35 (binary_expression -> expression MINUS expression .)
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40

  ! TIMES           [ reduce using rule 35 (binary_expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 35 (binary_expression -> expression MINUS expression .) ]
  ! MOD             [ reduce using rule 35 (binary_expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! EQ              [ shift and go to state 41 ]
  ! NEQ             [ shift and go to state 42 ]
  ! LT              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! LTE             [ shift and go to state 45 ]
  ! GTE             [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 63

    (36) binary_expression -> expression TIMES expression .
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 36 (binary_expression -> expression TIMES expression .)
    PLUS            reduce using rule 36 (binary_expression -> expression TIMES expression .)
    MINUS           reduce using rule 36 (binary_expression -> expression TIMES expression .)
    TIMES           reduce using rule 36 (binary_expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 36 (binary_expression -> expression TIMES expression .)
    MOD             reduce using rule 36 (binary_expression -> expression TIMES expression .)
    EQ              reduce using rule 36 (binary_expression -> expression TIMES expression .)
    NEQ             reduce using rule 36 (binary_expression -> expression TIMES expression .)
    LT              reduce using rule 36 (binary_expression -> expression TIMES expression .)
    GT              reduce using rule 36 (binary_expression -> expression TIMES expression .)
    LTE             reduce using rule 36 (binary_expression -> expression TIMES expression .)
    GTE             reduce using rule 36 (binary_expression -> expression TIMES expression .)
    AND             reduce using rule 36 (binary_expression -> expression TIMES expression .)
    OR              reduce using rule 36 (binary_expression -> expression TIMES expression .)
    RPAREN          reduce using rule 36 (binary_expression -> expression TIMES expression .)
    COMMA           reduce using rule 36 (binary_expression -> expression TIMES expression .)

  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! TIMES           [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 40 ]
  ! EQ              [ shift and go to state 41 ]
  ! NEQ             [ shift and go to state 42 ]
  ! LT              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! LTE             [ shift and go to state 45 ]
  ! GTE             [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 64

    (37) binary_expression -> expression DIVIDE expression .
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 37 (binary_expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 37 (binary_expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 37 (binary_expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 37 (binary_expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 37 (binary_expression -> expression DIVIDE expression .)
    MOD             reduce using rule 37 (binary_expression -> expression DIVIDE expression .)
    EQ              reduce using rule 37 (binary_expression -> expression DIVIDE expression .)
    NEQ             reduce using rule 37 (binary_expression -> expression DIVIDE expression .)
    LT              reduce using rule 37 (binary_expression -> expression DIVIDE expression .)
    GT              reduce using rule 37 (binary_expression -> expression DIVIDE expression .)
    LTE             reduce using rule 37 (binary_expression -> expression DIVIDE expression .)
    GTE             reduce using rule 37 (binary_expression -> expression DIVIDE expression .)
    AND             reduce using rule 37 (binary_expression -> expression DIVIDE expression .)
    OR              reduce using rule 37 (binary_expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 37 (binary_expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 37 (binary_expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! TIMES           [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 40 ]
  ! EQ              [ shift and go to state 41 ]
  ! NEQ             [ shift and go to state 42 ]
  ! LT              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! LTE             [ shift and go to state 45 ]
  ! GTE             [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 65

    (38) binary_expression -> expression MOD expression .
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 38 (binary_expression -> expression MOD expression .)
    PLUS            reduce using rule 38 (binary_expression -> expression MOD expression .)
    MINUS           reduce using rule 38 (binary_expression -> expression MOD expression .)
    TIMES           reduce using rule 38 (binary_expression -> expression MOD expression .)
    DIVIDE          reduce using rule 38 (binary_expression -> expression MOD expression .)
    MOD             reduce using rule 38 (binary_expression -> expression MOD expression .)
    EQ              reduce using rule 38 (binary_expression -> expression MOD expression .)
    NEQ             reduce using rule 38 (binary_expression -> expression MOD expression .)
    LT              reduce using rule 38 (binary_expression -> expression MOD expression .)
    GT              reduce using rule 38 (binary_expression -> expression MOD expression .)
    LTE             reduce using rule 38 (binary_expression -> expression MOD expression .)
    GTE             reduce using rule 38 (binary_expression -> expression MOD expression .)
    AND             reduce using rule 38 (binary_expression -> expression MOD expression .)
    OR              reduce using rule 38 (binary_expression -> expression MOD expression .)
    RPAREN          reduce using rule 38 (binary_expression -> expression MOD expression .)
    COMMA           reduce using rule 38 (binary_expression -> expression MOD expression .)

  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! TIMES           [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 40 ]
  ! EQ              [ shift and go to state 41 ]
  ! NEQ             [ shift and go to state 42 ]
  ! LT              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! LTE             [ shift and go to state 45 ]
  ! GTE             [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 66

    (39) binary_expression -> expression EQ expression .
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 39 (binary_expression -> expression EQ expression .)
    EQ              reduce using rule 39 (binary_expression -> expression EQ expression .)
    NEQ             reduce using rule 39 (binary_expression -> expression EQ expression .)
    AND             reduce using rule 39 (binary_expression -> expression EQ expression .)
    OR              reduce using rule 39 (binary_expression -> expression EQ expression .)
    RPAREN          reduce using rule 39 (binary_expression -> expression EQ expression .)
    COMMA           reduce using rule 39 (binary_expression -> expression EQ expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    LT              shift and go to state 43
    GT              shift and go to state 44
    LTE             shift and go to state 45
    GTE             shift and go to state 46

  ! PLUS            [ reduce using rule 39 (binary_expression -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 39 (binary_expression -> expression EQ expression .) ]
  ! TIMES           [ reduce using rule 39 (binary_expression -> expression EQ expression .) ]
  ! DIVIDE          [ reduce using rule 39 (binary_expression -> expression EQ expression .) ]
  ! MOD             [ reduce using rule 39 (binary_expression -> expression EQ expression .) ]
  ! LT              [ reduce using rule 39 (binary_expression -> expression EQ expression .) ]
  ! GT              [ reduce using rule 39 (binary_expression -> expression EQ expression .) ]
  ! LTE             [ reduce using rule 39 (binary_expression -> expression EQ expression .) ]
  ! GTE             [ reduce using rule 39 (binary_expression -> expression EQ expression .) ]
  ! EQ              [ shift and go to state 41 ]
  ! NEQ             [ shift and go to state 42 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 67

    (40) binary_expression -> expression NEQ expression .
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 40 (binary_expression -> expression NEQ expression .)
    EQ              reduce using rule 40 (binary_expression -> expression NEQ expression .)
    NEQ             reduce using rule 40 (binary_expression -> expression NEQ expression .)
    AND             reduce using rule 40 (binary_expression -> expression NEQ expression .)
    OR              reduce using rule 40 (binary_expression -> expression NEQ expression .)
    RPAREN          reduce using rule 40 (binary_expression -> expression NEQ expression .)
    COMMA           reduce using rule 40 (binary_expression -> expression NEQ expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    LT              shift and go to state 43
    GT              shift and go to state 44
    LTE             shift and go to state 45
    GTE             shift and go to state 46

  ! PLUS            [ reduce using rule 40 (binary_expression -> expression NEQ expression .) ]
  ! MINUS           [ reduce using rule 40 (binary_expression -> expression NEQ expression .) ]
  ! TIMES           [ reduce using rule 40 (binary_expression -> expression NEQ expression .) ]
  ! DIVIDE          [ reduce using rule 40 (binary_expression -> expression NEQ expression .) ]
  ! MOD             [ reduce using rule 40 (binary_expression -> expression NEQ expression .) ]
  ! LT              [ reduce using rule 40 (binary_expression -> expression NEQ expression .) ]
  ! GT              [ reduce using rule 40 (binary_expression -> expression NEQ expression .) ]
  ! LTE             [ reduce using rule 40 (binary_expression -> expression NEQ expression .) ]
  ! GTE             [ reduce using rule 40 (binary_expression -> expression NEQ expression .) ]
  ! EQ              [ shift and go to state 41 ]
  ! NEQ             [ shift and go to state 42 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 68

    (41) binary_expression -> expression LT expression .
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 41 (binary_expression -> expression LT expression .)
    EQ              reduce using rule 41 (binary_expression -> expression LT expression .)
    NEQ             reduce using rule 41 (binary_expression -> expression LT expression .)
    LT              reduce using rule 41 (binary_expression -> expression LT expression .)
    GT              reduce using rule 41 (binary_expression -> expression LT expression .)
    LTE             reduce using rule 41 (binary_expression -> expression LT expression .)
    GTE             reduce using rule 41 (binary_expression -> expression LT expression .)
    AND             reduce using rule 41 (binary_expression -> expression LT expression .)
    OR              reduce using rule 41 (binary_expression -> expression LT expression .)
    RPAREN          reduce using rule 41 (binary_expression -> expression LT expression .)
    COMMA           reduce using rule 41 (binary_expression -> expression LT expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40

  ! PLUS            [ reduce using rule 41 (binary_expression -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 41 (binary_expression -> expression LT expression .) ]
  ! TIMES           [ reduce using rule 41 (binary_expression -> expression LT expression .) ]
  ! DIVIDE          [ reduce using rule 41 (binary_expression -> expression LT expression .) ]
  ! MOD             [ reduce using rule 41 (binary_expression -> expression LT expression .) ]
  ! EQ              [ shift and go to state 41 ]
  ! NEQ             [ shift and go to state 42 ]
  ! LT              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! LTE             [ shift and go to state 45 ]
  ! GTE             [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 69

    (42) binary_expression -> expression GT expression .
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 42 (binary_expression -> expression GT expression .)
    EQ              reduce using rule 42 (binary_expression -> expression GT expression .)
    NEQ             reduce using rule 42 (binary_expression -> expression GT expression .)
    LT              reduce using rule 42 (binary_expression -> expression GT expression .)
    GT              reduce using rule 42 (binary_expression -> expression GT expression .)
    LTE             reduce using rule 42 (binary_expression -> expression GT expression .)
    GTE             reduce using rule 42 (binary_expression -> expression GT expression .)
    AND             reduce using rule 42 (binary_expression -> expression GT expression .)
    OR              reduce using rule 42 (binary_expression -> expression GT expression .)
    RPAREN          reduce using rule 42 (binary_expression -> expression GT expression .)
    COMMA           reduce using rule 42 (binary_expression -> expression GT expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40

  ! PLUS            [ reduce using rule 42 (binary_expression -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 42 (binary_expression -> expression GT expression .) ]
  ! TIMES           [ reduce using rule 42 (binary_expression -> expression GT expression .) ]
  ! DIVIDE          [ reduce using rule 42 (binary_expression -> expression GT expression .) ]
  ! MOD             [ reduce using rule 42 (binary_expression -> expression GT expression .) ]
  ! EQ              [ shift and go to state 41 ]
  ! NEQ             [ shift and go to state 42 ]
  ! LT              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! LTE             [ shift and go to state 45 ]
  ! GTE             [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 70

    (43) binary_expression -> expression LTE expression .
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 43 (binary_expression -> expression LTE expression .)
    EQ              reduce using rule 43 (binary_expression -> expression LTE expression .)
    NEQ             reduce using rule 43 (binary_expression -> expression LTE expression .)
    LT              reduce using rule 43 (binary_expression -> expression LTE expression .)
    GT              reduce using rule 43 (binary_expression -> expression LTE expression .)
    LTE             reduce using rule 43 (binary_expression -> expression LTE expression .)
    GTE             reduce using rule 43 (binary_expression -> expression LTE expression .)
    AND             reduce using rule 43 (binary_expression -> expression LTE expression .)
    OR              reduce using rule 43 (binary_expression -> expression LTE expression .)
    RPAREN          reduce using rule 43 (binary_expression -> expression LTE expression .)
    COMMA           reduce using rule 43 (binary_expression -> expression LTE expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40

  ! PLUS            [ reduce using rule 43 (binary_expression -> expression LTE expression .) ]
  ! MINUS           [ reduce using rule 43 (binary_expression -> expression LTE expression .) ]
  ! TIMES           [ reduce using rule 43 (binary_expression -> expression LTE expression .) ]
  ! DIVIDE          [ reduce using rule 43 (binary_expression -> expression LTE expression .) ]
  ! MOD             [ reduce using rule 43 (binary_expression -> expression LTE expression .) ]
  ! EQ              [ shift and go to state 41 ]
  ! NEQ             [ shift and go to state 42 ]
  ! LT              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! LTE             [ shift and go to state 45 ]
  ! GTE             [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 71

    (44) binary_expression -> expression GTE expression .
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 44 (binary_expression -> expression GTE expression .)
    EQ              reduce using rule 44 (binary_expression -> expression GTE expression .)
    NEQ             reduce using rule 44 (binary_expression -> expression GTE expression .)
    LT              reduce using rule 44 (binary_expression -> expression GTE expression .)
    GT              reduce using rule 44 (binary_expression -> expression GTE expression .)
    LTE             reduce using rule 44 (binary_expression -> expression GTE expression .)
    GTE             reduce using rule 44 (binary_expression -> expression GTE expression .)
    AND             reduce using rule 44 (binary_expression -> expression GTE expression .)
    OR              reduce using rule 44 (binary_expression -> expression GTE expression .)
    RPAREN          reduce using rule 44 (binary_expression -> expression GTE expression .)
    COMMA           reduce using rule 44 (binary_expression -> expression GTE expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40

  ! PLUS            [ reduce using rule 44 (binary_expression -> expression GTE expression .) ]
  ! MINUS           [ reduce using rule 44 (binary_expression -> expression GTE expression .) ]
  ! TIMES           [ reduce using rule 44 (binary_expression -> expression GTE expression .) ]
  ! DIVIDE          [ reduce using rule 44 (binary_expression -> expression GTE expression .) ]
  ! MOD             [ reduce using rule 44 (binary_expression -> expression GTE expression .) ]
  ! EQ              [ shift and go to state 41 ]
  ! NEQ             [ shift and go to state 42 ]
  ! LT              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! LTE             [ shift and go to state 45 ]
  ! GTE             [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 72

    (45) binary_expression -> expression AND expression .
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 45 (binary_expression -> expression AND expression .)
    AND             reduce using rule 45 (binary_expression -> expression AND expression .)
    OR              reduce using rule 45 (binary_expression -> expression AND expression .)
    RPAREN          reduce using rule 45 (binary_expression -> expression AND expression .)
    COMMA           reduce using rule 45 (binary_expression -> expression AND expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    EQ              shift and go to state 41
    NEQ             shift and go to state 42
    LT              shift and go to state 43
    GT              shift and go to state 44
    LTE             shift and go to state 45
    GTE             shift and go to state 46

  ! PLUS            [ reduce using rule 45 (binary_expression -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 45 (binary_expression -> expression AND expression .) ]
  ! TIMES           [ reduce using rule 45 (binary_expression -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 45 (binary_expression -> expression AND expression .) ]
  ! MOD             [ reduce using rule 45 (binary_expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 45 (binary_expression -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 45 (binary_expression -> expression AND expression .) ]
  ! LT              [ reduce using rule 45 (binary_expression -> expression AND expression .) ]
  ! GT              [ reduce using rule 45 (binary_expression -> expression AND expression .) ]
  ! LTE             [ reduce using rule 45 (binary_expression -> expression AND expression .) ]
  ! GTE             [ reduce using rule 45 (binary_expression -> expression AND expression .) ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 73

    (46) binary_expression -> expression OR expression .
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    SEMICOLON       reduce using rule 46 (binary_expression -> expression OR expression .)
    OR              reduce using rule 46 (binary_expression -> expression OR expression .)
    RPAREN          reduce using rule 46 (binary_expression -> expression OR expression .)
    COMMA           reduce using rule 46 (binary_expression -> expression OR expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    EQ              shift and go to state 41
    NEQ             shift and go to state 42
    LT              shift and go to state 43
    GT              shift and go to state 44
    LTE             shift and go to state 45
    GTE             shift and go to state 46
    AND             shift and go to state 47

  ! PLUS            [ reduce using rule 46 (binary_expression -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 46 (binary_expression -> expression OR expression .) ]
  ! TIMES           [ reduce using rule 46 (binary_expression -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 46 (binary_expression -> expression OR expression .) ]
  ! MOD             [ reduce using rule 46 (binary_expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 46 (binary_expression -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 46 (binary_expression -> expression OR expression .) ]
  ! LT              [ reduce using rule 46 (binary_expression -> expression OR expression .) ]
  ! GT              [ reduce using rule 46 (binary_expression -> expression OR expression .) ]
  ! LTE             [ reduce using rule 46 (binary_expression -> expression OR expression .) ]
  ! GTE             [ reduce using rule 46 (binary_expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 46 (binary_expression -> expression OR expression .) ]
  ! OR              [ shift and go to state 48 ]


state 74

    (53) term -> LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 53 (term -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 53 (term -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 53 (term -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 53 (term -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 53 (term -> LPAREN expression RPAREN .)
    MOD             reduce using rule 53 (term -> LPAREN expression RPAREN .)
    EQ              reduce using rule 53 (term -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 53 (term -> LPAREN expression RPAREN .)
    LT              reduce using rule 53 (term -> LPAREN expression RPAREN .)
    GT              reduce using rule 53 (term -> LPAREN expression RPAREN .)
    LTE             reduce using rule 53 (term -> LPAREN expression RPAREN .)
    GTE             reduce using rule 53 (term -> LPAREN expression RPAREN .)
    AND             reduce using rule 53 (term -> LPAREN expression RPAREN .)
    OR              reduce using rule 53 (term -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 53 (term -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 53 (term -> LPAREN expression RPAREN .)


state 75

    (12) function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement .

    INT             reduce using rule 12 (function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement .)
    FLOAT           reduce using rule 12 (function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement .)
    CHAR            reduce using rule 12 (function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement .)
    VOID            reduce using rule 12 (function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement .)
    $end            reduce using rule 12 (function_declaration -> type_specifier IDENTIFIER LPAREN param_list RPAREN compound_statement .)


state 76

    (18) compound_statement -> LBRACE . statement_list RBRACE
    (19) statement_list -> . statement_list statement
    (20) statement_list -> . statement
    (21) statement -> . expression_statement
    (22) statement -> . compound_statement
    (23) statement -> . selection_statement
    (24) statement -> . iteration_statement
    (25) statement -> . return_statement
    (26) statement -> . var_declaration
    (27) statement -> . empty
    (28) expression_statement -> . expression SEMICOLON
    (18) compound_statement -> . LBRACE statement_list RBRACE
    (59) selection_statement -> . IF LPAREN expression RPAREN compound_statement
    (60) selection_statement -> . IF LPAREN expression RPAREN compound_statement ELSE compound_statement
    (61) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (62) iteration_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
    (63) return_statement -> . RETURN expression SEMICOLON
    (6) var_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (7) var_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (17) empty -> .
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (8) type_specifier -> . INT
    (9) type_specifier -> . FLOAT
    (10) type_specifier -> . CHAR
    (11) type_specifier -> . VOID
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 76
    IF              shift and go to state 90
    WHILE           shift and go to state 91
    FOR             shift and go to state 92
    RETURN          shift and go to state 93
    RBRACE          reduce using rule 17 (empty -> .)
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    CHAR            shift and go to state 9
    VOID            shift and go to state 10
    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

  ! LBRACE          [ reduce using rule 17 (empty -> .) ]
  ! IF              [ reduce using rule 17 (empty -> .) ]
  ! WHILE           [ reduce using rule 17 (empty -> .) ]
  ! FOR             [ reduce using rule 17 (empty -> .) ]
  ! RETURN          [ reduce using rule 17 (empty -> .) ]
  ! INT             [ reduce using rule 17 (empty -> .) ]
  ! FLOAT           [ reduce using rule 17 (empty -> .) ]
  ! CHAR            [ reduce using rule 17 (empty -> .) ]
  ! VOID            [ reduce using rule 17 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 17 (empty -> .) ]
  ! MINUS           [ reduce using rule 17 (empty -> .) ]
  ! NOT             [ reduce using rule 17 (empty -> .) ]
  ! INC             [ reduce using rule 17 (empty -> .) ]
  ! DEC             [ reduce using rule 17 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 17 (empty -> .) ]
  ! LPAREN          [ reduce using rule 17 (empty -> .) ]

    statement_list                 shift and go to state 80
    statement                      shift and go to state 81
    expression_statement           shift and go to state 82
    compound_statement             shift and go to state 83
    selection_statement            shift and go to state 84
    iteration_statement            shift and go to state 85
    return_statement               shift and go to state 86
    var_declaration                shift and go to state 87
    empty                          shift and go to state 88
    expression                     shift and go to state 89
    type_specifier                 shift and go to state 94
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 77

    (13) param_list -> param_list COMMA param .

    RPAREN          reduce using rule 13 (param_list -> param_list COMMA param .)
    COMMA           reduce using rule 13 (param_list -> param_list COMMA param .)


state 78

    (55) function_call -> IDENTIFIER LPAREN argument_list RPAREN .

    SEMICOLON       reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    PLUS            reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    DIVIDE          reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    MOD             reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    EQ              reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    NEQ             reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    LT              reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    GT              reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    LTE             reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    GTE             reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    AND             reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    OR              reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 55 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)


state 79

    (56) argument_list -> argument_list COMMA . expression
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 95
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 80

    (18) compound_statement -> LBRACE statement_list . RBRACE
    (19) statement_list -> statement_list . statement
    (21) statement -> . expression_statement
    (22) statement -> . compound_statement
    (23) statement -> . selection_statement
    (24) statement -> . iteration_statement
    (25) statement -> . return_statement
    (26) statement -> . var_declaration
    (27) statement -> . empty
    (28) expression_statement -> . expression SEMICOLON
    (18) compound_statement -> . LBRACE statement_list RBRACE
    (59) selection_statement -> . IF LPAREN expression RPAREN compound_statement
    (60) selection_statement -> . IF LPAREN expression RPAREN compound_statement ELSE compound_statement
    (61) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (62) iteration_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
    (63) return_statement -> . RETURN expression SEMICOLON
    (6) var_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (7) var_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (17) empty -> .
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (8) type_specifier -> . INT
    (9) type_specifier -> . FLOAT
    (10) type_specifier -> . CHAR
    (11) type_specifier -> . VOID
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    RBRACE          shift and go to state 96
    LBRACE          shift and go to state 76
    IF              shift and go to state 90
    WHILE           shift and go to state 91
    FOR             shift and go to state 92
    RETURN          shift and go to state 93
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    CHAR            shift and go to state 9
    VOID            shift and go to state 10
    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

  ! RBRACE          [ reduce using rule 17 (empty -> .) ]
  ! LBRACE          [ reduce using rule 17 (empty -> .) ]
  ! IF              [ reduce using rule 17 (empty -> .) ]
  ! WHILE           [ reduce using rule 17 (empty -> .) ]
  ! FOR             [ reduce using rule 17 (empty -> .) ]
  ! RETURN          [ reduce using rule 17 (empty -> .) ]
  ! INT             [ reduce using rule 17 (empty -> .) ]
  ! FLOAT           [ reduce using rule 17 (empty -> .) ]
  ! CHAR            [ reduce using rule 17 (empty -> .) ]
  ! VOID            [ reduce using rule 17 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 17 (empty -> .) ]
  ! MINUS           [ reduce using rule 17 (empty -> .) ]
  ! NOT             [ reduce using rule 17 (empty -> .) ]
  ! INC             [ reduce using rule 17 (empty -> .) ]
  ! DEC             [ reduce using rule 17 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 17 (empty -> .) ]
  ! LPAREN          [ reduce using rule 17 (empty -> .) ]

    statement                      shift and go to state 97
    expression_statement           shift and go to state 82
    compound_statement             shift and go to state 83
    selection_statement            shift and go to state 84
    iteration_statement            shift and go to state 85
    return_statement               shift and go to state 86
    var_declaration                shift and go to state 87
    empty                          shift and go to state 88
    expression                     shift and go to state 89
    type_specifier                 shift and go to state 94
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 81

    (20) statement_list -> statement .

    RBRACE          reduce using rule 20 (statement_list -> statement .)
    LBRACE          reduce using rule 20 (statement_list -> statement .)
    IF              reduce using rule 20 (statement_list -> statement .)
    WHILE           reduce using rule 20 (statement_list -> statement .)
    FOR             reduce using rule 20 (statement_list -> statement .)
    RETURN          reduce using rule 20 (statement_list -> statement .)
    INT             reduce using rule 20 (statement_list -> statement .)
    FLOAT           reduce using rule 20 (statement_list -> statement .)
    CHAR            reduce using rule 20 (statement_list -> statement .)
    VOID            reduce using rule 20 (statement_list -> statement .)
    IDENTIFIER      reduce using rule 20 (statement_list -> statement .)
    MINUS           reduce using rule 20 (statement_list -> statement .)
    NOT             reduce using rule 20 (statement_list -> statement .)
    INC             reduce using rule 20 (statement_list -> statement .)
    DEC             reduce using rule 20 (statement_list -> statement .)
    INT_LITERAL     reduce using rule 20 (statement_list -> statement .)
    LPAREN          reduce using rule 20 (statement_list -> statement .)


state 82

    (21) statement -> expression_statement .

    RBRACE          reduce using rule 21 (statement -> expression_statement .)
    LBRACE          reduce using rule 21 (statement -> expression_statement .)
    IF              reduce using rule 21 (statement -> expression_statement .)
    WHILE           reduce using rule 21 (statement -> expression_statement .)
    FOR             reduce using rule 21 (statement -> expression_statement .)
    RETURN          reduce using rule 21 (statement -> expression_statement .)
    INT             reduce using rule 21 (statement -> expression_statement .)
    FLOAT           reduce using rule 21 (statement -> expression_statement .)
    CHAR            reduce using rule 21 (statement -> expression_statement .)
    VOID            reduce using rule 21 (statement -> expression_statement .)
    IDENTIFIER      reduce using rule 21 (statement -> expression_statement .)
    MINUS           reduce using rule 21 (statement -> expression_statement .)
    NOT             reduce using rule 21 (statement -> expression_statement .)
    INC             reduce using rule 21 (statement -> expression_statement .)
    DEC             reduce using rule 21 (statement -> expression_statement .)
    INT_LITERAL     reduce using rule 21 (statement -> expression_statement .)
    LPAREN          reduce using rule 21 (statement -> expression_statement .)


state 83

    (22) statement -> compound_statement .

    RBRACE          reduce using rule 22 (statement -> compound_statement .)
    LBRACE          reduce using rule 22 (statement -> compound_statement .)
    IF              reduce using rule 22 (statement -> compound_statement .)
    WHILE           reduce using rule 22 (statement -> compound_statement .)
    FOR             reduce using rule 22 (statement -> compound_statement .)
    RETURN          reduce using rule 22 (statement -> compound_statement .)
    INT             reduce using rule 22 (statement -> compound_statement .)
    FLOAT           reduce using rule 22 (statement -> compound_statement .)
    CHAR            reduce using rule 22 (statement -> compound_statement .)
    VOID            reduce using rule 22 (statement -> compound_statement .)
    IDENTIFIER      reduce using rule 22 (statement -> compound_statement .)
    MINUS           reduce using rule 22 (statement -> compound_statement .)
    NOT             reduce using rule 22 (statement -> compound_statement .)
    INC             reduce using rule 22 (statement -> compound_statement .)
    DEC             reduce using rule 22 (statement -> compound_statement .)
    INT_LITERAL     reduce using rule 22 (statement -> compound_statement .)
    LPAREN          reduce using rule 22 (statement -> compound_statement .)


state 84

    (23) statement -> selection_statement .

    RBRACE          reduce using rule 23 (statement -> selection_statement .)
    LBRACE          reduce using rule 23 (statement -> selection_statement .)
    IF              reduce using rule 23 (statement -> selection_statement .)
    WHILE           reduce using rule 23 (statement -> selection_statement .)
    FOR             reduce using rule 23 (statement -> selection_statement .)
    RETURN          reduce using rule 23 (statement -> selection_statement .)
    INT             reduce using rule 23 (statement -> selection_statement .)
    FLOAT           reduce using rule 23 (statement -> selection_statement .)
    CHAR            reduce using rule 23 (statement -> selection_statement .)
    VOID            reduce using rule 23 (statement -> selection_statement .)
    IDENTIFIER      reduce using rule 23 (statement -> selection_statement .)
    MINUS           reduce using rule 23 (statement -> selection_statement .)
    NOT             reduce using rule 23 (statement -> selection_statement .)
    INC             reduce using rule 23 (statement -> selection_statement .)
    DEC             reduce using rule 23 (statement -> selection_statement .)
    INT_LITERAL     reduce using rule 23 (statement -> selection_statement .)
    LPAREN          reduce using rule 23 (statement -> selection_statement .)


state 85

    (24) statement -> iteration_statement .

    RBRACE          reduce using rule 24 (statement -> iteration_statement .)
    LBRACE          reduce using rule 24 (statement -> iteration_statement .)
    IF              reduce using rule 24 (statement -> iteration_statement .)
    WHILE           reduce using rule 24 (statement -> iteration_statement .)
    FOR             reduce using rule 24 (statement -> iteration_statement .)
    RETURN          reduce using rule 24 (statement -> iteration_statement .)
    INT             reduce using rule 24 (statement -> iteration_statement .)
    FLOAT           reduce using rule 24 (statement -> iteration_statement .)
    CHAR            reduce using rule 24 (statement -> iteration_statement .)
    VOID            reduce using rule 24 (statement -> iteration_statement .)
    IDENTIFIER      reduce using rule 24 (statement -> iteration_statement .)
    MINUS           reduce using rule 24 (statement -> iteration_statement .)
    NOT             reduce using rule 24 (statement -> iteration_statement .)
    INC             reduce using rule 24 (statement -> iteration_statement .)
    DEC             reduce using rule 24 (statement -> iteration_statement .)
    INT_LITERAL     reduce using rule 24 (statement -> iteration_statement .)
    LPAREN          reduce using rule 24 (statement -> iteration_statement .)


state 86

    (25) statement -> return_statement .

    RBRACE          reduce using rule 25 (statement -> return_statement .)
    LBRACE          reduce using rule 25 (statement -> return_statement .)
    IF              reduce using rule 25 (statement -> return_statement .)
    WHILE           reduce using rule 25 (statement -> return_statement .)
    FOR             reduce using rule 25 (statement -> return_statement .)
    RETURN          reduce using rule 25 (statement -> return_statement .)
    INT             reduce using rule 25 (statement -> return_statement .)
    FLOAT           reduce using rule 25 (statement -> return_statement .)
    CHAR            reduce using rule 25 (statement -> return_statement .)
    VOID            reduce using rule 25 (statement -> return_statement .)
    IDENTIFIER      reduce using rule 25 (statement -> return_statement .)
    MINUS           reduce using rule 25 (statement -> return_statement .)
    NOT             reduce using rule 25 (statement -> return_statement .)
    INC             reduce using rule 25 (statement -> return_statement .)
    DEC             reduce using rule 25 (statement -> return_statement .)
    INT_LITERAL     reduce using rule 25 (statement -> return_statement .)
    LPAREN          reduce using rule 25 (statement -> return_statement .)


state 87

    (26) statement -> var_declaration .

    RBRACE          reduce using rule 26 (statement -> var_declaration .)
    LBRACE          reduce using rule 26 (statement -> var_declaration .)
    IF              reduce using rule 26 (statement -> var_declaration .)
    WHILE           reduce using rule 26 (statement -> var_declaration .)
    FOR             reduce using rule 26 (statement -> var_declaration .)
    RETURN          reduce using rule 26 (statement -> var_declaration .)
    INT             reduce using rule 26 (statement -> var_declaration .)
    FLOAT           reduce using rule 26 (statement -> var_declaration .)
    CHAR            reduce using rule 26 (statement -> var_declaration .)
    VOID            reduce using rule 26 (statement -> var_declaration .)
    IDENTIFIER      reduce using rule 26 (statement -> var_declaration .)
    MINUS           reduce using rule 26 (statement -> var_declaration .)
    NOT             reduce using rule 26 (statement -> var_declaration .)
    INC             reduce using rule 26 (statement -> var_declaration .)
    DEC             reduce using rule 26 (statement -> var_declaration .)
    INT_LITERAL     reduce using rule 26 (statement -> var_declaration .)
    LPAREN          reduce using rule 26 (statement -> var_declaration .)


state 88

    (27) statement -> empty .

    RBRACE          reduce using rule 27 (statement -> empty .)
    LBRACE          reduce using rule 27 (statement -> empty .)
    IF              reduce using rule 27 (statement -> empty .)
    WHILE           reduce using rule 27 (statement -> empty .)
    FOR             reduce using rule 27 (statement -> empty .)
    RETURN          reduce using rule 27 (statement -> empty .)
    INT             reduce using rule 27 (statement -> empty .)
    FLOAT           reduce using rule 27 (statement -> empty .)
    CHAR            reduce using rule 27 (statement -> empty .)
    VOID            reduce using rule 27 (statement -> empty .)
    IDENTIFIER      reduce using rule 27 (statement -> empty .)
    MINUS           reduce using rule 27 (statement -> empty .)
    NOT             reduce using rule 27 (statement -> empty .)
    INC             reduce using rule 27 (statement -> empty .)
    DEC             reduce using rule 27 (statement -> empty .)
    INT_LITERAL     reduce using rule 27 (statement -> empty .)
    LPAREN          reduce using rule 27 (statement -> empty .)


state 89

    (28) expression_statement -> expression . SEMICOLON
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    SEMICOLON       shift and go to state 98
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    EQ              shift and go to state 41
    NEQ             shift and go to state 42
    LT              shift and go to state 43
    GT              shift and go to state 44
    LTE             shift and go to state 45
    GTE             shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 90

    (59) selection_statement -> IF . LPAREN expression RPAREN compound_statement
    (60) selection_statement -> IF . LPAREN expression RPAREN compound_statement ELSE compound_statement

    LPAREN          shift and go to state 99


state 91

    (61) iteration_statement -> WHILE . LPAREN expression RPAREN statement

    LPAREN          shift and go to state 100


state 92

    (62) iteration_statement -> FOR . LPAREN expression_statement expression_statement expression RPAREN statement

    LPAREN          shift and go to state 101


state 93

    (63) return_statement -> RETURN . expression SEMICOLON
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 102
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 94

    (6) var_declaration -> type_specifier . IDENTIFIER SEMICOLON
    (7) var_declaration -> type_specifier . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 103


state 95

    (56) argument_list -> argument_list COMMA expression .
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    RPAREN          reduce using rule 56 (argument_list -> argument_list COMMA expression .)
    COMMA           reduce using rule 56 (argument_list -> argument_list COMMA expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    EQ              shift and go to state 41
    NEQ             shift and go to state 42
    LT              shift and go to state 43
    GT              shift and go to state 44
    LTE             shift and go to state 45
    GTE             shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 96

    (18) compound_statement -> LBRACE statement_list RBRACE .

    INT             reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)
    FLOAT           reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)
    CHAR            reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)
    VOID            reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)
    $end            reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)
    IF              reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)
    FOR             reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)
    IDENTIFIER      reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)
    MINUS           reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)
    NOT             reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)
    INC             reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)
    DEC             reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)
    INT_LITERAL     reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)
    ELSE            reduce using rule 18 (compound_statement -> LBRACE statement_list RBRACE .)


state 97

    (19) statement_list -> statement_list statement .

    RBRACE          reduce using rule 19 (statement_list -> statement_list statement .)
    LBRACE          reduce using rule 19 (statement_list -> statement_list statement .)
    IF              reduce using rule 19 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 19 (statement_list -> statement_list statement .)
    FOR             reduce using rule 19 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 19 (statement_list -> statement_list statement .)
    INT             reduce using rule 19 (statement_list -> statement_list statement .)
    FLOAT           reduce using rule 19 (statement_list -> statement_list statement .)
    CHAR            reduce using rule 19 (statement_list -> statement_list statement .)
    VOID            reduce using rule 19 (statement_list -> statement_list statement .)
    IDENTIFIER      reduce using rule 19 (statement_list -> statement_list statement .)
    MINUS           reduce using rule 19 (statement_list -> statement_list statement .)
    NOT             reduce using rule 19 (statement_list -> statement_list statement .)
    INC             reduce using rule 19 (statement_list -> statement_list statement .)
    DEC             reduce using rule 19 (statement_list -> statement_list statement .)
    INT_LITERAL     reduce using rule 19 (statement_list -> statement_list statement .)
    LPAREN          reduce using rule 19 (statement_list -> statement_list statement .)


state 98

    (28) expression_statement -> expression SEMICOLON .

    RBRACE          reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    LBRACE          reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    IF              reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    WHILE           reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    FOR             reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    RETURN          reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    INT             reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    FLOAT           reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    CHAR            reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    VOID            reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    MINUS           reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    NOT             reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    INC             reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    DEC             reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    INT_LITERAL     reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    LPAREN          reduce using rule 28 (expression_statement -> expression SEMICOLON .)


state 99

    (59) selection_statement -> IF LPAREN . expression RPAREN compound_statement
    (60) selection_statement -> IF LPAREN . expression RPAREN compound_statement ELSE compound_statement
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 104
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 100

    (61) iteration_statement -> WHILE LPAREN . expression RPAREN statement
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 105
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 101

    (62) iteration_statement -> FOR LPAREN . expression_statement expression_statement expression RPAREN statement
    (28) expression_statement -> . expression SEMICOLON
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression_statement           shift and go to state 106
    expression                     shift and go to state 89
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 102

    (63) return_statement -> RETURN expression . SEMICOLON
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    SEMICOLON       shift and go to state 107
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    EQ              shift and go to state 41
    NEQ             shift and go to state 42
    LT              shift and go to state 43
    GT              shift and go to state 44
    LTE             shift and go to state 45
    GTE             shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 103

    (6) var_declaration -> type_specifier IDENTIFIER . SEMICOLON
    (7) var_declaration -> type_specifier IDENTIFIER . ASSIGN expression SEMICOLON

    SEMICOLON       shift and go to state 13
    ASSIGN          shift and go to state 14


state 104

    (59) selection_statement -> IF LPAREN expression . RPAREN compound_statement
    (60) selection_statement -> IF LPAREN expression . RPAREN compound_statement ELSE compound_statement
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    RPAREN          shift and go to state 108
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    EQ              shift and go to state 41
    NEQ             shift and go to state 42
    LT              shift and go to state 43
    GT              shift and go to state 44
    LTE             shift and go to state 45
    GTE             shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 105

    (61) iteration_statement -> WHILE LPAREN expression . RPAREN statement
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    RPAREN          shift and go to state 109
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    EQ              shift and go to state 41
    NEQ             shift and go to state 42
    LT              shift and go to state 43
    GT              shift and go to state 44
    LTE             shift and go to state 45
    GTE             shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 106

    (62) iteration_statement -> FOR LPAREN expression_statement . expression_statement expression RPAREN statement
    (28) expression_statement -> . expression SEMICOLON
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression_statement           shift and go to state 110
    expression                     shift and go to state 89
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 107

    (63) return_statement -> RETURN expression SEMICOLON .

    RBRACE          reduce using rule 63 (return_statement -> RETURN expression SEMICOLON .)
    LBRACE          reduce using rule 63 (return_statement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 63 (return_statement -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 63 (return_statement -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 63 (return_statement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 63 (return_statement -> RETURN expression SEMICOLON .)
    INT             reduce using rule 63 (return_statement -> RETURN expression SEMICOLON .)
    FLOAT           reduce using rule 63 (return_statement -> RETURN expression SEMICOLON .)
    CHAR            reduce using rule 63 (return_statement -> RETURN expression SEMICOLON .)
    VOID            reduce using rule 63 (return_statement -> RETURN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 63 (return_statement -> RETURN expression SEMICOLON .)
    MINUS           reduce using rule 63 (return_statement -> RETURN expression SEMICOLON .)
    NOT             reduce using rule 63 (return_statement -> RETURN expression SEMICOLON .)
    INC             reduce using rule 63 (return_statement -> RETURN expression SEMICOLON .)
    DEC             reduce using rule 63 (return_statement -> RETURN expression SEMICOLON .)
    INT_LITERAL     reduce using rule 63 (return_statement -> RETURN expression SEMICOLON .)
    LPAREN          reduce using rule 63 (return_statement -> RETURN expression SEMICOLON .)


state 108

    (59) selection_statement -> IF LPAREN expression RPAREN . compound_statement
    (60) selection_statement -> IF LPAREN expression RPAREN . compound_statement ELSE compound_statement
    (18) compound_statement -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 76

    compound_statement             shift and go to state 111

state 109

    (61) iteration_statement -> WHILE LPAREN expression RPAREN . statement
    (21) statement -> . expression_statement
    (22) statement -> . compound_statement
    (23) statement -> . selection_statement
    (24) statement -> . iteration_statement
    (25) statement -> . return_statement
    (26) statement -> . var_declaration
    (27) statement -> . empty
    (28) expression_statement -> . expression SEMICOLON
    (18) compound_statement -> . LBRACE statement_list RBRACE
    (59) selection_statement -> . IF LPAREN expression RPAREN compound_statement
    (60) selection_statement -> . IF LPAREN expression RPAREN compound_statement ELSE compound_statement
    (61) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (62) iteration_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
    (63) return_statement -> . RETURN expression SEMICOLON
    (6) var_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (7) var_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (17) empty -> .
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (8) type_specifier -> . INT
    (9) type_specifier -> . FLOAT
    (10) type_specifier -> . CHAR
    (11) type_specifier -> . VOID
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 76
    IF              shift and go to state 90
    WHILE           shift and go to state 91
    FOR             shift and go to state 92
    RETURN          shift and go to state 93
    RBRACE          reduce using rule 17 (empty -> .)
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    CHAR            shift and go to state 9
    VOID            shift and go to state 10
    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

  ! LBRACE          [ reduce using rule 17 (empty -> .) ]
  ! IF              [ reduce using rule 17 (empty -> .) ]
  ! WHILE           [ reduce using rule 17 (empty -> .) ]
  ! FOR             [ reduce using rule 17 (empty -> .) ]
  ! RETURN          [ reduce using rule 17 (empty -> .) ]
  ! INT             [ reduce using rule 17 (empty -> .) ]
  ! FLOAT           [ reduce using rule 17 (empty -> .) ]
  ! CHAR            [ reduce using rule 17 (empty -> .) ]
  ! VOID            [ reduce using rule 17 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 17 (empty -> .) ]
  ! MINUS           [ reduce using rule 17 (empty -> .) ]
  ! NOT             [ reduce using rule 17 (empty -> .) ]
  ! INC             [ reduce using rule 17 (empty -> .) ]
  ! DEC             [ reduce using rule 17 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 17 (empty -> .) ]
  ! LPAREN          [ reduce using rule 17 (empty -> .) ]

    expression                     shift and go to state 89
    statement                      shift and go to state 112
    expression_statement           shift and go to state 82
    compound_statement             shift and go to state 83
    selection_statement            shift and go to state 84
    iteration_statement            shift and go to state 85
    return_statement               shift and go to state 86
    var_declaration                shift and go to state 87
    empty                          shift and go to state 88
    type_specifier                 shift and go to state 94
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 110

    (62) iteration_statement -> FOR LPAREN expression_statement expression_statement . expression RPAREN statement
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

    expression                     shift and go to state 113
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 111

    (59) selection_statement -> IF LPAREN expression RPAREN compound_statement .
    (60) selection_statement -> IF LPAREN expression RPAREN compound_statement . ELSE compound_statement

    RBRACE          reduce using rule 59 (selection_statement -> IF LPAREN expression RPAREN compound_statement .)
    LBRACE          reduce using rule 59 (selection_statement -> IF LPAREN expression RPAREN compound_statement .)
    IF              reduce using rule 59 (selection_statement -> IF LPAREN expression RPAREN compound_statement .)
    WHILE           reduce using rule 59 (selection_statement -> IF LPAREN expression RPAREN compound_statement .)
    FOR             reduce using rule 59 (selection_statement -> IF LPAREN expression RPAREN compound_statement .)
    RETURN          reduce using rule 59 (selection_statement -> IF LPAREN expression RPAREN compound_statement .)
    INT             reduce using rule 59 (selection_statement -> IF LPAREN expression RPAREN compound_statement .)
    FLOAT           reduce using rule 59 (selection_statement -> IF LPAREN expression RPAREN compound_statement .)
    CHAR            reduce using rule 59 (selection_statement -> IF LPAREN expression RPAREN compound_statement .)
    VOID            reduce using rule 59 (selection_statement -> IF LPAREN expression RPAREN compound_statement .)
    IDENTIFIER      reduce using rule 59 (selection_statement -> IF LPAREN expression RPAREN compound_statement .)
    MINUS           reduce using rule 59 (selection_statement -> IF LPAREN expression RPAREN compound_statement .)
    NOT             reduce using rule 59 (selection_statement -> IF LPAREN expression RPAREN compound_statement .)
    INC             reduce using rule 59 (selection_statement -> IF LPAREN expression RPAREN compound_statement .)
    DEC             reduce using rule 59 (selection_statement -> IF LPAREN expression RPAREN compound_statement .)
    INT_LITERAL     reduce using rule 59 (selection_statement -> IF LPAREN expression RPAREN compound_statement .)
    LPAREN          reduce using rule 59 (selection_statement -> IF LPAREN expression RPAREN compound_statement .)
    ELSE            shift and go to state 114


state 112

    (61) iteration_statement -> WHILE LPAREN expression RPAREN statement .

    RBRACE          reduce using rule 61 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    LBRACE          reduce using rule 61 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    IF              reduce using rule 61 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    WHILE           reduce using rule 61 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    FOR             reduce using rule 61 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    RETURN          reduce using rule 61 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    INT             reduce using rule 61 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    FLOAT           reduce using rule 61 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    CHAR            reduce using rule 61 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    VOID            reduce using rule 61 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    IDENTIFIER      reduce using rule 61 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    MINUS           reduce using rule 61 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    NOT             reduce using rule 61 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    INC             reduce using rule 61 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    DEC             reduce using rule 61 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    INT_LITERAL     reduce using rule 61 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    LPAREN          reduce using rule 61 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)


state 113

    (62) iteration_statement -> FOR LPAREN expression_statement expression_statement expression . RPAREN statement
    (34) binary_expression -> expression . PLUS expression
    (35) binary_expression -> expression . MINUS expression
    (36) binary_expression -> expression . TIMES expression
    (37) binary_expression -> expression . DIVIDE expression
    (38) binary_expression -> expression . MOD expression
    (39) binary_expression -> expression . EQ expression
    (40) binary_expression -> expression . NEQ expression
    (41) binary_expression -> expression . LT expression
    (42) binary_expression -> expression . GT expression
    (43) binary_expression -> expression . LTE expression
    (44) binary_expression -> expression . GTE expression
    (45) binary_expression -> expression . AND expression
    (46) binary_expression -> expression . OR expression

    RPAREN          shift and go to state 115
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    EQ              shift and go to state 41
    NEQ             shift and go to state 42
    LT              shift and go to state 43
    GT              shift and go to state 44
    LTE             shift and go to state 45
    GTE             shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 114

    (60) selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE . compound_statement
    (18) compound_statement -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 76

    compound_statement             shift and go to state 116

state 115

    (62) iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN . statement
    (21) statement -> . expression_statement
    (22) statement -> . compound_statement
    (23) statement -> . selection_statement
    (24) statement -> . iteration_statement
    (25) statement -> . return_statement
    (26) statement -> . var_declaration
    (27) statement -> . empty
    (28) expression_statement -> . expression SEMICOLON
    (18) compound_statement -> . LBRACE statement_list RBRACE
    (59) selection_statement -> . IF LPAREN expression RPAREN compound_statement
    (60) selection_statement -> . IF LPAREN expression RPAREN compound_statement ELSE compound_statement
    (61) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (62) iteration_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
    (63) return_statement -> . RETURN expression SEMICOLON
    (6) var_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (7) var_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (17) empty -> .
    (29) expression -> . assignment_expression
    (30) expression -> . binary_expression
    (31) expression -> . unary_expression
    (32) expression -> . term
    (8) type_specifier -> . INT
    (9) type_specifier -> . FLOAT
    (10) type_specifier -> . CHAR
    (11) type_specifier -> . VOID
    (33) assignment_expression -> . IDENTIFIER ASSIGN expression
    (34) binary_expression -> . expression PLUS expression
    (35) binary_expression -> . expression MINUS expression
    (36) binary_expression -> . expression TIMES expression
    (37) binary_expression -> . expression DIVIDE expression
    (38) binary_expression -> . expression MOD expression
    (39) binary_expression -> . expression EQ expression
    (40) binary_expression -> . expression NEQ expression
    (41) binary_expression -> . expression LT expression
    (42) binary_expression -> . expression GT expression
    (43) binary_expression -> . expression LTE expression
    (44) binary_expression -> . expression GTE expression
    (45) binary_expression -> . expression AND expression
    (46) binary_expression -> . expression OR expression
    (47) unary_expression -> . MINUS expression
    (48) unary_expression -> . NOT expression
    (49) unary_expression -> . INC IDENTIFIER
    (50) unary_expression -> . DEC IDENTIFIER
    (51) term -> . IDENTIFIER
    (52) term -> . INT_LITERAL
    (53) term -> . LPAREN expression RPAREN
    (54) term -> . function_call
    (55) function_call -> . IDENTIFIER LPAREN argument_list RPAREN

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 76
    IF              shift and go to state 90
    WHILE           shift and go to state 91
    FOR             shift and go to state 92
    RETURN          shift and go to state 93
    RBRACE          reduce using rule 17 (empty -> .)
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    CHAR            shift and go to state 9
    VOID            shift and go to state 10
    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 22
    NOT             shift and go to state 23
    INC             shift and go to state 24
    DEC             shift and go to state 25
    INT_LITERAL     shift and go to state 26
    LPAREN          shift and go to state 27

  ! LBRACE          [ reduce using rule 17 (empty -> .) ]
  ! IF              [ reduce using rule 17 (empty -> .) ]
  ! WHILE           [ reduce using rule 17 (empty -> .) ]
  ! FOR             [ reduce using rule 17 (empty -> .) ]
  ! RETURN          [ reduce using rule 17 (empty -> .) ]
  ! INT             [ reduce using rule 17 (empty -> .) ]
  ! FLOAT           [ reduce using rule 17 (empty -> .) ]
  ! CHAR            [ reduce using rule 17 (empty -> .) ]
  ! VOID            [ reduce using rule 17 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 17 (empty -> .) ]
  ! MINUS           [ reduce using rule 17 (empty -> .) ]
  ! NOT             [ reduce using rule 17 (empty -> .) ]
  ! INC             [ reduce using rule 17 (empty -> .) ]
  ! DEC             [ reduce using rule 17 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 17 (empty -> .) ]
  ! LPAREN          [ reduce using rule 17 (empty -> .) ]

    expression_statement           shift and go to state 82
    expression                     shift and go to state 89
    statement                      shift and go to state 117
    compound_statement             shift and go to state 83
    selection_statement            shift and go to state 84
    iteration_statement            shift and go to state 85
    return_statement               shift and go to state 86
    var_declaration                shift and go to state 87
    empty                          shift and go to state 88
    type_specifier                 shift and go to state 94
    assignment_expression          shift and go to state 18
    binary_expression              shift and go to state 19
    unary_expression               shift and go to state 20
    term                           shift and go to state 21
    function_call                  shift and go to state 28

state 116

    (60) selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement .

    RBRACE          reduce using rule 60 (selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement .)
    LBRACE          reduce using rule 60 (selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement .)
    IF              reduce using rule 60 (selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement .)
    WHILE           reduce using rule 60 (selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement .)
    FOR             reduce using rule 60 (selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement .)
    RETURN          reduce using rule 60 (selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement .)
    INT             reduce using rule 60 (selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement .)
    FLOAT           reduce using rule 60 (selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement .)
    CHAR            reduce using rule 60 (selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement .)
    VOID            reduce using rule 60 (selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement .)
    IDENTIFIER      reduce using rule 60 (selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement .)
    MINUS           reduce using rule 60 (selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement .)
    NOT             reduce using rule 60 (selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement .)
    INC             reduce using rule 60 (selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement .)
    DEC             reduce using rule 60 (selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement .)
    INT_LITERAL     reduce using rule 60 (selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement .)
    LPAREN          reduce using rule 60 (selection_statement -> IF LPAREN expression RPAREN compound_statement ELSE compound_statement .)


state 117

    (62) iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .

    RBRACE          reduce using rule 62 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    LBRACE          reduce using rule 62 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    IF              reduce using rule 62 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    WHILE           reduce using rule 62 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    FOR             reduce using rule 62 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    RETURN          reduce using rule 62 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    INT             reduce using rule 62 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    FLOAT           reduce using rule 62 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    CHAR            reduce using rule 62 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    VOID            reduce using rule 62 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    IDENTIFIER      reduce using rule 62 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    MINUS           reduce using rule 62 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    NOT             reduce using rule 62 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    INC             reduce using rule 62 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    DEC             reduce using rule 62 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    INT_LITERAL     reduce using rule 62 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
    LPAREN          reduce using rule 62 (iteration_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 57 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 57 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 57 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 57 resolved as shift
WARNING: shift/reduce conflict for MOD in state 57 resolved as shift
WARNING: shift/reduce conflict for EQ in state 57 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 57 resolved as shift
WARNING: shift/reduce conflict for LT in state 57 resolved as shift
WARNING: shift/reduce conflict for GT in state 57 resolved as shift
WARNING: shift/reduce conflict for LTE in state 57 resolved as shift
WARNING: shift/reduce conflict for GTE in state 57 resolved as shift
WARNING: shift/reduce conflict for AND in state 57 resolved as shift
WARNING: shift/reduce conflict for OR in state 57 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 76 resolved as shift
WARNING: shift/reduce conflict for IF in state 76 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 76 resolved as shift
WARNING: shift/reduce conflict for FOR in state 76 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 76 resolved as shift
WARNING: shift/reduce conflict for INT in state 76 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 76 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 76 resolved as shift
WARNING: shift/reduce conflict for VOID in state 76 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 76 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 76 resolved as shift
WARNING: shift/reduce conflict for NOT in state 76 resolved as shift
WARNING: shift/reduce conflict for INC in state 76 resolved as shift
WARNING: shift/reduce conflict for DEC in state 76 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 76 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 76 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 80 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 80 resolved as shift
WARNING: shift/reduce conflict for IF in state 80 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 80 resolved as shift
WARNING: shift/reduce conflict for FOR in state 80 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 80 resolved as shift
WARNING: shift/reduce conflict for INT in state 80 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 80 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 80 resolved as shift
WARNING: shift/reduce conflict for VOID in state 80 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 80 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 80 resolved as shift
WARNING: shift/reduce conflict for NOT in state 80 resolved as shift
WARNING: shift/reduce conflict for INC in state 80 resolved as shift
WARNING: shift/reduce conflict for DEC in state 80 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 80 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 80 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 109 resolved as shift
WARNING: shift/reduce conflict for IF in state 109 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 109 resolved as shift
WARNING: shift/reduce conflict for FOR in state 109 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 109 resolved as shift
WARNING: shift/reduce conflict for INT in state 109 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 109 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 109 resolved as shift
WARNING: shift/reduce conflict for VOID in state 109 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 109 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 109 resolved as shift
WARNING: shift/reduce conflict for NOT in state 109 resolved as shift
WARNING: shift/reduce conflict for INC in state 109 resolved as shift
WARNING: shift/reduce conflict for DEC in state 109 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 109 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 109 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 115 resolved as shift
WARNING: shift/reduce conflict for IF in state 115 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 115 resolved as shift
WARNING: shift/reduce conflict for FOR in state 115 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 115 resolved as shift
WARNING: shift/reduce conflict for INT in state 115 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 115 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 115 resolved as shift
WARNING: shift/reduce conflict for VOID in state 115 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 115 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 115 resolved as shift
WARNING: shift/reduce conflict for NOT in state 115 resolved as shift
WARNING: shift/reduce conflict for INC in state 115 resolved as shift
WARNING: shift/reduce conflict for DEC in state 115 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 115 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 115 resolved as shift
